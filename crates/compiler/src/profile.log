SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-cool/plugin/cool.vim
Sourced 1 time
Total time:   0.000976
 Self time:   0.000867

count  total (s)   self (s)
                            " vim-cool - Disable hlsearch when you are done searching.
                            " Maintainer:	romainl <romainlafourcade@gmail.com>
                            " Version:	0.0.2
                            " License:	MIT License
                            " Location:	plugin/cool.vim
                            " Website:	https://github.com/romainl/vim-cool
                            
    1              0.000027 if exists("g:loaded_cool") || v:version < 704 || &compatible
                                finish
    1              0.000002 endif
    1              0.000007 let g:loaded_cool = 1
                            
    1              0.000010 let s:save_cpo = &cpo
    1   0.000017   0.000014 set cpo&vim
                            
    1              0.000005 augroup Cool
    1              0.000021     autocmd!
    1              0.000001 augroup END
                            
    1              0.000005 if exists('##OptionSet')
    1              0.000007     if !exists('*execute')
                                    autocmd Cool OptionSet highlight let <SID>saveh = &highlight
    1              0.000001     endif
                                " toggle coolness when hlsearch is toggled
    1              0.000030     autocmd Cool OptionSet hlsearch call <SID>PlayItCool(v:option_old, v:option_new)
    1              0.000002 endif
                            
    1              0.000007 function! s:StartHL()
                                if !v:hlsearch || mode() isnot 'n'
                                    return
                                endif
                                let g:cool_is_searching = 1
                                let [pos, rpos] = [winsaveview(), getpos('.')]
                                silent! exe "keepjumps go".(line2byte('.')+col('.')-(v:searchforward ? 2 : 0))
                                try
                                    silent keepjumps norm! n
                                    if getpos('.') != rpos
                                        throw 0
                                    endif
                                catch /^\%(0$\|Vim\%(\w\|:Interrupt$\)\@!\)/
                                    call <SID>StopHL()
                                    return
                                finally
                                    call winrestview(pos)
                                endtry
                                if !get(g:,'cool_total_matches') || !exists('*reltimestr')
                                    return
                                endif
                                exe "silent! norm! :let g:cool_char=nr2char(screenchar(screenrow(),1))\<cr>"
                                let cool_char = remove(g:,'cool_char')
                                if cool_char !~ '[/?]'
                                    return
                                endif
                                let [f, ws, now, noOf] = [0, &wrapscan, reltime(), [0,0]]
                                set nowrapscan
                                try
                                    while f < 2
                                        if reltimestr(reltime(now))[:-6] =~ '[1-9]'
                                            " time >= 100ms
                                            return
                                        endif
                                        let noOf[v:searchforward ? f : !f] += 1
                                        try
                                            silent exe "keepjumps norm! ".(f ? 'n' : 'N')
                                        catch /^Vim[^)]\+):E38[45]\D/
                                            call setpos('.',rpos)
                                            let f += 1
                                        endtry
                                    endwhile
                                finally
                                    call winrestview(pos)
                                    let &wrapscan = ws
                                endtry
                                redraw|echo cool_char.@/ 'match' noOf[0] 'of' noOf[0] + noOf[1] - 1
                            endfunction
                            
    1              0.000003 function! s:StopHL()
                                if !v:hlsearch || mode() isnot 'n'
                                    return
                                else
                                    let g:cool_is_searching = 0
                                    silent call feedkeys("\<Plug>(StopHL)", 'm')
                                endif
                            endfunction
                            
    1              0.000004 if !exists('*execute')
                                let s:saveh = &highlight
                                " toggle highlighting, a workaround for :nohlsearch in autocmds
                                function! s:AuNohlsearch()
                                    noautocmd set highlight+=l:-
                                    autocmd Cool Insertleave *
                                                \ noautocmd let &highlight = s:saveh | autocmd! Cool InsertLeave *
                                    return ''
                                endfunction
    1              0.000001 endif
                            
    1              0.000004 function! s:PlayItCool(old, new)
                                if a:old == 0 && a:new == 1
                                    " nohls --> hls
                                    "   set up coolness
                                    noremap <silent> <Plug>(StopHL) :<C-U>nohlsearch<cr>
                                    if !exists('*execute')
                                        noremap! <expr> <Plug>(StopHL) <SID>AuNohlsearch()
                            
                                        " If no "execute()", ":tnoremap" isn't probably implemented too.
                                    else
                                        noremap! <expr> <Plug>(StopHL) execute('nohlsearch')[-1]
                                        if exists(':tnoremap')
                                            tnoremap <expr> <Plug>(StopHL) execute('nohlsearch')[-1]
                                        endif
                                    endif
                            
                                    autocmd Cool CursorMoved * call <SID>StartHL()
                                    autocmd Cool InsertEnter * call <SID>StopHL()
                                elseif a:old == 1 && a:new == 0
                                    " hls --> nohls
                                    "   tear down coolness
                                    nunmap <Plug>(StopHL)
                                    unmap! <expr> <Plug>(StopHL)
                                    if exists(':tunmap')
                                        tunmap <Plug>(StopHL)
                                    endif
                            
                                    autocmd! Cool CursorMoved
                                    autocmd! Cool InsertEnter
                                else
                                    " nohls --> nohls
                                    "   do nothing
                                    return
                                endif
                            endfunction
                            
                            " play it cool
    1   0.000123   0.000020 call <SID>PlayItCool(0, &hlsearch)
                            
    1   0.000022   0.000019 let &cpo = s:save_cpo

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/ftplugin/rust.vim
Sourced 2 times
Total time:   0.000665
 Self time:   0.000665

count  total (s)   self (s)
                            " Language:     Rust
                            " Description:  Vim ftplugin for Rust
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Maintainer:   Kevin Ballard <kevin@sb.org>
                            " Last Change:  June 08, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim 
                            
    2              0.000005 if exists("b:did_ftplugin")
                            	finish
    2              0.000001 endif
    2              0.000003 let b:did_ftplugin = 1
                            
    2              0.000005 let s:save_cpo = &cpo
    2              0.000010 set cpo&vim
                            
    2              0.000003 augroup rust.vim
    2              0.000013 autocmd!
                            
                            " Variables {{{1
                            
                            " The rust source code at present seems to typically omit a leader on /*!
                            " comments, so we'll use that as our default, but make it easy to switch.
                            " This does not affect indentation at all (I tested it with and without
                            " leader), merely whether a leader is inserted by default or not.
    2              0.000005 if exists("g:rust_bang_comment_leader") && g:rust_bang_comment_leader != 0
                            	" Why is the `,s0:/*,mb:\ ,ex:*/` there, you ask? I don't understand why,
                            	" but without it, */ gets indented one space even if there were no
                            	" leaders. I'm fairly sure that's a Vim bug.
                            	setlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\ ,ex:*/,:///,://!,://
    2              0.000001 else
    2              0.000006 	setlocal comments=s0:/*!,m:\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://
    2              0.000001 endif
    2              0.000003 setlocal commentstring=//%s
    2              0.000006 setlocal formatoptions-=t formatoptions+=croqnl
                            " j was only added in 7.3.541, so stop complaints about its nonexistence
    2              0.000004 silent! setlocal formatoptions+=j
                            
                            " smartindent will be overridden by indentexpr if filetype indent is on, but
                            " otherwise it's better than nothing.
    2              0.000007 setlocal smartindent nocindent
                            
    2              0.000004 if !exists("g:rust_recommended_style") || g:rust_recommended_style != 0
    2              0.000011 	setlocal tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    2              0.000003 	setlocal textwidth=99
    2              0.000001 endif
                            
                            " This includeexpr isn't perfect, but it's a good start
    2              0.000003 setlocal includeexpr=substitute(v:fname,'::','/','g')
                            
    2              0.000002 setlocal suffixesadd=.rs
                            
    2              0.000003 if exists("g:ftplugin_rust_source_path")
                                let &l:path=g:ftplugin_rust_source_path . ',' . &l:path
    2              0.000001 endif
                            
    2              0.000002 if exists("g:loaded_delimitMate")
                            	if exists("b:delimitMate_excluded_regions")
                            		let b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions
                            	endif
                            
                            	let s:delimitMate_extra_excluded_regions = ',rustLifetimeCandidate,rustGenericLifetimeCandidate'
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_map`
                            	" event in the autocommand system, add the above-defined extra excluded
                            	" regions to delimitMate's state, if they have not already been added.
                            	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_map' && match(
                            		\     delimitMate#Get("excluded_regions"),
                            		\     s:delimitMate_extra_excluded_regions) == -1
                            		\|  let b:delimitMate_excluded_regions =
                            		\       delimitMate#Get("excluded_regions")
                            		\       . s:delimitMate_extra_excluded_regions
                            		\|endif
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_unmap`
                            	" event in the autocommand system, delete the above-defined extra excluded
                            	" regions from delimitMate's state (the deletion being idempotent and
                            	" having no effect if the extra excluded regions are not present in the
                            	" targeted part of delimitMate's state).
                            	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_unmap'
                            		\|  let b:delimitMate_excluded_regions = substitute(
                            		\       delimitMate#Get("excluded_regions"),
                            		\       '\C\V' . s:delimitMate_extra_excluded_regions,
                            		\       '', 'g')
                            		\|endif
    2              0.000001 endif
                            
    2              0.000006 if has("folding") && exists('g:rust_fold') && g:rust_fold != 0
                            	let b:rust_set_foldmethod=1
                            	setlocal foldmethod=syntax
                            	if g:rust_fold == 2
                            		setlocal foldlevel<
                            	else
                            		setlocal foldlevel=99
                            	endif
    2              0.000001 endif
                            
    2              0.000004 if has('conceal') && exists('g:rust_conceal') && g:rust_conceal != 0
                            	let b:rust_set_conceallevel=1
                            	setlocal conceallevel=2
    2              0.000001 endif
                            
                            " Motion Commands {{{1
                            
                            " Bind motion commands to support hanging indents
    2              0.000010 nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>
    2              0.000004 nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>
    2              0.000004 xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>
    2              0.000003 xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>
    2              0.000003 onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>
    2              0.000003 onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>
                            
                            " Commands {{{1
                            
                            " See |:RustRun| for docs
    2              0.000009 command! -nargs=* -complete=file -bang -buffer RustRun call rust#Run(<bang>0, <q-args>)
                            
                            " See |:RustExpand| for docs
    2              0.000006 command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -buffer RustExpand call rust#Expand(<bang>0, <q-args>)
                            
                            " See |:RustEmitIr| for docs
    2              0.000003 command! -nargs=* -buffer RustEmitIr call rust#Emit("llvm-ir", <q-args>)
                            
                            " See |:RustEmitAsm| for docs
    2              0.000003 command! -nargs=* -buffer RustEmitAsm call rust#Emit("asm", <q-args>)
                            
                            " See |:RustPlay| for docs
    2              0.000010 command! -range=% RustPlay :call rust#Play(<count>, <line1>, <line2>, <f-args>)
                            
                            " See |:RustFmt| for docs
    2              0.000003 command! -buffer RustFmt call rustfmt#Format()
                            
                            " See |:RustFmtRange| for docs
    2              0.000005 command! -range -buffer RustFmtRange call rustfmt#FormatRange(<line1>, <line2>)
                            
                            " Mappings {{{1
                            
                            " Bind ⌘R in MacVim to :RustRun
    2              0.000003 nnoremap <silent> <buffer> <D-r> :RustRun<CR>
                            " Bind ⌘⇧R in MacVim to :RustRun! pre-filled with the last args
    2              0.000009 nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>
                            
    2              0.000004 if !exists("b:rust_last_rustc_args") || !exists("b:rust_last_args")
    2              0.000003 	let b:rust_last_rustc_args = []
    2              0.000002 	let b:rust_last_args = []
    2              0.000001 endif
                            
                            " Cleanup {{{1
                            
    2              0.000027 let b:undo_ftplugin = "
                            		\ setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<
                            		\|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<
                            		\|if exists('b:rust_original_delimitMate_excluded_regions')
                            		  \|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions
                            		  \|unlet b:rust_original_delimitMate_excluded_regions
                            		\|else
                            		  \|unlet! b:delimitMate_excluded_regions
                            		\|endif
                            		\|if exists('b:rust_set_foldmethod')
                            		  \|setlocal foldmethod< foldlevel<
                            		  \|unlet b:rust_set_foldmethod
                            		\|endif
                            		\|if exists('b:rust_set_conceallevel')
                            		  \|setlocal conceallevel<
                            		  \|unlet b:rust_set_conceallevel
                            		\|endif
                            		\|unlet! b:rust_last_rustc_args b:rust_last_args
                            		\|delcommand RustRun
                            		\|delcommand RustExpand
                            		\|delcommand RustEmitIr
                            		\|delcommand RustEmitAsm
                            		\|delcommand RustPlay
                            		\|nunmap <buffer> <D-r>
                            		\|nunmap <buffer> <D-R>
                            		\|nunmap <buffer> [[
                            		\|nunmap <buffer> ]]
                            		\|xunmap <buffer> [[
                            		\|xunmap <buffer> ]]
                            		\|ounmap <buffer> [[
                            		\|ounmap <buffer> ]]
                            		\|set matchpairs-=<:>
                            		\"
                            
                            " }}}1
                            
                            " Code formatting on save
    2              0.000004 if get(g:, "rustfmt_autosave", 0)
                            	autocmd BufWritePre *.rs silent! call rustfmt#Format()
    2              0.000001 endif
                            
    2              0.000001 augroup END
                            
    2              0.000009 let &cpo = s:save_cpo
    2              0.000002 unlet s:save_cpo
                            
                            " vim: set noet sw=8 ts=8:

SCRIPT  /Users/klasseg/.config/nvim/after/ftplugin/rust.lua
Sourced 2 times
Total time:   0.000508
 Self time:   0.000508

count  total (s)   self (s)
                            vim.cmd [[
                              nno  <buffer> < a<><C-c>i|     " Generics
                              vmap <buffer> » sa<hiBox<C-c>| " Box
                              hi @type guifg=none guibg=none gui=none
                            
                              let g:rustfmt_fail_silently = 1
                              " let g:rust_fold = 1
                              let g:rust_clip_command = 'pbcopy'
                            
                              normal zR
                              set nowrap
                            
                              " hi Function ctermfg=31 cterm=bold
                              " hi Function ctermfg=238 cterm=bold
                            ]]

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/indent/rust.vim
Sourced 2 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         Rust
                            " Author:           Chris Morgan <me@chrismorgan.info>
                            " Last Change:      2017 Jun 13
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
                            " Only load this indent file when no other was loaded.
    2              0.000004 if exists("b:did_indent")
                            	finish
    2              0.000001 endif
    2              0.000002 let b:did_indent = 1
                            
    2              0.000004 setlocal cindent
    2              0.000004 setlocal cinoptions=L0,(0,Ws,J1,j1
    2              0.000003 setlocal cinkeys=0{,0},!^F,o,O,0[,0]
                            " Don't think cinwords will actually do anything at all... never mind
    2              0.000004 setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern
                            
                            " Some preliminary settings
    2              0.000018 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    2              0.000003 setlocal autoindent	" indentexpr isn't much help otherwise
                            " Also do indentkeys, otherwise # gets shoved to column 0 :-/
    2              0.000003 setlocal indentkeys=0{,0},!^F,o,O,0[,0]
                            
    2              0.000002 setlocal indentexpr=GetRustIndent(v:lnum)
                            
                            " Only define the function once.
    2              0.000007 if exists("*GetRustIndent")
    1              0.000001 	finish
    1              0.000000 endif
                            
    1              0.000002 let s:save_cpo = &cpo
    1              0.000003 set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
    1              0.000002 function! s:get_line_trimmed(lnum)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
                            	let line = getline(a:lnum)
                            	let line_len = strlen(line)
                            	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
                            		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
                            		return substitute(line, "\s*$", "", "")
                            	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
                            		return substitute(line, "\s*//.*$", "", "")
                            	endif
                            endfunction
                            
    1              0.000001 function! s:is_string_comment(lnum, col)
                            	if has('syntax_items')
                            		for id in synstack(a:lnum, a:col)
                            			let synname = synIDattr(id, "name")
                            			if synname == "rustString" || synname =~ "^rustComment"
                            				return 1
                            			endif
                            		endfor
                            	else
                            		" without syntax, let's not even try
                            		return 0
                            	endif
                            endfunction
                            
    1              0.000001 function GetRustIndent(lnum)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
                            	let line = getline(a:lnum)
                            
                            	if has('syntax_items')
                            		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                            		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)'
                            					\ && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
                            	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
                            	let prevlinenum = prevnonblank(a:lnum - 1)
                            	let prevline = s:get_line_trimmed(prevlinenum)
                            	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
                            	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
                            	if prevline[len(prevline) - 1] == ","
                            				\ && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
                            	endif
                            
                            	if prevline[len(prevline) - 1] == ","
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]'
                            				\ && prevline !~ '^\s*fn\s'
                            				\ && prevline !~ '([^()]\+,$'
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
                            	endif
                            
                            	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW',
                            					\ 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW',
                            						\ 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
                            	endif
                            
                            	" Fall back on cindent, which does it mostly right
                            	return cindent(a:lnum)
                            endfunction
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
Sourced 1 time
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
                            if vim.g.lspconfig ~= nil then
                              return
                            end
                            vim.g.lspconfig = 1
                            
                            local api, lsp = vim.api, vim.lsp
                            
                            if vim.fn.has 'nvim-0.8' ~= 1 then
                              local version_info = vim.version()
                              local warning_str = string.format(
                                '[lspconfig] requires neovim 0.8 or later. Detected neovim version: 0.%s.%s',
                                version_info.minor,
                                version_info.patch
                              )
                              vim.notify_once(warning_str)
                              return
                            end
                            
                            local completion_sort = function(items)
                              table.sort(items)
                              return items
                            end
                            
                            local lsp_complete_configured_servers = function(arg)
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, require('lspconfig.util').available_servers()))
                            end
                            
                            local lsp_get_active_client_ids = function(arg)
                              local clients = vim.tbl_map(function(client)
                                return ('%d (%s)'):format(client.id, client.name)
                              end, require('lspconfig.util').get_managed_clients())
                            
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, clients))
                            end
                            
                            local get_clients_from_cmd_args = function(arg)
                              local result = {}
                              for id in (arg or ''):gmatch '(%d+)' do
                                result[#result + 1] = lsp.get_client_by_id(tonumber(id))
                              end
                              if #result == 0 then
                                return require('lspconfig.util').get_managed_clients()
                              end
                              return result
                            end
                            
                            for group, hi in pairs {
                              LspInfoBorder = { link = 'Label', default = true },
                              LspInfoList = { link = 'Function', default = true },
                              LspInfoTip = { link = 'Comment', default = true },
                              LspInfoTitle = { link = 'Title', default = true },
                              LspInfoFiletype = { link = 'Type', default = true },
                            } do
                              api.nvim_set_hl(0, group, hi)
                            end
                            
                            -- Called from plugin/lspconfig.vim because it requires knowing that the last
                            -- script in scriptnames to be executed is lspconfig.
                            api.nvim_create_user_command('LspInfo', function()
                              require 'lspconfig.ui.lspinfo'()
                            end, {
                              desc = 'Displays attached, active, and configured language servers',
                            })
                            
                            api.nvim_create_user_command('LspStart', function(info)
                              local server_name = string.len(info.args) > 0 and info.args or nil
                              if server_name then
                                local config = require('lspconfig.configs')[server_name]
                                if config then
                                  config.launch()
                                  return
                                end
                              end
                            
                              local matching_configs = require('lspconfig.util').get_config_by_ft(vim.bo.filetype)
                              for _, config in ipairs(matching_configs) do
                                config.launch()
                              end
                            end, {
                              desc = 'Manually launches a language server',
                              nargs = '?',
                              complete = lsp_complete_configured_servers,
                            })
                            
                            api.nvim_create_user_command('LspRestart', function(info)
                              local detach_clients = {}
                              for _, client in ipairs(get_clients_from_cmd_args(info.args)) do
                                client.stop()
                                if vim.tbl_count(client.attached_buffers) > 0 then
                                  detach_clients[client.name] = { client, client.attached_buffers }
                                end
                              end
                              local timer = vim.loop.new_timer()
                              timer:start(
                                500,
                                100,
                                vim.schedule_wrap(function()
                                  for client_name, tuple in pairs(detach_clients) do
                                    local client, attached_buffers = unpack(tuple)
                                    if client.is_stopped() then
                                      for buf in pairs(attached_buffers) do
                                        require('lspconfig.configs')[client_name].launch(buf)
                                      end
                                      detach_clients[client_name] = nil
                                    end
                                  end
                            
                                  if next(detach_clients) == nil and not timer:is_closing() then
                                    timer:close()
                                  end
                                end)
                              )
                            end, {
                              desc = 'Manually restart the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspStop', function(info)
                              local current_buf = vim.api.nvim_get_current_buf()
                              local server_id, force
                              local arguments = vim.split(info.args, '%s')
                              for _, v in pairs(arguments) do
                                if v == '++force' then
                                  force = true
                                elseif v:find '^[0-9]+$' then
                                  server_id = v
                                end
                              end
                            
                              if not server_id then
                                local servers_on_buffer = lsp.get_active_clients { bufnr = current_buf }
                                for _, client in ipairs(servers_on_buffer) do
                                  if client.attached_buffers[current_buf] then
                                    client.stop(force)
                                  end
                                end
                              else
                                for _, client in ipairs(get_clients_from_cmd_args(server_id)) do
                                  client.stop(force)
                                end
                              end
                            end, {
                              desc = 'Manually stops the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspLog', function()
                              vim.cmd(string.format('tabnew %s', lsp.get_log_path()))
                            end, {
                              desc = 'Opens the Nvim LSP client log.',
                            })

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-argwrap/plugin/argwrap.vim
Sourced 1 time
Total time:   0.000895
 Self time:   0.000465

count  total (s)   self (s)
                            " Copyright (c) 2014 Alex Yatskov <alex@foosoft.net>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy of
                            " this software and associated documentation files (the "Software"), to deal in
                            " the Software without restriction, including without limitation the rights to
                            " use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
                            " the Software, and to permit persons to whom the Software is furnished to do so,
                            " subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in all
                            " copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
                            " FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
                            " COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
                            " IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
                            " CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1   0.000703   0.000302 call argwrap#initSetting('line_prefix', '')
    1   0.000008   0.000004 call argwrap#initSetting('padded_braces', '')
    1   0.000006   0.000003 call argwrap#initSetting('tail_comma', 0)
    1   0.000006   0.000003 call argwrap#initSetting('tail_comma_braces', '')
    1   0.000006   0.000002 call argwrap#initSetting('tail_indent_braces', '')
    1   0.000006   0.000003 call argwrap#initSetting('wrap_closing_brace', 1)
    1   0.000005   0.000002 call argwrap#initSetting('comma_first', 0)
    1   0.000006   0.000003 call argwrap#initSetting('comma_first_indent', 0)
    1   0.000006   0.000003 call argwrap#initSetting('filetype_hooks', {})
    1   0.000005   0.000002 call argwrap#initSetting('php_smart_brace', 0)
                            
    1              0.000002 command! ArgWrap call argwrap#toggle()
                            
    1              0.000010 nnoremap <silent> <Plug>(ArgWrapToggle) :call argwrap#toggle() <BAR>
                              \ silent! call repeat#set("\<Plug>(ArgWrapToggle)")<CR>

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-argwrap/autoload/argwrap.vim
Sourced 1 time
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
                            " Copyright (c) 2014 Alex Yatskov <alex@foosoft.net>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy of
                            " this software and associated documentation files (the "Software"), to deal in
                            " the Software without restriction, including without limitation the rights to
                            " use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
                            " the Software, and to permit persons to whom the Software is furnished to do so,
                            " subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in all
                            " copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
                            " FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
                            " COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
                            " IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
                            " CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
                            
    1              0.000002 function! argwrap#validateRange(range)
                                return len(a:range) > 0 && !(a:range.lineStart == 0 && a:range.colStart == 0 || a:range.lineEnd == 0 && a:range.colEnd == 0)
                            endfunction
                            
    1              0.000001 function! argwrap#compareRanges(range1, range2)
                                let [l:buffer, l:line, l:col, l:offset] = getpos('.')
                            
                                let l:lineDiff1 = a:range1.lineStart - l:line
                                let l:colDiff1 = a:range1.colStart - l:col
                                let l:lineDiff2 = a:range2.lineStart - l:line
                                let l:colDiff2 = a:range2.colStart - l:col
                            
                                if l:lineDiff1 < l:lineDiff2
                                    return 1
                                elseif l:lineDiff1 > l:lineDiff2
                                    return -1
                                elseif l:colDiff1 < l:colDiff2
                                    return 1
                                elseif l:colDiff1 > l:colDiff2
                                    return -1
                                else
                                    return 0
                                endif
                            endfunction
                            
    1              0.000001 function! argwrap#findRange(braces)
                                let l:filter = 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"'
                                let [l:lineStart, l:colStart] = searchpairpos(a:braces[0], '', a:braces[1], 'Wcnb', filter)
                                let [l:lineEnd, l:colEnd] = searchpairpos(a:braces[0], '', a:braces[1], 'Wcn', filter)
                                return {'lineStart': l:lineStart, 'colStart': l:colStart, 'lineEnd': l:lineEnd, 'colEnd': l:colEnd}
                            endfunction
                            
    1              0.000001 function! argwrap#findClosestRange()
                                let l:ranges = []
                                for l:braces in [['(', ')'], ['\[', '\]'], ['{', '}']]
                                    let l:range = argwrap#findRange(braces)
                                    if argwrap#validateRange(l:range)
                                        call add(l:ranges, l:range)
                                    endif
                                endfor
                            
                                if len(l:ranges) == 0
                                    return {}
                                else
                                    return sort(l:ranges, 'argwrap#compareRanges')[0]
                                endif
                            endfunction
                            
    1              0.000001 function! argwrap#extractContainerArgText(range, linePrefix)
                                let l:text = ''
                                let l:trimPattern = printf('\m^\s*\(.\{-}\%%(%s\)\?\)\s*$', escape(a:linePrefix, '\$.*^['))
                            
                                for l:lineIndex in range(a:range.lineStart, a:range.lineEnd)
                                    let l:lineText = getline(l:lineIndex)
                            
                                    let l:extractStart = 0
                                    if l:lineIndex == a:range.lineStart
                                        let l:extractStart = a:range.colStart
                                    endif
                            
                                    let l:extractEnd = strlen(l:lineText)
                                    if l:lineIndex == a:range.lineEnd
                                        let l:extractEnd = a:range.colEnd - 1
                                    endif
                            
                                    if l:extractStart < l:extractEnd
                                        let l:extract = l:lineText[l:extractStart : l:extractEnd - 1]
                                        let l:extract = substitute(l:extract, l:trimPattern, '\1', '')
                                        if stridx(l:extract, a:linePrefix) == 0
                                            let l:extract = l:extract[len(a:linePrefix):]
                                        endif
                                        let l:extract = substitute(l:extract, ',$', ', ', '')
                                        let l:text .= l:extract
                                    endif
                                endfor
                            
                                return l:text
                            endfunction
                            
    1              0.000003 function! argwrap#updateScope(stack, char)
                                let l:pairs = {'"': '"', '''': '''', ')': '(', ']': '[', '}': '{'}
                                let l:length = len(a:stack)
                            
                                if l:length > 0 && get(l:pairs, a:char, '') == a:stack[l:length - 1]
                                    call remove(a:stack, l:length - 1)
                                elseif index(values(l:pairs), a:char) >= 0
                                    call add(a:stack, a:char)
                                endif
                            endfunction
                            
    1              0.000001 function! argwrap#trimArgument(text)
                                let l:trim = substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')
                                let l:trim = substitute(l:trim, '\([:=]\)\s\{2,}', '\1 ', '')
                                return substitute(l:trim, '\s\{2,}\([:=]\)', ' \1', '')
                            endfunction
                            
    1              0.000001 function! argwrap#extractContainerArgs(text)
                                let l:text = substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')
                            
                                let l:stack = []
                                let l:arguments = []
                                let l:argument = ''
                            
                                if len(l:text) > 0
                                    for l:index in range(strlen(l:text))
                                        let l:char = l:text[l:index]
                                        call argwrap#updateScope(l:stack, l:char)
                            
                                        if len(l:stack) == 0 && l:char == ','
                                            let l:argument = argwrap#trimArgument(l:argument)
                                            if len(l:argument) > 0
                                                call add(l:arguments, l:argument)
                                            endif
                                            let l:argument = ''
                                        else
                                            let l:argument .= l:char
                                        endif
                                    endfor
                            
                                    let l:argument = argwrap#trimArgument(l:argument)
                                    if len(l:argument) > 0
                                        call add(l:arguments, l:argument)
                                    endif
                                endif
                            
                                return l:arguments
                            endfunction
                            
    1              0.000001 function! argwrap#extractContainer(range)
                                let l:textStart = getline(a:range.lineStart)
                                let l:textEnd = getline(a:range.lineEnd)
                            
                                let l:indent = matchstr(l:textStart, '\s*')
                                let l:prefix = l:textStart[strlen(l:indent) : a:range.colStart - 1]
                                let l:suffix = l:textEnd[a:range.colEnd - 1:]
                            
                                return {'indent': l:indent, 'prefix': l:prefix, 'suffix': l:suffix}
                            endfunction
                            
    1              0.000002 function! argwrap#wrapContainer(range, container, arguments, wrapBrace, tailComma, tailCommaBraces, tailIndentBraces, linePrefix, commaFirst, commaFirstIndent)
                                let l:argCount = len(a:arguments)
                                let l:line = a:range.lineStart
                                let l:prefix = a:container.prefix[len(a:container.prefix) - 1]
                            
                                call setline(l:line, a:container.indent . a:container.prefix)
                            
                                for l:index in range(l:argCount)
                                    let l:last = l:index == l:argCount - 1
                                    let l:first = l:index == 0
                                    let l:text = ''
                            
                                    if a:commaFirst
                                        let l:text .= a:container.indent . a:linePrefix
                                        if !l:first
                                            let l:text .= ', '
                                        end
                                        let l:text .= a:arguments[l:index]
                                    else
                                        let l:text .= a:container.indent . a:linePrefix . a:arguments[l:index]
                                        if  !l:last || a:tailComma || a:tailCommaBraces =~ l:prefix
                                            let l:text .= ','
                                        end
                                    end
                            
                                    if l:last && !a:wrapBrace
                                        let l:text .= a:container.suffix
                                    end
                            
                                    call append(l:line, l:text)
                                    let l:line += 1
                                    silent! exec printf('%s>', l:line)
                            
                                    if l:first && a:commaFirstIndent
                                        let width = &l:shiftwidth
                                        let &l:shiftwidth = 2
                                        silent! exec printf('%s>', l:line)
                                        let &l:shiftwidth = l:width
                                    end
                                endfor
                            
                                if a:wrapBrace
                                    call append(l:line, a:container.indent . a:linePrefix . a:container.suffix)
                                    if a:tailIndentBraces =~ l:prefix
                                        silent! exec printf('%s>', l:line + 1)
                                    end
                                endif
                            endfunction
                            
    1              0.000001 function! argwrap#unwrapContainer(range, container, arguments, padded)
                                let l:brace = a:container.prefix[strlen(a:container.prefix) - 1]
                                if stridx(a:padded, l:brace) == -1
                                    let l:padding = ''
                                else
                                    let l:padding = ' '
                                endif
                            
                                let l:text = a:container.indent . a:container.prefix . l:padding . join(a:arguments, ', ') . l:padding . a:container.suffix
                                call setline(a:range.lineStart, l:text)
                                exec printf('silent %d,%dd_', a:range.lineStart + 1, a:range.lineEnd)
                            endfunction
                            
    1              0.000001 function! argwrap#getSetting(name)
                                let l:bName = 'b:argwrap_' . a:name
                                let l:gName = 'g:argwrap_' . a:name
                            
                                return exists(l:bName) ? {l:bName} : {l:gName}
                            endfunction
                            
    1              0.000001 function! argwrap#initSetting(name, value) abort
                                let l:setting = 'g:argwrap_'.a:name
                            
                                if !exists(l:setting)
                                    let {l:setting} = a:value
                                endif
                            endfunction
                            
    1              0.000002 function! argwrap#toggle()
                                let l:linePrefix = argwrap#getSetting('line_prefix')
                                let l:padded = argwrap#getSetting('padded_braces')
                                let l:tailComma = argwrap#getSetting('tail_comma')
                                let l:tailCommaBraces = argwrap#getSetting('tail_comma_braces')
                                let l:tailIndentBraces = argwrap#getSetting('tail_indent_braces')
                                let l:wrapBrace = argwrap#getSetting('wrap_closing_brace')
                                let l:commaFirst = argwrap#getSetting('comma_first')
                                let l:commaFirstIndent = argwrap#getSetting('comma_first_indent')
                            
                                let l:range = argwrap#findClosestRange()
                                if !argwrap#validateRange(l:range)
                                    return
                                endif
                            
                                let l:argText = argwrap#extractContainerArgText(l:range, l:linePrefix)
                                let l:arguments = argwrap#extractContainerArgs(l:argText)
                                if len(l:arguments) == 0
                                    return
                                endif
                            
                                let l:container = argwrap#extractContainer(l:range)
                                if l:range.lineStart == l:range.lineEnd
                                    call argwrap#hooks#execute('pre_wrap', l:range, l:container, l:arguments)
                                    call argwrap#wrapContainer(l:range, l:container, l:arguments, l:wrapBrace, l:tailComma, l:tailCommaBraces, l:tailIndentBraces, l:linePrefix, l:commaFirst, l:commaFirstIndent)
                                    call argwrap#hooks#execute('post_wrap', l:range, l:container, l:arguments)
                                else
                                    call argwrap#hooks#execute('pre_unwrap', l:range, l:container, l:arguments)
                                    call argwrap#unwrapContainer(l:range, l:container, l:arguments, l:padded)
                                    call argwrap#hooks#execute('post_unwrap', l:range, l:container, l:arguments)
                                endif
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-highlighturl/plugin/highlighturl.vim
Sourced 1 time
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: plugin/highlighturl.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2015/03/25 02:53:16.
                            " =============================================================================
                            
    1              0.000005 if exists('g:loaded_highlighturl') || v:version < 700 || !exists('*matchadd')
                              finish
    1              0.000000 endif
    1              0.000001 let g:loaded_highlighturl = 1
                            
    1              0.000003 let s:save_cpo = &cpo
    1              0.000003 set cpo&vim
                            
    1              0.000001 augroup highlighturl
    1              0.000004   autocmd!
    1              0.000003   autocmd VimEnter,ColorScheme * call highlighturl#set_highlight()
    1              0.000003   autocmd VimEnter,FileType,BufEnter,WinEnter * call highlighturl#set_url_match()
    1              0.000002   if v:version < 704 || v:version == 704 && !has('patch682')
                                autocmd CursorMoved,CursorMovedI * call highlighturl#check_urlcursor()
    1              0.000000   endif
    1              0.000000 augroup END
                            
    1              0.000004 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim
Sourced 1 time
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/highlighturl.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2022/04/28 09:31:53.
                            " =============================================================================
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000003 let s:urlcursor = v:version < 704 || v:version == 704 && !has('patch682')
                            
    1              0.000002 function! s:get(name, default) abort
                              return get(b:, 'highlighturl_' . a:name, get(g:, 'highlighturl_' . a:name, a:default))
                            endfunction
                            
    1              0.000001 function! highlighturl#default_pattern() abort
                              return  '\v\c%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)%('
                                    \.'[&:#*@~%_\-=?!+;/0-9a-z]+%(%([.;/?]|[.][.]+)[&:#*@~%_\-=?!+/0-9a-z]+|:\d+|'
                                    \.',%(%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)@![0-9a-z]+))*|'
                                    \.'\([&:#*@~%_\-=?!+;/.0-9a-z]*\)|\[[&:#*@~%_\-=?!+;/.0-9a-z]*\]|'
                                    \.'\{%([&:#*@~%_\-=?!+;/.0-9a-z]*|\{[&:#*@~%_\-=?!+;/.0-9a-z]*\})\})+'
                            endfunction
                            
    1              0.000001 function! highlighturl#get_url_highlight(cursor) abort
                              let cursor = a:cursor ? '_cursor' : ''
                              let term = s:get('term' . cursor, s:get('term_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
                              let cterm = s:get('cterm' . cursor, s:get('cterm_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
                              let ctermfg = s:get('ctermfg' . cursor, &background ==# 'dark' ? '44' : '31')
                              let gui = s:get('gui' . cursor, s:get('gui_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
                              let guifg = s:get('guifg' . cursor, &background ==# 'dark' ? '#00dfdf' : '#002f5f')
                              return 'term=' . term . ' cterm=' . cterm . ' ctermfg=' . ctermfg . ' gui=' . gui . ' guifg=' . guifg
                            endfunction
                            
    1              0.000001 function! highlighturl#set_highlight() abort
                              call highlighturl#set_url_highlight()
                              if s:urlcursor
                                call highlighturl#set_urlcursor_highlight()
                              endif
                            endfunction
                            
    1              0.000001 function! highlighturl#set_url_highlight() abort
                              execute 'highlight default HighlightUrl' highlighturl#get_url_highlight(0)
                            endfunction
                            
    1              0.000001 function! highlighturl#set_urlcursor_highlight() abort
                              redir => out
                                silent! highlight CursorLine
                              redir END
                              let outstr = substitute(out, '\n', '', 'g')
                              let cbg = matchstr(outstr, 'ctermbg=\S\+')
                              let gbg = matchstr(outstr, 'guibg=\S\+')
                              execute 'highlight default HighlightUrlCursor' highlighturl#get_url_highlight(1) cbg gbg
                            endfunction
                            
    1              0.000001 function! highlighturl#delete_url_match() abort
                              for m in getmatches()
                                if m.group ==# 'HighlightUrl' || m.group ==# 'HighlightUrlCursor'
                                  call matchdelete(m.id)
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! highlighturl#set_url_match() abort
                              call highlighturl#delete_url_match()
                              if s:get('enable', get(s:, 'enable', 1))
                                if !hlexists('HighlightUrl')
                                  call highlighturl#set_highlight()
                                endif
                                let pattern = s:get('pattern', highlighturl#default_pattern())
                                call matchadd('HighlightUrl', pattern, s:get('url_priority', 15))
                                if s:urlcursor
                                  call highlighturl#set_urlcursor_match()
                                endif
                              endif
                            endfunction
                            
    1              0.000001 let s:line = {}
    1              0.000001 let s:cursorline = {}
    1              0.000001 function! highlighturl#check_urlcursor() abort
                              if get(s:line, bufnr('')) != line('.') || get(s:cursorline, bufnr('')) != &l:cursorline
                                call highlighturl#set_urlcursor_match()
                              endif
                            endfunction
                            
    1              0.000001 let s:match_id = {}
    1              0.000001 function! highlighturl#set_urlcursor_match() abort
                              let bufnr = bufnr('')
                              let s:line[bufnr] = line('.')
                              let s:cursorline[bufnr] = &l:cursorline
                              if has_key(s:match_id, bufnr)
                                silent! call matchdelete(s:match_id[bufnr])
                              endif
                              if s:get('enable', get(s:, 'enable', 1))
                                let name = &l:cursorline ? 'HighlightUrlCursor': 'HighlightUrl'
                                let pattern = '\%' . line('.') . 'l' . s:get('pattern', highlighturl#default_pattern())
                                let s:match_id[bufnr] = matchadd(name, pattern, s:get('url_cursor_priority', 20))
                              endif
                            endfunction
                            
    1              0.000001 function! highlighturl#refresh() abort
                              let save_winnr = winnr()
                              for winnr in range(1, winnr('$'))
                                silent! noautocmd execute winnr 'wincmd w'
                                unlet! b:highlighturl_enable
                                call highlighturl#set_url_match()
                              endfor
                              silent! noautocmd execute save_winnr 'wincmd w'
                              return ''
                            endfunction
                            
    1              0.000001 function! highlighturl#enable() abort
                              let s:enable = 1
                              call highlighturl#refresh()
                              return ''
                            endfunction
                            
    1              0.000000 function! highlighturl#disable() abort
                              let s:enable = 0
                              call highlighturl#refresh()
                              return ''
                            endfunction
                            
    1              0.000000 function! highlighturl#toggle() abort
                              if get(s:, 'enable', 1)
                                call highlighturl#disable()
                              else
                                call highlighturl#enable()
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! highlighturl#enable_local() abort
                              let b:highlighturl_enable = 1
                              call highlighturl#set_url_match()
                              return ''
                            endfunction
                            
    1              0.000000 function! highlighturl#disable_local() abort
                              let b:highlighturl_enable = 0
                              call highlighturl#set_url_match()
                              return ''
                            endfunction
                            
    1              0.000000 function! highlighturl#toggle_local() abort
                              if s:get('enable', get(s:, 'enable', 1))
                                call highlighturl#disable_local()
                              else
                                call highlighturl#enable_local()
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/vim-matchup/autoload/matchup/util.vim
Sourced 1 time
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
                            " vim match-up - even better matching
                            "
                            " Maintainer: Andy Massimino
                            " Email:      a@normed.space
                            "
                            
    1              0.000003 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 function! matchup#util#command(cmd) " {{{1
                              let l:lines = ''
                              try
                                execute 'silent! redir => l:lines'
                                  silent! execute a:cmd
                                redir END
                              finally
                                return split(l:lines, '\n')
                              endtry
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#in_comment(...) " {{{1
                              return call('matchup#util#in_syntax', ['^Comment$'] + a:000)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#in_string(...) " {{{1
                              return call('matchup#util#in_syntax', ['^String$'] + a:000)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#in_comment_or_string(...) " {{{1
                              return call('matchup#util#in_syntax',
                                    \ ['\%(String\|Comment\)'] + a:000)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#in_syntax(name, ...) " {{{1
                              " usage: matchup#util#in_syntax(name, [line, col])
                              let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                            
                              " check syntax at position (same as matchit's s: method)
                              let l:syn = synIDattr(synID(l:pos[0], l:pos[1], 1), 'name')
                              return l:syn =~? a:name
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#in_synstack(name, ...) abort " {{{1
                              let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                              let l:syn = map(synstack(l:pos[0], l:pos[1]),
                                    \ "synIDattr(v:val, 'name')")
                              return match(l:syn, '^' . a:name . '$') >= 0
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#in_whitespace(...) " {{{1
                              let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                              return matchstr(getline(l:pos[0]), '\%'.l:pos[1].'c.') =~# '\s'
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#in_indent(...) " {{{1
                              let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                              return l:pos[1] > 0 && getline(l:pos[0]) =~# '^\s*\%'.(l:pos[1]+1).'c'
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#has_duplicate_str(list) " {{{1
                              if len(a:list) <= 1 | return 0 | endif
                              let l:seen = {}
                              for l:elem in a:list
                                if has_key(l:seen, l:elem)
                                  return 1
                                endif
                                let l:seen[l:elem] = 1
                              endfor
                              return 0
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#patch_match_words(from, to, ...) abort " {{{1
                              if !exists('b:match_words') | return | endif
                            
                              " if extra argument is given, give diagnostic information
                              if a:0
                                let l:first = stridx(b:match_words, a:from)
                                if l:first < 0
                                  echoerr 'match-up: patch_match_words:' a:from 'not found'
                                  return
                                elseif stridx(b:match_words, a:from, l:first+1) > -1
                                  echoerr 'match-up: patch_match_words: multiple occurences of' a:from
                                  return
                                endif
                              endif
                            
                              let b:match_words = substitute(b:match_words,
                                    \ '\V'.escape(a:from, '\'),
                                    \ escape(a:to, '\'),
                                    \ '')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#check_match_words(sha256) abort " {{{1
                              if !exists('b:match_words') | return 0 | endif
                              return sha256(b:match_words) =~# '^'.a:sha256
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#append_match_words(str) abort " {{{1
                              if !exists('b:match_words')
                                let b:match_words = ''
                              endif
                            
                              if len(b:match_words) && b:match_words[-1] !=# ',' && a:str[0] !=# ','
                                let b:match_words .= ','
                              endif
                              let b:match_words .= a:str
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#matchpref(id, default) abort " {{{1
                              return get(get(g:matchup_matchpref, &filetype, {}), a:id, a:default)
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! matchup#util#standard_html(...) abort " {{{1
                              let l:prefs = a:0 ? a:1 : {}
                              let l:variant = get(l:prefs, 'variant', 'html')
                            
                              let l:words = '<:>,<\@<=!--:-->'
                            
                              if l:variant ==# 'html' && get(l:prefs, 'lists', 0)
                                let l:words .= ',<\@<=[ou]l\>\g{hlend}[^>]*\%(>\|$\)'
                                      \ . ':<\@<=li\>'
                                      \ . ':<\@<=/[ou]l\g{hlend}>'
                                let l:words .= ',<\@<=dl\>\g{hlend}[^>]*\%(>\|$\)'
                                      \ . ':<\@<=d[td]\>'
                                      \ . ':<\@<=/dl\g{hlend}>'
                              endif
                            
                              if l:variant ==# 'html'
                                let l:words .= ',<\@<=\([^/!][^ \t>]*\)\g{hlend}'
                                      \ . '\%(>\|$\|[ \t][^>]*\%(>\|$\)\)'
                                      \ . ':<\@<=/\1\g{hlend}>'
                              elseif l:variant ==# 'xml'
                                let l:words .= ',<\@<=!\[CDATA\[:]]>'
                                let l:words .= ',<\@<=?\k\+:?>'
                                let l:words .= ',<\@<=\([^ \t>/]\+\)\g{hlend}'
                                      \ . '\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\)'
                                      \ . ':<\@<=/\1\g{hlend}>'
                                let l:words .= ',<\@<=\%([^ \t>/]\+\)\g{hlend}'
                                      \ . '\%(\s\+[^>]*[^/>]\|$\)'
                                      \ . ':/>'
                              else
                                echoerr 'match-up: invalid variant' l:variant
                              endif
                            
                              if !get(l:prefs, 'tagnameonly', 1)
                                let l:words = substitute(l:words, '\\g{hlend}', '', 'g')
                              endif
                            
                              return l:words
                            endfunction
                            
                            " }}}1
    1              0.000001 function! matchup#util#standard_xml(...) abort " {{{1
                              let l:prefs = a:0 ? copy(a:1) : {}
                              let l:prefs['variant'] = 'xml'
                              return matchup#util#standard_html(l:prefs)
                            endfunction
                            
                            " }}}1
                            
    1              0.000004 let &cpo = s:save_cpo
                            
                            " vim: fdm=marker sw=2

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim
Sourced 1 time
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    1              0.000008 let s:index = 0
    1              0.000002 let s:functions = {}
    1              0.000001 let s:token = 477094643697281 " random number
                            
    1              0.000002 function! wilder#lua#call(f, ...) abort
                              return wilder#lua#wrap(call(a:f, a:000))
                            endfunction
                            
    1              0.000001 function! wilder#lua#wrap(t) abort
                              if type(a:t) is v:t_string ||
                                    \ type(a:t) is v:t_number ||
                                    \ type(a:t) is v:t_bool ||
                                    \ a:t is v:null
                                return a:t
                              endif
                            
                              if type(a:t) is v:t_func
                                return s:wrap_function(a:t)
                              endif
                            
                              if type(a:t) is v:t_dict
                                for l:key in keys(a:t)
                                  let l:Value = a:t[l:key]
                                  let a:t[l:key] = wilder#lua#wrap(l:Value)
                                endfor
                              endif
                            
                              " v:t_list
                              return map(a:t, {_, x -> wilder#lua#wrap(x)})
                            endfunction
                            
    1              0.000002 function! s:wrap_function(f) abort
                              let l:index = s:index
                              let s:index += 1
                            
                              let s:functions[l:index] = a:f
                              return {
                                    \ 'index': l:index,
                                    \ 'name': get(a:f, 'name'),
                                    \ '__wilder_wrapped__': s:token,
                                    \ }
                            endfunction
                            
    1              0.000001 function! wilder#lua#call_wrapped_function(index, ...) abort
                              let l:F = s:functions[a:index]
                              let l:Result = call(l:F, a:000)
                              return wilder#lua#wrap(l:Result)
                            endfunction
                            
    1              0.000001 function! wilder#lua#unref_wrapped_function(index) abort
                              unlet s:functions[a:index]
                            endfunction
                            
    1              0.000001 function! wilder#lua#_get_functions() abort
                              return s:functions
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim
Sourced 1 time
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
    1              0.000002 function! wilder#in_context()
                              return wilder#main#in_context()
                            endfunction
                            
    1              0.000001 function! wilder#enable_cmdline_enter()
                              return wilder#main#enable_cmdline_enter()
                            endfunction
                            
    1              0.000000 function! wilder#enable()
                              return wilder#main#enable()
                            endfunction
                            
    1              0.000000 function! wilder#disable()
                              return wilder#main#disable()
                            endfunction
                            
    1              0.000000 function! wilder#toggle()
                              return wilder#main#toggle()
                            endfunction
                            
    1              0.000001 function! wilder#set_option(x, ...) abort
                              if !a:0
                                call wilder#options#set(a:x)
                              else
                                call wilder#options#set(a:x, a:1)
                              endif
                            endfunction
                            
    1              0.000000 function! wilder#next()
                              return wilder#main#next()
                            endfunction
                            
    1              0.000001 function! wilder#previous()
                              return wilder#main#previous()
                            endfunction
                            
    1              0.000001 function! wilder#resolve(ctx, x)
                              call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})
                            endfunction
                            
    1              0.000001 function! wilder#reject(ctx, x)
                              call timer_start(0, {-> wilder#pipeline#reject(a:ctx, a:x)})
                            endfunction
                            
                            " DEPRECATED: use wilder#resolve()
    1              0.000001 function! wilder#on_finish(ctx, x)
                              return call('wilder#resolve', [a:ctx, a:x])
                            endfunction
                            
                            " DEPRECATED: use wilder#reject()
    1              0.000001 function! wilder#on_error(ctx, x)
                              return call('wilder#reject', [a:ctx, a:x])
                            endfunction
                            
    1              0.000001 function! wilder#wait(f, ...)
                              if !a:0
                                return wilder#pipeline#wait(a:f)
                              elseif a:0 == 1
                                return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#can_reject_completion()
                              return wilder#main#can_reject_completion()
                            endfunction
                            
    1              0.000001 function! wilder#reject_completion()
                              return wilder#main#reject_completion()
                            endfunction
                            
    1              0.000001 function! wilder#can_accept_completion()
                              return wilder#main#can_accept_completion()
                            endfunction
                            
    1              0.000001 function! wilder#accept_completion(...)
                              let l:auto_select = get(a:, 1, 1)
                              return wilder#main#accept_completion(l:auto_select)
                            endfunction
                            
    1              0.000001 function! wilder#start_from_normal_mode()
                              return wilder#main#start_from_normal_mode()
                            endfunction
                            
    1              0.000001 function! wilder#make_hl(name, args, ...) abort
                              return wilder#highlight#make_hl(a:name, a:args, a:000)
                            endfunction
                            
    1              0.000001 function! wilder#make_temp_hl(name, args, ...) abort
                              return wilder#highlight#make_temp_hl(a:name, a:args, a:000)
                            endfunction
                            
    1              0.000001 function! wilder#hl_with_attr(name, hl_group, ...) abort
                              let l:attrs = {}
                              for l:attr in a:000
                                if l:attr[:1] ==# 'no'
                                  let l:attrs[l:attr[2:]] = v:false
                                else
                                  let l:attrs[l:attr] = v:true
                                endif
                              endfor
                              return wilder#make_hl(a:name, a:hl_group, [{}, l:attrs, l:attrs])
                            endfunction
                            
                            " DEPRECATED: use wilder#basic_highlighter()
    1              0.000001 function! wilder#query_highlighter(...)
                              return call('wilder#basic_highlighter', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#basic_highlighter()
    1              0.000001 function! wilder#query_common_subsequence_spans(...)
                              return call('wilder#basic_highlighter', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#basic_highlighter(...)
                              let l:opts = get(a:, 1, {})
                              return wilder#highlighter#basic_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#vim_basic_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              let l:opts.language = 'vim'
                              return wilder#highlighter#basic_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#python_basic_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              let l:opts.language = 'python'
                              return wilder#highlighter#basic_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#pcre2_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              return wilder#highlighter#pcre2_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#python_pcre2_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              let l:opts.language = 'python'
                              return wilder#highlighter#pcre2_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#lua_pcre2_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              let l:opts.language = 'lua'
                              return wilder#highlighter#pcre2_highlighter(l:opts)
                            endfunction
                            
                            " DEPRECATED: use wilder#pcre2_highlighter()
    1              0.000001 function! wilder#pcre2_capture_spans(...) abort
                              return call('wilder#pcre2_highlighter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#cpsm_highlighter(...) abort
                              return call('wilder#python_cpsm_highlighter', a:000)
                            endfunction
                            
    1              0.000002 function! wilder#python_cpsm_highlighter(...) abort
                              let l:opts = get(a:, 1, {})
                              return wilder#highlighter#python_cpsm_highlighter(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#lua_fzy_highlighter(...) abort
                              return wilder#highlighter#lua_fzy_highlighter()
                            endfunction
                            
    1              0.000001 function! wilder#highlighter_with_gradient(highlighter) abort
                              return wilder#highlighter#highlighter_with_gradient(a:highlighter)
                            endfunction
                            
                            " pipes
                            
    1              0.000001 function! wilder#_sleep(t) abort
                              " lambda functions do not have func-abort
                              " so it is possible for timer_start to throw an error
                              " followed by resolve being called
                              return {_, x -> {ctx -> timer_start(a:t, {-> wilder#resolve(ctx, x)})}}
                            endfunction
                            
    1              0.000000 function! wilder#branch(...) abort
                              return wilder#pipe#branch#(a:000)
                            endfunction
                            
    1              0.000000 function! wilder#map(...) abort
                              return wilder#pipe#map#(a:000)
                            endfunction
                            
    1              0.000001 function! wilder#subpipeline(f) abort
                              return wilder#pipe#subpipeline#(a:f)
                            endfunction
                            
    1              0.000000 function! wilder#check(...) abort
                              return wilder#pipe#check#(a:000)
                            endfunction
                            
    1              0.000001 function! wilder#if(condition, p) abort
                              if !a:condition
                                return {_, x -> x}
                              endif
                            
                              return {ctx, x -> a:p(ctx, x)}
                            endfunction
                            
    1              0.000001 function! wilder#debounce(t) abort
                              return wilder#pipe#debounce#(a:t)
                            endfunction
                            
    1              0.000000 function! wilder#result(...) abort
                              if !a:0
                                return wilder#pipe#result#()
                              else
                                return wilder#pipe#result#(a:1)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#result_output_escape(chars) abort
                              return wilder#pipe#result#escape_output_result(a:chars)
                            endfunction
                            
                            " DEPRECATED: Use wilder#vim_substring_pattern()
    1              0.000001 function! wilder#vim_substring() abort
                              return call('wilder#vim_substring_pattern', [])
                            endfunction
                            
    1              0.000001 function! wilder#vim_substring_pattern() abort
                              return {_, x -> x . (x[-1:] ==# '\' ? '\' : '') . '\k*'}
                            endfunction
                            
    1              0.000000 function! wilder#vim_search(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#pipe#vim_search#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#escape_python(str, ...) abort
                              let l:escaped_chars = get(a:, 1, '^$*+?|(){}[]')
                            
                              let l:chars = split(a:str, '\zs')
                              let l:res = ''
                            
                              let l:i = 0
                              while l:i < len(l:chars)
                                let l:char = l:chars[l:i]
                                if l:char ==# '\'
                                  if l:i+1 < len(l:chars)
                                    let l:res .= '\' . l:chars[l:i+1]
                                    let l:i += 2
                                  else
                                    let l:res .= '\\'
                                    let l:i += 1
                                  endif
                                elseif stridx(l:escaped_chars, l:char) != -1
                                  let l:res .= '\' . l:char
                                  let l:i += 1
                                else
                                  let l:res .= l:char
                                  let l:i += 1
                                endif
                              endwhile
                            
                              return l:res
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_substring_pattern()
    1              0.000001 function! wilder#python_substring() abort
                              return call('wilder#python_substring_pattern', [])
                            endfunction
                            
    1              0.000001 function! wilder#python_substring_pattern() abort
                              return {_, x -> '(' . wilder#escape_python(x) . ')\w*'}
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_fuzzy_pattern()
    1              0.000001 function! wilder#python_fuzzy_match(...) abort
                              return call('wilder#python_fuzzy_pattern', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzy_pattern(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#pipe#python_fuzzy_match#(l:args)
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_fuzzy_delimiter_pattern()
    1              0.000001 function! wilder#python_fuzzy_delimiter(...) abort
                              return call('wilder#python_fuzzy_delimiter_pattern', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzy_delimiter_pattern(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#pipe#python_fuzzy_delimiter#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#python_search(...) abort
                              let l:opts = a:0 > 0 ? a:1 : {}
                              return {_, x -> {ctx -> _wilder_python_search(ctx, l:opts, x)}}
                            endfunction
                            
    1              0.000001 function! wilder#_python_sleep(t) abort
                              return {_, x -> {ctx -> _wilder_python_sleep(ctx, a:t, x)}}
                            endfunction
                            
    1              0.000001 function! wilder#history(...) abort
                              if !a:0
                                return wilder#pipe#history#()
                              elseif a:0 == 1
                                return wilder#pipe#history#(a:1)
                              else
                                return wilder#pipe#history#(a:1, a:2)
                              endif
                            endfunction
                            
                            " sorters
                            
                            " DEPRECATED: Use wilder#lexical_sorter()
    1              0.000000 function! wilder#vim_sort() abort
                              return call('wilder#lexical_sorter', [])
                            endfunction
                            
    1              0.000001 function! wilder#lexical_sorter() abort
                              return call('wilder#transform#lexical_sorter', [])
                            endfunction
                            
    1              0.000000 function! wilder#lexical_sort(...) abort
                              return call('wilder#transform#lexical_sort', a:000)
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_lexical_sorter()
    1              0.000000 function! wilder#python_sort() abort
                              return call('wilder#python_lexical_sorter', [])
                            endfunction
                            
    1              0.000001 function! wilder#python_lexical_sorter() abort
                              return call('wilder#transform#python_lexical_sorter', [])
                            endfunction
                            
    1              0.000001 function! wilder#python_lexical_sort(...) abort
                              return call('wilder#transform#python_lexical_sort', a:000)
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_difflib_sorter()
    1              0.000001 function! wilder#python_sorter_difflib(...) abort
                              return call('wilder#python_difflib_sorter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_difflib_sorter(...) abort
                              return call('wilder#transform#python_difflib_sorter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_difflib_sort(...) abort
                              return call('wilder#transform#python_difflib_sort', a:000)
                            endfunction
                            
                            " DEPRECATED: Use wilder#python_fuzzywuzzy_sorter()
    1              0.000001 function! wilder#python_sorter_fuzzywuzzy(...) abort
                              return call('wilder#python_fuzzywuzzy_sorter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzywuzzy_sorter(...) abort
                              return call('wilder#transform#python_fuzzywuzzy_sorter', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#python_fuzzywuzzy_sort()
    1              0.000001 function! wilder#python_fuzzywuzzy(ctx, xs, query) abort
                              return call('wilder#python_fuzzywuzzy_sort', [a:ctx, {}, a:xs, a:query])
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzywuzzy_sort(...) abort
                              return call('wilder#transform#python_fuzzywuzzy_sort', a:000)
                            endfunction
                            
                            " filters
                            
                            " DEPRECATED: use wilder#uniq_filter()
    1              0.000000 function! wilder#uniq() abort
                              return call('wilder#uniq_filter', [])
                            endfunction
                            
    1              0.000001 function! wilder#uniq_filter() abort
                              return call('wilder#transform#uniq_filter', [])
                            endfunction
                            
    1              0.000000 function! wilder#uniq_filt(...) abort
                              return call('wilder#transform#uniq_filt', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#python_uniq_filter()
    1              0.000000 function! wilder#python_uniq() abort
                              return call('wilder#python_uniq_filter', [])
                            endfunction
                            
    1              0.000001 function! wilder#python_uniq_filter() abort
                              return call('wilder#transform#python_uniq_filter', [])
                            endfunction
                            
    1              0.000001 function! wilder#python_uniq_filt(...) abort
                              return call('wilder#transform#python_uniq_filt', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#fuzzy_filter()
    1              0.000000 function! wilder#filter_fuzzy() abort
                              return call('wilder#fuzzy_filter', [])
                            endfunction
                            
    1              0.000000 function! wilder#fuzzy_filter(...) abort
                              return call('wilder#transform#fuzzy_filter', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#fuzzy_filt(...) abort
                              return call('wilder#transform#fuzzy_filt', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#vim_fuzzy_filter() abort
                              return call('wilder#transform#vim_fuzzy_filter', [])
                            endfunction
                            
    1              0.000000 function! wilder#vim_fuzzy_filt(...) abort
                              return call('wilder#transform#vim_fuzzy_filt', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#python_fuzzy_filter()
    1              0.000001 function! wilder#python_filter_fuzzy(...) abort
                              return call('wilder#python_fuzzy_filter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzy_filter(...) abort
                              return call('wilder#transform#python_fuzzy_filter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fuzzy_filt(...) abort
                              return call('wilder#transform#python_fuzzy_filt', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#python_fruzzy_filter()
    1              0.000001 function! wilder#python_filter_fruzzy(...) abort
                              return call('wilder#python_fruzzy_filter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fruzzy_filter(...) abort
                              return call('wilder#transform#python_fruzzy_filter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_fruzzy_filt(...) abort
                              return call('wilder#transform#python_fruzzy_filt', a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#python_cpsm_filter()
    1              0.000000 function! wilder#python_filter_cpsm(...) abort
                              return call('wilder#python_cpsm_filter', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#python_cpsm_filter(...) abort
                              return call('wilder#transform#python_cpsm_filter', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#python_cpsm_filt(...) abort
                              return call('wilder#transform#python_cpsm_filt', a:000)
                            endfunction
                            
    1              0.000002 function! wilder#python_clap_filter(...) abort
                              return call('wilder#transform#python_clap_filter', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#python_clap_filt(...) abort
                              return call('wilder#transform#python_clap_filt', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#lua_fzy_filter() abort
                              return call('wilder#transform#lua_fzy_filter', [])
                            endfunction
                            
    1              0.000001 function! wilder#lua_fzy_filt(...) abort
                              return call('wilder#transform#lua_fzy_filt', a:000)
                            endfunction
                            
                            " pipelines
                            
    1              0.000000 function! wilder#search_pipeline(...) abort
                              let l:opts = get(a:, 1, {})
                            
                              return wilder#options#get('use_python_remote_plugin') ?
                                    \ wilder#python_search_pipeline(l:opts) :
                                    \ wilder#vim_search_pipeline(l:opts)
                            endfunction
                            
    1              0.000001 function! s:search_pipeline(...) abort
                              let l:opts = a:0 > 0 ? a:1 : {}
                            
                              let l:search_pipeline = get(l:opts, 'pipeline', [
                                    \ wilder#vim_substring(),
                                    \ wilder#vim_search(),
                                    \ wilder#result_output_escape('^$*~[]/\'),
                                    \ ])
                            
                              let l:skip_cmdtype_check = get(l:opts, 'skip_cmdtype_check', 0)
                            
                              let l:should_debounce = get(l:opts, 'debounce', 0) > 0
                              let l:Debounce = l:should_debounce ? wilder#debounce(l:opts['debounce']) : 0
                            
                              return [
                                    \ wilder#if(!l:skip_cmdtype_check,
                                    \   wilder#check({-> getcmdtype() ==# '/' || getcmdtype() ==# '?'})),
                                    \ wilder#if(l:should_debounce, l:Debounce),
                                    \ wilder#subpipeline({ctx, x -> l:search_pipeline + [
                                    \  wilder#result({
                                    \    'data': {ctx, data -> s:set_query(data, x)},
                                    \  }),
                                    \ ]})
                                    \ ]
                            endfunction
                            
    1              0.000001 function! s:set_query(data, x)
                              let l:data = a:data is v:null ? {} : a:data
                              if has_key(l:data, 'query')
                                return a:data
                              endif
                            
                              return extend(l:data, {'query': a:x})
                            endfunction
                            
    1              0.000001 function! wilder#vim_search_pipeline(...) abort
                              return s:search_pipeline(get(a:, 1, {}))
                            endfunction
                            
    1              0.000001 function! wilder#python_search_pipeline(...) abort
                              let l:opts = get(a:, 1, {})
                            
                              let l:Pattern = get(l:opts, 'pattern', get(l:opts, 'regex', 'substring'))
                              if type(l:Pattern) is v:t_func
                                " pass
                              elseif l:Pattern ==# 'fuzzy'
                                let l:Pattern = wilder#python_fuzzy_pattern()
                              elseif l:Pattern ==# 'fuzzy_delimiter'
                                let l:Pattern = wilder#python_fuzzy_delimiter_pattern()
                              else
                                let l:Pattern = wilder#python_substring_pattern()
                              endif
                            
                              let l:Sorter = get(l:opts, 'sorter', get(l:opts, 'sort', 0))
                            
                              let l:pipeline = [
                                    \ l:Pattern,
                                    \ wilder#subpipeline({ctx, x -> [
                                    \   wilder#python_search(s:extract_keys(l:opts, 'max_candidates', 'engine')),
                                    \   wilder#if(l:Sorter isnot 0, {ctx, xs -> l:Sorter(ctx, xs, ctx.input)}),
                                    \   wilder#result_output_escape('^$*~[]/\'),
                                    \   wilder#result({'data': {'pcre2.pattern': x}}),
                                    \ ]}),
                                    \ ]
                            
                              return s:search_pipeline({
                                    \ 'debounce': get(l:opts, 'debounce', 0),
                                    \ 'pipeline': l:pipeline,
                                    \ 'skip_cmdtype_check': get(l:opts, 'skip_cmdtype_check', 0),
                                    \ })
                            endfunction
                            
    1              0.000001 function! wilder#cmdline_pipeline(...) abort
                              return wilder#cmdline#pipeline(get(a:, 1, {}))
                            endfunction
                            
    1              0.000000 function! wilder#substitute_pipeline(...) abort
                              return wilder#cmdline#substitute_pipeline(get(a:, 1, {}))
                            endfunction
                            
    1              0.000001 function! wilder#python_file_finder_pipeline(...) abort
                              return wilder#cmdline#python_file_finder_pipeline(get(a:, 1, {}))
                            endfunction
                            
                            " renderer items
                            
                            " DEPRECATED: use wilder#wildmenu_index()
    1              0.000000 function! wilder#index(...) abort
                              return call('wilder#wildmenu_index', a:000)
                            endfunction
                            
    1              0.000000 function! wilder#wildmenu_index(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#renderer#component#wildmenu_index#(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_string()
    1              0.000000 function! wilder#string(str, ...) abort
                              return call('wilder#wildmenu_string', [str] + a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_string(str, ...) abort
                              if a:0
                                return [a:str, a:1]
                              endif
                            
                              return a:str
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_previous_arrow()
    1              0.000001 function! wilder#previous_arrow(...) abort
                              return call('wilder#wildmenu_previous_arrow', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_previous_arrow(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#renderer#component#wildmenu_arrows#previous(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_next_arrow()
    1              0.000001 function! wilder#next_arrow(...) abort
                              return call('wilder#wildmenu_next_arrow', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_next_arrow(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#renderer#component#wildmenu_arrows#next(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_powerline_separator()
    1              0.000001 function! wilder#separator(str, from, to, ...) abort
                              return call('wilder#wildmenu_powerline_separator', [a:str, a:from, a:to] + a:000)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_powerline_separator()
    1              0.000001 function! wilder#powerline_separator(str, from, to, ...) abort
                              return call('wilder#wildmenu_powerline_separator', [a:str, a:from, a:to] + a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_powerline_separator(str, from, to, ...) abort
                              if a:0
                                return wilder#renderer#component#wildmenu_separator#(a:str, a:from, a:to, a:1)
                              else
                                return wilder#renderer#component#wildmenu_separator#(a:str, a:from, a:to)
                              endif
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_spinner()
    1              0.000000 function! wilder#spinner(...) abort
                              return call('wilder#wildmenu_spinner', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_spinner(...) abort
                              let l:args = a:0 > 0 ? a:1 : {}
                              return wilder#renderer#component#wildmenu_spinner#(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_condition()
    1              0.000001 function! wilder#condition(predicate, if_true, ...) abort
                              return call('wilder#wildmenu_condition', [a:predicate, a:if_true] + a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_condition(predicate, if_true, ...) abort
                              let l:if_false = a:0 > 0 ? a:1 : []
                              return wilder#renderer#component#wildmenu_condition#(a:predicate, a:if_true, l:if_false)
                            endfunction
                            
    1              0.000000 function! wilder#popupmenu_scrollbar(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_scrollbar#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#popupmenu_spinner(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_spinner#(l:args)
                            endfunction
                            
    1              0.000000 function! wilder#popupmenu_devicons(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_devicons#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#popupmenu_buffer_flags(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_buffer_flags#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#popupmenu_empty_message(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_empty_message#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#popupmenu_empty_message_with_spinner(...) abort
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#component#popupmenu_empty_message_with_spinner#(l:args)
                            endfunction
                            
                            " renderers
                            
    1              0.000001 function! wilder#renderer_mux(args)
                              return wilder#renderer#mux#(a:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_renderer()
    1              0.000001 function! wilder#statusline_renderer(...)
                              let l:args = a:0 > 0 ? a:1 : {}
                              call extend(l:args, {'mode': 'statusline'})
                              return wilder#wildmenu_renderer(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_renderer()
    1              0.000001 function! wilder#float_renderer(...)
                              let l:args = a:0 > 0 ? a:1 : {}
                              call extend(l:args, {'mode': 'float'})
                              return wilder#wildmenu_renderer(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_renderer(...)
                              let l:args = a:0 > 0 ? a:1 : {}
                            
                              if !has_key(l:args, 'mode')
                                let l:args.mode = has('nvim-0.4') ? 'float' :
                                      \ exists('*popup_create') ? 'popup' :
                                      \ 'statusline'
                              endif
                            
                              if l:args.mode ==# 'float' || l:args.mode ==# 'popup'
                                return wilder#renderer#wildmenu_float_or_popup#(l:args)
                              endif
                            
                              return wilder#renderer#wildmenu_statusline#(l:args)
                            endfunction
                            
    1              0.000000 function! wilder#popupmenu_renderer(...)
                              let l:args = get(a:, 1, {})
                            
                              if !has_key(l:args, 'mode')
                                let l:args.mode = has('nvim-0.4') ? 'float' : 'popup'
                              endif
                            
                              return wilder#renderer#popupmenu#(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_airline_theme()
    1              0.000000 function! wilder#airline_theme(...)
                              return call('wilder#wildmenu_airline_theme', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_airline_theme(...)
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#wildmenu_theme#airline_theme(l:args)
                            endfunction
                            
                            " DEPRECATED: use wilder#wildmenu_lightline_theme()
    1              0.000001 function! wilder#lightline_theme(...)
                              return call('wilder#wildmenu_lightline_theme', a:000)
                            endfunction
                            
    1              0.000001 function! wilder#wildmenu_lightline_theme(...)
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#wildmenu_theme#lightline_theme(l:args)
                            endfunction
                            
    1              0.000000 function! wilder#popupmenu_border_theme(...)
                              let l:args = get(a:, 1, {})
                              return wilder#renderer#popupmenu_border_theme#(l:args)
                            endfunction
                            
    1              0.000001 function! wilder#popupmenu_palette_theme(...)
                              let l:args = get(a:, 1, {})
                            
                              return wilder#renderer#popupmenu_palette_theme#(l:args)
                            endfunction
                            
    1              0.000001 function! s:find_function_script_file(f)
                              try
                                " ensure function is autoloaded
                                silent call eval(a:f . '()')
                              catch /E119/
                                " success
                              catch
                                return ''
                              endtry
                            
                              let l:output = execute('verbose function ' . a:f)
                              let l:lines = split(l:output, '\n')
                              if len(l:lines) < 2
                                return ''
                              endif
                            
                              let l:matches = matchlist(l:lines[1], 'Last set from \(.\+\) line \d\+$')
                              if len(l:matches) < 2
                                " verbose function output is different for older versions.
                                let l:matches = matchlist(l:lines[1], 'Last set from \(.\+\)$')
                                if len(l:matches) < 2
                                  return ''
                                endif
                              endif
                            
                              return l:matches[1]
                            endfunction
                            
    1              0.000001 function! wilder#findfile(file) abort
                              if exists('*nvim_get_runtime_file')
                                let l:runtime_files = nvim_get_runtime_file(a:file, 0)
                                return get(l:runtime_files, 0, '')
                              endif
                            
                              return findfile(a:file, &rtp)
                            endfunction
                            
    1              0.000001 function! s:get_module_path(file, use_cached)
                              if !exists('s:module_path_cache')
                                let s:module_path_cache = wilder#cache#cache()
                              endif
                            
                              if !a:use_cached || !s:module_path_cache.has_key(a:file)
                                let l:file = wilder#findfile(a:file)
                                let l:path = fnamemodify(l:file, ':h')
                            
                                call s:module_path_cache.set(a:file, l:path)
                              endif
                            
                              return s:module_path_cache.get(a:file)
                            endfunction
                            
    1              0.000000 function! wilder#fruzzy_path(...) abort
                              return s:get_module_path('rplugin/python3/fruzzy.py', get(a:, 1, 1))
                            endfunction
                            
    1              0.000000 function! wilder#cpsm_path(...) abort
                              return s:get_module_path('autoload/cpsm.py', get(a:, 1, 1))
                            endfunction
                            
    1              0.000000 function! wilder#clap_path(...) abort
                              return s:get_module_path('pythonx/clap/scorer.py', get(a:, 1, 1))
                            endfunction
                            
    1              0.000001 function! wilder#clear_module_path_cache()
                              if !exists('s:module_path_cache')
                                let s:module_path_cache = wilder#cache#cache()
                              endif
                            
                              call s:module_path_cache.clear()
                            endfunction
                            
    1              0.000001 function! wilder#project_root(...) abort
                              if !exists('s:project_root_cache')
                                let s:project_root_cache = wilder#cache#cache()
                              endif
                            
                              if a:0
                                let l:root_markers = a:1
                              else
                                let l:root_markers = ['.hg', '.git']
                              endif
                            
                              return {-> s:project_root(l:root_markers)}
                            endfunction
                            
    1              0.000001 function! wilder#clear_project_root_cache() abort
                              if !exists('s:project_root_cache')
                                let s:project_root_cache = wilder#cache#cache()
                              endif
                            
                              call s:project_root_cache.clear()
                            endfunction
                            
    1              0.000001 function! s:project_root(root_markers, ...) abort
                              if a:0
                                let l:path = a:1
                              else
                                let l:path = getcwd()
                              endif
                            
                              if !s:project_root_cache.has_key(l:path)
                                let l:project_root = s:get_project_root(l:path, a:root_markers)
                                call s:project_root_cache.set(l:path, l:project_root)
                              endif
                            
                              return s:project_root_cache.get(l:path)
                            endfunction
                            
    1              0.000001 function! s:get_project_root(path, root_markers) abort
                              let l:home_directory = expand('~')
                              let l:find_path = a:path . ';' . l:home_directory
                            
                              for l:root_marker in a:root_markers
                                let l:result = findfile(l:root_marker, l:find_path)
                                if empty(l:result)
                                  let l:result = finddir(l:root_marker, l:find_path)
                                endif
                            
                                if empty(l:result)
                                  continue
                                endif
                            
                                return fnamemodify(l:result, ':~:h')
                              endfor
                            
                              return ''
                            endfunction
                            
                            " DEPRECATED: This function is to be removed.
                            " Use wilder#popupmenu_devicons() instead.
    1              0.000001 function! wilder#result_draw_devicons()
                              return wilder#result({
                                    \ 'draw': ['wilder#draw_devicons'],
                                    \ })
                            endfunction
                            
    1              0.000002 function! wilder#draw_devicons(ctx, x, data) abort
                              let l:expand = get(a:data, 'cmdline.expand', '')
                            
                              if l:expand !=# 'file' &&
                                    \ l:expand !=# 'file_in_path' &&
                                    \ l:expand !=# 'dir' &&
                                    \ l:expand !=# 'shellcmd' &&
                                    \ l:expand !=# 'buffer'
                                return a:x
                              endif
                            
                              let l:slash = !has('win32') && !has('win64')
                                    \ ? '/'
                                    \ : &shellslash
                                    \ ? '/'
                                    \ : '\'
                            
                              let l:is_dir = a:x[-1:] ==# l:slash
                            
                              return WebDevIconsGetFileTypeSymbol(a:x, l:is_dir) . ' ' . a:x
                            endfunction
                            
    1              0.000001 function! wilder#devicons_get_icon_from_vim_devicons()
                              return wilder#renderer#component#popupmenu_devicons#get_icon_from_vim_devicons()
                            endfunction
                            
    1              0.000001 function! wilder#devicons_get_icon_from_nerdfont_vim()
                              return wilder#renderer#component#popupmenu_devicons#get_icon_from_nerdfont_vim()
                            endfunction
                            
    1              0.000001 function! wilder#devicons_get_icon_from_nvim_web_devicons(...)
                              let l:opts = a:0 ? a:1 : {}
                              return wilder#renderer#component#popupmenu_devicons#get_icon_from_nvim_web_devicons(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#devicons_get_hl_from_glyph_palette_vim(...)
                              let l:opts = a:0 ? a:1 : {}
                              return wilder#renderer#component#popupmenu_devicons#get_hl_from_glyph_palette_vim(l:opts)
                            endfunction
                            
    1              0.000001 function! wilder#devicons_get_hl_from_nvim_web_devicons(...)
                              let l:opts = a:0 ? a:1 : {}
                              return wilder#renderer#component#popupmenu_devicons#get_hl_from_nvim_web_devicons(l:opts)
                            endfunction
                            
    1              0.000001 function! s:extract_keys(obj, ...)
                              let l:res = {}
                            
                              for l:key in a:000
                                if has_key(a:obj, l:key)
                                  let l:res[l:key] = a:obj[l:key]
                                endif
                              endfor
                            
                              return l:res
                            endfunction
                            
    1              0.000000 function! wilder#setup(...)
                              return call('wilder#setup#', a:000)
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/setup.vim
Sourced 1 time
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
    1              0.000001 function! wilder#setup#(...)
                              let l:config = get(a:, 1, {})
                            
                              " Duplicate wilder#main#enable_cmdline_enter() and
                              " wilder#main#disable_cmdline_enter() here so we don't have to autoload
                              " autoload/wilder/main.vim.
                              if get(l:config, 'enable_cmdline_enter', 1)
                                if !exists('#WilderCmdlineEnter')
                                  augroup WilderCmdlineEnter
                                    autocmd!
                                    autocmd CmdlineEnter * call wilder#main#start()
                                  augroup END
                                endif
                              else
                                if exists('#WilderCmdlineEnter')
                                  augroup WilderCmdlineEnter
                                    autocmd!
                                  augroup END
                                  augroup! WilderCmdlineEnter
                                endif
                              endif
                            
                              let l:wildcharm = get(l:config, 'wildcharm', &wildchar)
                              if l:wildcharm isnot v:false
                                execute 'set wildcharm='. &wildchar
                              endif
                            
                              let l:modes = get(l:config, 'modes', ['/', '?'])
                              call wilder#options#set('modes', l:modes)
                            
                              for [l:key, l:default_mapping, l:function, l:condition] in [
                                    \ ['next_key', '<Tab>', 'wilder#next()', 'wilder#in_context()'],
                                    \ ['previous_key', '<S-Tab>', 'wilder#previous()', 'wilder#in_context()'],
                                    \ ['reject_key', '<Up>', 'wilder#reject_completion()', 'wilder#can_reject_completion()'],
                                    \ ['accept_key', '<Down>', 'wilder#accept_completion()', 'wilder#can_accept_completion()'],
                                    \ ]
                                let l:mapping = get(l:config, l:key, l:default_mapping)
                                if l:mapping is v:false
                                  continue
                                endif
                            
                                if type(l:mapping) is v:t_list
                                  let l:fallback_mapping = l:mapping[1]
                                  let l:mapping = l:mapping[0]
                                else
                                  let l:fallback_mapping = l:mapping
                                endif
                            
                                if l:key ==# 'accept_key' &&
                                      \ !get(l:config, 'accept_completion_auto_select', 1)
                                  let l:function = 'wilder#accept_completion(0)'
                                endif
                            
                                if l:fallback_mapping isnot 0
                                  execute 'cnoremap <expr>' l:mapping l:condition ' ? ' l:function ' : ' string(l:fallback_mapping)
                                else
                                  execute 'cmap ' l:mapping '<Cmd>call' l:function '<CR>'
                                endif
                              endfor
                            
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim
Sourced 1 time
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000002 let s:opts = {}
                            
                            " main options
    1              0.000015 call extend(s:opts, {
                                  \ 'modes': ['/', '?'],
                                  \ 'use_cmdlinechanged': exists('##CmdlineChanged'),
                                  \ 'interval': 100,
                                  \ 'before_cursor': 0,
                                  \ 'num_workers': 2,
                                  \ 'noselect': 1,
                                  \ })
                            
    1              0.000001 function! wilder#options#get(...) abort
                              if !a:0
                                return s:opts
                              endif
                            
                              if a:1 ==# 'use_python_remote_plugin' &&
                                    \ !has_key(s:opts, 'use_python_remote_plugin')
                                if !has('python3')
                                  let s:opts.use_python_remote_plugin = 0
                                elseif has('nvim')
                                  let s:opts.use_python_remote_plugin = 1
                                else
                                  let l:file = findfile('autoload/yarp.vim', &rtp)
                                  let s:opts.use_python_remote_plugin = !empty(l:file)
                                endif
                              endif
                            
                              return s:opts[a:1]
                            endfunction
                            
    1              0.000001 function! wilder#options#set(x, ...) abort
                              if len(a:000) == 0
                                call extend(s:opts, a:x)
                              else
                                let s:opts[a:x] = a:1
                              endif
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim
Sourced 1 time
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
    1              0.000005 let s:empty_result = {'value': [], 'data': {}}
                            
    1              0.000002 function! wilder#renderer#popupmenu#(opts) abort
                              let l:highlights = copy(get(a:opts, 'highlights', {}))
                              let l:state = {
                                    \ 'highlights': extend(l:highlights, {
                                    \   'default': get(a:opts, 'hl', 'Pmenu'),
                                    \   'selected': get(a:opts, 'selected_hl', 'PmenuSel'),
                                    \   'error': get(a:opts, 'error_hl', 'ErrorMsg'),
                                    \   'empty_message': 'WarningMsg',
                                    \ }, 'keep'),
                                    \ 'ellipsis': wilder#render#to_printable(get(a:opts, 'ellipsis', '...')),
                                    \ 'apply_incsearch_fix': get(a:opts, 'apply_incsearch_fix', has('nvim') && !has('nvim-0.5.1')),
                                    \ 'reverse': get(a:opts, 'reverse', 0),
                                    \ 'highlight_mode': get(a:opts, 'highlight_mode', 'detailed'),
                                    \ 'left_offset': get(a:opts, 'left_offset', 1),
                                    \ 'zindex': get(a:opts, 'zindex', 250),
                                    \ 'top': get(a:opts, 'top', []),
                                    \ 'bottom': get(a:opts, 'bottom', []),
                                    \ 'empty_message': get(a:opts, 'empty_message', 0),
                                    \ 'empty_message_first_draw_delay': get(a:opts, 'empty_message_first_draw_delay', 100),
                                    \ 'error_message': get(a:opts, 'error_message', wilder#renderer#component#popupmenu_error_message#()),
                                    \ 'position': get(a:opts, 'position', funcref('s:get_position')),
                                    \
                                    \ 'page': [-1, -1],
                                    \ 'buf': -1,
                                    \ 'win': -1,
                                    \ 'draw_cache': wilder#cache#cache(),
                                    \ 'highlight_cache': wilder#cache#cache(),
                                    \ 'run_id': -1,
                                    \ 'longest_line_width': 0,
                                    \ 'render_id': -1,
                                    \ 'active': 0,
                                    \ 'is_first_draw': 0,
                                    \ 'empty_message_first_draw_timer': -1,
                                    \ }
                            
                              let l:Max_height = get(a:opts, 'max_height', '50%')
                              if type(l:Max_height) is v:t_number && l:Max_height <= 0
                                let l:Max_height = 10000
                              endif
                              let l:state.get_max_height = s:get_height_or_width_from_option(l:Max_height, 10000, 1)
                            
                              let l:Min_height = get(a:opts, 'min_height', 0)
                              let l:state.get_min_height = s:get_height_or_width_from_option(l:Min_height, 0, 1)
                            
                              let l:Max_width = get(a:opts, 'max_width', '50%')
                              if type(l:Max_width) is v:t_number && l:Max_width <= 0
                                let l:Max_width = 10000
                              endif
                              let l:state.get_max_width = s:get_height_or_width_from_option(l:Max_width, 10000, 0)
                            
                              let l:Min_width = get(a:opts, 'min_width', 16)
                              let l:state.get_min_width = s:get_height_or_width_from_option(l:Min_width, 16, 0)
                            
                              if exists('+pumblend')
                                if has_key(a:opts, 'pumblend')
                                  let l:state.pumblend = a:opts.pumblend
                                elseif has_key(a:opts, 'winblend')
                                  " DEPRECATED: Use 'pumblend'
                                  let l:state.pumblend = a:opts.winblend
                                else
                                  " -1 to indicate unset
                                  let l:state.pumblend = -1
                                endif
                              else
                                let l:state.pumblend = -1
                              endif
                            
                              if !has_key(a:opts, 'left') && !has_key(a:opts, 'right')
                                let l:state.left = [' ']
                                let l:state.right = [' ', wilder#popupmenu_scrollbar()]
                              else
                                let l:state.left = get(a:opts, 'left', [])
                                let l:state.right = get(a:opts, 'right', [])
                              endif
                            
                              if !has_key(l:state.highlights, 'accent')
                                let l:state.highlights.accent =
                                      \ wilder#hl_with_attr(
                                      \ 'WilderPoppupMenuAccent',
                                      \ l:state.highlights['default'],
                                      \ 'underline', 'bold')
                              endif
                            
                              if !has_key(l:state.highlights, 'selected_accent')
                                let l:state.highlights.selected_accent =
                                      \ wilder#hl_with_attr(
                                      \ 'WilderPopupMenuSelectedAccent',
                                      \ l:state.highlights['selected'],
                                      \ 'underline', 'bold')
                              endif
                            
                              if has_key(a:opts, 'highlighter')
                                let l:Highlighter = a:opts['highlighter']
                              elseif has_key(a:opts, 'apply_highlights')
                                let l:Highlighter = a:opts['apply_highlights']
                              else
                                let l:Highlighter = 0
                              endif
                            
                              if type(l:Highlighter) is v:t_list
                                let l:Highlighter = wilder#highlighter#apply_first(l:Highlighter)
                              endif
                            
                              let l:state.highlighter = l:Highlighter
                            
                              if a:opts.mode ==# 'float'
                                let l:state.api = wilder#renderer#nvim_api#()
                              else
                                let l:state.api = wilder#renderer#vim_api#()
                              endif
                            
                              return {
                                    \ 'render': {ctx, result -> s:render(l:state, ctx, result)},
                                    \ 'pre_hook': {ctx -> s:pre_hook(l:state, ctx)},
                                    \ 'post_hook': {ctx -> s:post_hook(l:state, ctx)},
                                    \ }
                            endfunction
                            
    1              0.000002 function! s:render(state, ctx, result) abort
                              call timer_stop(a:state.empty_message_first_draw_timer)
                            
                              if a:state.run_id != a:ctx.run_id
                                let a:state.longest_line_width = 0
                                call a:state.draw_cache.clear()
                                call a:state.highlight_cache.clear()
                              endif
                            
                              let a:state.run_id = a:ctx.run_id
                            
                              if a:ctx.clear_previous
                                let a:state.page = [-1, -1]
                              endif
                            
                              let l:page = s:make_page(a:state, a:ctx, a:result)
                              let a:ctx.page = l:page
                              let a:state.page = l:page
                            
                              let l:height = l:page == [-1, -1] ?
                                    \ 0 :
                                    \ l:page[1] - l:page[0] + 1
                            
                              let l:min_height = a:state.get_min_height(a:ctx, a:result)
                              let l:min_height -= len(a:state.top)
                              let l:min_height -= len(a:state.bottom)
                              if l:height < l:min_height
                                let l:height = l:min_height
                              endif
                            
                              let a:ctx.height = l:height
                              let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
                              if a:state.page == [-1, -1] &&
                                    \ !has_key(a:ctx, 'error') &&
                                    \ a:state.empty_message is 0
                                call a:state.api.hide()
                                return
                              endif
                            
                              let l:was_first_draw = a:state.is_first_draw
                              let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
                              if l:was_first_draw &&
                                    \ a:state.page == [-1, -1] &&
                                    \ a:state.empty_message isnot 0 &&
                                    \ !a:ctx.done &&
                                    \ a:state.empty_message_first_draw_delay > 0
                                let a:state.empty_message_first_draw_timer =
                                      \ timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
                                return
                              endif
                            
                              " If error or empty message is not showing, check if we need to draw.
                              if !has_key(a:ctx, 'error') &&
                                    \ a:state.page != [-1, -1] &&
                                    \ !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
                                return
                              endif
                            
                              let a:state.render_id += 1
                            
                              if a:state.api.need_timer()
                                let l:render_id = a:state.render_id
                                call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
                              endif
                            endfunction
                            
    1              0.000001 function! s:make_page(state, ctx, result) abort
                              if empty(a:result.value)
                                return [-1, -1]
                              endif
                            
                              let l:page = a:state.page
                              let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
                              let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
                              if l:page != [-1, -1]
                                if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
                                elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
                                endif
                              endif
                            
                              if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
                                if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
                                  return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
                              endif
                            
                              " Otherwise make a new page.
                            
                              let l:max_height = a:state.get_max_height(a:ctx, a:result)
                              let l:min_height = a:state.get_min_height(a:ctx, a:result)
                              if l:max_height < l:min_height
                                let l:max_height = l:min_height
                              endif
                              let l:max_height -= len(a:state.top)
                              let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
                              let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
                              if a:ctx.direction >= 0
                                let l:start = l:selected
                            
                                " Try to include all candidates after selected.
                                let l:height = len(a:result.value) - l:selected
                            
                                if l:height > l:max_height
                                  let l:height = l:max_height
                                endif
                            
                                return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]
                            endfunction
                            
    1              0.000001 function! s:render_lines_from_timer(render_id, state, ctx, result)
                              " Multiple renders might be queued, skip if there is a newer render
                              if a:render_id != a:state.render_id ||
                                    \ !a:state.active
                                return
                              endif
                            
                              call s:render_lines(a:state, a:ctx, a:result)
                            endfunction
                            
    1              0.000001 function! s:render_lines(state, ctx, result) abort
                              if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
                                let l:pos = get(a:result, 'pos', 0) + 1
                                let l:pos -= a:state.left_offset
                                if l:pos < 0
                                  let l:pos = 0
                                endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
                              endif
                            
                              let l:selected = a:ctx.selected
                              let l:reverse = a:state.reverse
                            
                              let [l:page_start, l:page_end] = a:state.page
                            
                              if a:state.page != [-1, -1]
                                " draw candidates
                                let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
                                let l:lines = l:reverse ? reverse(l:lines) : l:lines
                              else
                                if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
                                else
                                  " draw empty message
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
                                endif
                            
                                let l:width = empty(l:lines) ?
                                      \ a:state.get_min_width(a:ctx, a:result) :
                                      \ wilder#render#chunks_displaywidth(l:lines[0])
                              endif
                            
                              let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
                              let l:lines_height = len(l:lines)
                            
                              let l:top_lines = []
                              let l:top_height = 0
                              for l:Top in a:state.top
                                let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
                                if empty(l:line)
                                  continue
                                endif
                            
                                call add(l:top_lines, l:line)
                                let l:top_height += 1
                              endfor
                              let l:lines = l:top_lines + l:lines
                            
                              let l:bottom_height = 0
                              for l:Bottom in a:state.bottom
                                let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
                                if empty(l:line)
                                  continue
                                endif
                            
                                call add(l:lines, l:line)
                                let l:bottom_height += 1
                              endfor
                            
                              if empty(l:lines)
                                call a:state.api.hide()
                                return
                              endif
                            
                              call a:state.api.show()
                            
                              let l:height = len(l:lines)
                              let l:max_height = a:state.get_max_height(a:ctx, a:result)
                              if l:max_height > &lines
                                let l:max_height = &lines
                              endif
                              let [l:row, l:col] = a:state.position(a:ctx, l:pos,
                                    \ {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
                              call a:state.api.move(l:row, l:col, l:height, l:width)
                              call a:state.api.set_option('wrap', v:false)
                              call a:state.api.clear_all_highlights()
                              call a:state.api.delete_all_lines()
                            
                              let l:default_hl = a:state.highlights['default']
                              let l:selected_hl = a:state.highlights['selected']
                            
                              let l:i = 0
                              while l:i < len(l:lines)
                                let l:chunks = l:lines[l:i]
                            
                                let l:text = ''
                                for l:chunk in l:chunks
                                  let l:text .= l:chunk[0]
                                endfor
                            
                                call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
                                if l:page_start == -1 ||
                                      \ (!l:reverse && l:i < l:top_height) ||
                                      \ (l:reverse && l:i >= l:top_height + l:lines_height)
                                  let l:is_selected = 0
                                else
                                  let l:is_selected = l:reverse ? 
                                        \ l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected :
                                        \ l:page_start + l:i - l:top_height == l:selected
                                endif
                            
                                let l:start = 0
                                for l:chunk in l:chunks
                                  let l:end = l:start + len(l:chunk[0])
                            
                                  if l:is_selected
                                    if len(l:chunk) == 1
                                      let l:hl = l:selected_hl
                                    elseif len(l:chunk) == 2
                                      let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
                                    endif
                                  else
                                    let l:hl = get(l:chunk, 1, l:default_hl)
                                  endif
                            
                                  if l:hl !=# l:default_hl
                                    call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
                                  endif
                            
                                  let l:start = l:end
                                endfor
                            
                                let l:i += 1
                              endwhile
                            
                              call a:state.api.set_firstline(1)
                              call wilder#renderer#redraw(a:state.apply_incsearch_fix)
                            endfunction
                            
    1              0.000001 function! s:get_error_dimensions(state, ctx, error)
                              let l:width = strdisplaywidth(a:error)
                              let l:height = 1
                            
                              let l:max_width = a:state.get_max_width(a:ctx, s:empty_result)
                              if l:width > l:max_width
                                let l:height = float2nr(ceil(1.0 * l:width / l:max_width))
                                let l:width = l:max_width
                              endif
                            
                              let l:max_height = a:state.get_max_height(a:ctx, s:empty_result)
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:height, l:width]
                            endfunction
                            
    1              0.000001 function! s:make_lines(state, ctx, result) abort
                              let l:Highlighter = get(a:state, 'highlighter', [])
                            
                              let l:height = a:ctx.height
                            
                              if l:height > 0
                                let l:left_column_chunks = map(repeat([0], l:height), {-> []})
                                call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
                                let l:right_column_chunks = map(repeat([0], l:height), {-> []})
                                call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
                              endif
                            
                              " [[left_column, chunks, right_column]]
                              let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
                              let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
                              let [l:start, l:end] = a:state.page
                              let l:i = 0
                              while l:i < l:height
                                let l:index = l:start + l:i
                                if l:index <= l:end
                                  let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
                                endif
                                let l:left_column = l:left_column_chunks[l:i]
                                let l:right_column = l:right_column_chunks[l:i]
                            
                                let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
                                let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
                                let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
                                let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
                                if l:total_width > a:state.longest_line_width
                                  let a:state.longest_line_width = l:total_width
                                endif
                            
                                let l:index = l:i - l:start
                                let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
                                let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
                                let l:i += 1
                              endwhile
                            
                              let l:max_width = a:state.get_max_width(a:ctx, a:result)
                              let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
                              let l:expected_width = min([
                                    \ l:max_width,
                                    \ a:state.longest_line_width,
                                    \ ])
                              if l:expected_width < l:min_width
                                let l:expected_width = l:min_width
                              endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
                              let l:lines = repeat([0], l:height)
                            
                              let l:i = 0
                              while l:i < len(l:raw_lines)
                                let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
                                let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
                                if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
                                elseif l:total_width < l:expected_width
                                  let l:to_pad = l:expected_width - l:total_width
                                  let l:chunks += [[repeat(' ', l:to_pad)]]
                                endif
                            
                                let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
                                let l:i += 1
                              endwhile
                            
                              return [l:lines, l:expected_width]
                            endfunction
                            
    1              0.000002 function! s:draw_columns(column_chunks, columns, ctx, result) abort
                              let l:height = a:ctx.height
                            
                              for l:Column in a:columns
                                let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
                                if empty(l:column)
                                  continue
                                endif
                            
                                let l:i = 0
                                while l:i < len(l:column)
                                  let a:column_chunks[l:i] += l:column[l:i]
                            
                                  let l:i += 1
                                endwhile
                            
                                if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! wilder#renderer#popupmenu#draw_column(ctx, result, column) abort
                              let l:Column = a:column
                              let l:height = a:ctx.height
                            
                              if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
                              endif
                            
                              if type(l:Column) is v:t_func
                                let l:Column = l:Column(a:ctx, a:result)
                              endif
                            
                              if type(l:Column) is v:t_string
                                if empty(l:Column)
                                  return []
                                endif
                            
                                return repeat([[[l:Column]]], l:height)
                              endif
                            
                              " v:t_list
                              if empty(l:Column)
                                return []
                              endif
                            
                              if empty(l:Column[0])
                                return []
                              endif
                            
                              " highlight chunk
                              if type(l:Column[0]) is v:t_string
                                return repeat([[l:Column]], l:height)
                              endif
                            
                              " list of highlight chunks
                              if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
                              endif
                            
                              " list of list of highlight chunks
                              return l:Column
                            endfunction
                            
    1              0.000001 function! s:draw_candidates_chunks(state, ctx, result, i) abort
                              let l:is_selected = a:ctx.selected == a:i
                            
                              let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
                              let l:Highlighter = a:state.highlighter
                            
                              if l:Highlighter is 0
                                return [[l:str]]
                              endif
                            
                              if !l:is_selected &&
                                    \ a:state.highlight_cache.has_key(l:str)
                                return copy(a:state.highlight_cache.get(l:str))
                              endif
                            
                              let l:data = get(a:result, 'data', {})
                              let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
                              if l:spans is 0
                                return [[l:str]]
                              endif
                            
                              if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
                              endif
                            
                              let l:chunks = wilder#render#spans_to_chunks(
                                    \ l:str,
                                    \ l:spans,
                                    \ l:is_selected,
                                    \ a:ctx.highlights)
                            
                              if !l:is_selected
                                call a:state.highlight_cache.set(l:str, l:chunks)
                                let l:chunks = copy(l:chunks)
                              endif
                            
                              return l:chunks
                            endfunction
                            
    1              0.000001 function! s:draw_candidate(state, ctx, result, i) abort
                              let l:use_cache = a:ctx.selected == a:i
                              if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
                              endif
                            
                              let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
                              if l:use_cache
                                call a:state.draw_cache.set(a:i, l:x)
                              endif
                            
                              return l:x
                            endfunction
                            
    1              0.000001 function! s:merge_spans(spans) abort
                              if empty(a:spans)
                                return []
                              endif
                            
                              let l:start_byte = a:spans[0][0]
                              let l:end_byte = a:spans[-1][0] + a:spans[-1][1]
                            
                              return [[l:start_byte, l:end_byte - l:start_byte]]
                            endfunction
                            
    1              0.000001 function! s:pre_hook(state, ctx) abort
                              call a:state.api.new({
                                    \ 'normal_highlight': a:state.highlights.default,
                                    \ 'zindex': get(a:state, 'zindex', 0),
                                    \ 'pumblend': get(a:state, 'pumblend', -1)
                                    \ })
                            
                              for l:Component in [a:state.empty_message, a:state.error_message] +
                                    \ a:state.left + a:state.right + a:state.top + a:state.bottom
                                call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
                              endfor
                            
                              let a:state.active = 1
                              let a:state.is_first_draw = 1
                            endfunction
                            
    1              0.000001 function! s:post_hook(state, ctx) abort
                              call a:state.api.hide()
                            
                              for l:Component in [a:state.empty_message, a:state.error_message] +
                                    \ a:state.left + a:state.right + a:state.top + a:state.bottom
                                call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
                              endfor
                            
                              call timer_stop(a:state.empty_message_first_draw_timer)
                            
                              let a:state.active = 0
                            endfunction
                            
    1              0.000001 function! s:make_error_message(state, ctx, error, error_message) abort
                              let l:min_width = a:state.get_min_width(a:ctx, s:empty_result)
                              let l:max_width = a:state.get_max_width(a:ctx, s:empty_result)
                              let l:min_height = a:state.get_min_height(a:ctx, s:empty_result)
                              let l:max_height = a:state.get_max_height(a:ctx, s:empty_result)
                            
                              let l:height_used = len(a:state.top) + len(a:state.bottom)
                              let l:max_height -= l:height_used
                              let l:min_height -= l:height_used
                            
                              if l:max_width < l:min_width
                                let l:max_width = l:min_width
                              endif
                              if l:max_height < l:min_height
                                let l:max_height = l:min_height
                              endif
                            
                              let l:ctx = copy(a:ctx)
                            
                              let l:ctx.min_width = l:min_width
                              let l:ctx.max_width = l:max_width
                              let l:ctx.min_height = l:min_height
                              let l:ctx.max_height = l:max_height
                            
                              return a:error_message(l:ctx, a:ctx.error)
                            endfunction
                            
    1              0.000001 function! s:make_message(state, ctx, func, result, arg, hl_key) abort
                              let l:Message = a:func
                              if type(l:Message) is v:t_dict
                                let l:Message = l:Message.value
                              endif
                            
                              let l:min_width = a:state.get_min_width(a:ctx, a:result)
                              let l:max_width = a:state.get_max_width(a:ctx, a:result)
                              let l:min_height = a:state.get_min_height(a:ctx, a:result)
                              let l:max_height = a:state.get_max_height(a:ctx, a:result)
                            
                              let l:height_used = len(a:state.top) + len(a:state.bottom)
                              let l:max_height -= l:height_used
                              let l:min_height -= l:height_used
                            
                              if l:max_width < l:min_width
                                let l:max_width = l:min_width
                              endif
                              if l:max_height < l:min_height
                                let l:max_height = l:min_height
                              endif
                            
                              if type(l:Message) is v:t_func
                                let l:ctx = copy(a:ctx)
                            
                                let l:ctx.min_width = l:min_width
                                let l:ctx.max_width = l:max_width
                                let l:ctx.min_height = l:min_height
                                let l:ctx.max_height = l:max_height
                            
                                let l:Message = l:Message(l:ctx, a:arg)
                              endif
                            
                              if type(l:Message) is v:t_string
                                let l:hl = a:ctx.highlights[a:hl_key]
                                let l:Message = s:make_message_from_string(l:Message, l:min_width, l:max_width, l:min_height, l:hl)
                              endif
                            
                              return l:Message
                            endfunction
                            
    1              0.000001 function! s:make_message_from_string(message, min_width, max_width, min_height, hl) abort
                              let l:message = a:message
                            
                              let l:message = wilder#render#truncate(a:max_width, l:message)
                              let l:message .= repeat(' ', a:min_width - strdisplaywidth(l:message))
                            
                              let l:rows = [[[l:message, a:hl]]]
                            
                              if a:min_height > 1
                                let l:width = strdisplaywidth(l:message)
                                let l:rows += repeat([[[repeat(' ', l:width)]]], a:min_height - 1)
                              endif
                            
                              return l:rows
                            endfunction
                            
    1              0.000001 function! s:draw_top_or_bottom_line(line, ctx, result) abort
                              let l:width = a:ctx.width
                            
                              let l:Line = a:line
                              if type(l:Line) is v:t_dict
                                let l:Line = l:Line.value
                              endif
                            
                              if type(l:Line) is v:t_func
                                let l:Line = l:Line(a:ctx, a:result)
                              endif
                            
                              if type(l:Line) is v:t_string
                                if empty(l:Line)
                                  return l:Line
                                endif
                            
                                let l:Line = [[wilder#render#truncate_and_pad(a:ctx.width, l:Line)]]
                              endif
                            
                              return l:Line
                            endfunction
                            
    1              0.000001 function! s:clamp(value, is_height) abort
                              if a:value < 1
                                return 1
                              endif
                            
                              let l:max = a:is_height ? (&lines - 1) : &columns
                              if a:value > l:max
                                return l:max
                              endif
                            
                              return a:value
                            endfunction
                            
    1              0.000001 function! s:get_height_or_width_from_option(opt, default, is_height) abort
                              if type(a:opt) is v:t_number
                                return {-> s:clamp(a:opt, a:is_height)}
                              endif
                            
                              if type(a:opt) is v:t_func
                                return {ctx, result -> s:clamp(a:opt(ctx, result), a:is_height)}
                              endif
                            
                              let l:matches = matchlist(a:opt, '^\(\d\+%\)$')
                              if len(l:matches) >= 2
                                let l:percent = 0.01 * str2nr(l:matches[1])
                                if a:is_height
                                  return {-> s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)}
                                else
                                  return {-> s:clamp(float2nr(l:percent * &columns), a:is_height)}
                                endif
                              endif
                            
                              return {-> s:clamp(a:default, a:is_height)}
                            endfunction
                            
    1              0.000001 function! s:get_position(ctx, pos, dimensions) abort
                              let l:col = a:pos % &columns
                            
                              if !has('nvim')
                                if l:col + a:dimensions.width > &columns
                                  let l:col = &columns - a:dimensions.width
                                endif
                                if l:col < 0
                                  let l:col = 0
                                endif
                              endif
                            
                              let l:cmdheight = wilder#renderer#get_cmdheight()
                              let l:row = &lines - l:cmdheight - a:dimensions.height
                            
                              return [l:row, l:col]
                            endfunction
                            
    1              0.000001 function! wilder#renderer#popupmenu#iterate_candidates(ctx, result, f) abort
                              let l:page = a:ctx.page
                              if l:page == [-1, -1]
                                return []
                              endif
                            
                              let l:lines = []
                            
                              let l:i = l:page[0]
                              while l:i <= l:page[1]
                                let l:candidate = wilder#main#get_candidate(a:ctx, a:result, l:i)
                                let l:ctx = copy(a:ctx)
                                let l:ctx.original = a:result.value[l:i]
                                let l:ctx.i = l:i
                            
                                let l:result = a:f(l:ctx, l:candidate, a:result.data)
                                if type(l:result) is v:t_string
                                  call add(l:lines, [[l:result]])
                                elseif empty(l:result)
                                  " empty v:t_list
                                  call add(l:lines, [])
                                elseif type(l:result[0]) is v:t_string
                                  " highlight chunk
                                  call add(l:lines, [l:result])
                                else
                                  " list of highhlight chunks
                                  call add(l:lines, l:result)
                                endif
                            
                                let l:i += 1
                              endwhile
                            
                              return l:lines
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim
Sourced 1 time
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
                            
    1              0.000006 let s:has_strtrans_issue = strdisplaywidth('') != strdisplaywidth(strtrans(''))
                            
                            " DEPRECATED: use wilder#render#draw_candidate()
    1              0.000001 function! wilder#render#draw_x(ctx, result, i) abort
                              return wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            endfunction
                            
    1              0.000001 function! wilder#render#draw_candidate(ctx, result, i) abort
                              let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
                              if has_key(a:result, 'draw')
                                let l:ctx = {
                                      \ 'i': a:i,
                                      \ 'selected': a:ctx.selected == a:i,
                                      \ }
                            
                                for l:F in a:result.draw
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
                                endfor
                              endif
                            
                              return wilder#render#to_printable(l:x)
                            endfunction
                            
    1              0.000001 function! wilder#render#spans_to_chunks(str, spans, is_selected, highlights) abort
                              let l:res = []
                            
                              let l:non_span_start = 0
                              let l:end = 0
                            
                              let l:non_span_hl = a:highlights[a:is_selected ? 'selected' : 'default']
                              let l:default_span_hl = a:highlights[a:is_selected ? 'selected_accent' : 'accent']
                            
                              let l:i = 0
                              while l:i < len(a:spans)
                                let l:span = a:spans[l:i]
                                let l:start = l:span[0]
                                let l:len = l:span[1]
                            
                                if len(l:span) == 2
                                  " [start, length]
                                  let l:span_hl = l:default_span_hl
                                elseif len(l:span) == 3
                                  " [start, length, hl]
                                  let l:span_hl = l:span[2]
                                else
                                  " [start, length, hl, selected_hl]
                                  let l:span_hl = a:is_selected ?
                                        \ l:span[3] :
                                        \ l:span[2]
                                endif
                            
                                if l:start > 0
                                  call add(l:res, [strpart(a:str, l:non_span_start, l:start - l:non_span_start), l:non_span_hl])
                                endif
                            
                                call add(l:res, [strpart(a:str, l:start, l:len), l:span_hl])
                            
                                let l:non_span_start = l:start + l:len
                                let l:i += 1
                              endwhile
                            
                              call add(l:res, [strpart(a:str, l:non_span_start), l:non_span_hl])
                            
                              return l:res
                            endfunction
                            
    1              0.000001 function! s:add_span(res, str, span_hls, hl_index) abort
                              if len(a:span_hls) == 1
                                call add(a:res, [a:str, a:span_hls[0]])
                                return a:hl_index
                              elseif empty(a:span_hls)
                                call add(a:res, [a:str])
                                return a:hl_index
                              endif
                            
                              let l:chars = split(a:str, '\zs')
                              let l:hl_index = a:hl_index
                            
                              for l:char in l:chars
                                if l:hl_index < len(a:span_hls)
                                  call add(a:res, [l:char, a:span_hls[l:hl_index]])
                                  let l:hl_index += 1
                                else
                                  call add(a:res, [l:char, a:span_hls[-1]])
                                endif
                              endfor
                              
                              return l:hl_index
                            endfunction
                            
    1              0.000001 function! wilder#render#to_printable(x) abort
                              if !s:has_strtrans_issue
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res
                            endfunction
                            
    1              0.000001 function! wilder#render#truncate(len, x, ...) abort
                              return s:truncate_and_maybe_pad(a:len, a:x, get(a:, 1, 0), 0)
                            endfunction
                            
    1              0.000002 function! wilder#render#truncate_and_pad(len, x, ...) abort
                              return s:truncate_and_maybe_pad(a:len, a:x, get(a:, 1, 0), 1)
                            endfunction
                            
                            " direction 0 = truncate left
                            "           1 = truncate right
    1              0.000001 function! s:truncate_and_maybe_pad(len, x, direction, should_pad) abort
                              if a:len <= 0
                                return ''
                              endif
                            
                              let l:width = strdisplaywidth(a:x)
                              if l:width > a:len
                                let l:chars = split(a:x, '\zs')
                            
                                if a:direction
                                  let l:index = 0
                                  while l:width > a:len && l:index < len(l:chars)
                                    let l:width -= strdisplaywidth(l:chars[l:index])
                            
                                    let l:index += 1
                                  endwhile
                            
                                  let l:str = join(l:chars[l:index :], '')
                                else
                                  let l:index = len(l:chars) - 1
                                  while l:width > a:len && l:index >= 0
                                    let l:width -= strdisplaywidth(l:chars[l:index])
                            
                                    let l:index -= 1
                                  endwhile
                            
                                  let l:str = join(l:chars[:l:index], '')
                                endif
                              else
                                let l:str = a:x
                              endif
                            
                              if a:should_pad
                                let l:str .= repeat(' ', a:len - l:width)
                              endif
                            
                              return l:str
                            endfunction
                            
    1              0.000001 function! wilder#render#truncate_chunks(len, xs, ...) abort
                              if a:len <= 0
                                return []
                              endif
                            
                              " direction 0 = truncate left
                              "           1 = truncate right
                              let l:direction = get(a:, 1, 0)
                            
                              let l:width = 0
                              let l:res = []
                            
                              if l:direction
                                let l:i = len(a:xs) - 1
                                while l:i >= 0
                                  let l:chunk = a:xs[l:i]
                                  let l:chunk_width = strdisplaywidth(l:chunk[0])
                            
                                  if l:width + l:chunk_width > a:len
                                    let l:truncated_chunk = [wilder#render#truncate(a:len - l:width, l:chunk[0], 1)]
                                    let l:truncated_chunk += l:chunk[1:]
                                    call insert(l:res, l:truncated_chunk)
                                    return l:res
                                  endif
                            
                                  call insert(l:res, l:chunk)
                                  let l:width += l:chunk_width
                                  let l:i -= 1
                                endwhile
                              else
                                let l:i = 0
                                while l:i < len(a:xs)
                                  let l:chunk = a:xs[l:i]
                                  let l:chunk_width = strdisplaywidth(l:chunk[0])
                            
                                  if l:width + l:chunk_width > a:len
                                    let l:truncated_chunk = [wilder#render#truncate(a:len - l:width, l:chunk[0])]
                                    let l:truncated_chunk += l:chunk[1:]
                                    call add(l:res, l:truncated_chunk)
                                    return l:res
                                  endif
                            
                                  call add(l:res, l:chunk)
                                  let l:width += l:chunk_width
                                  let l:i += 1
                                endwhile
                              endif
                            
                              return l:res
                            endfunction
                            
    1              0.000001 function! wilder#render#chunks_displaywidth(chunks) abort
                              let l:width = 0
                            
                              for l:chunk in a:chunks
                                if !empty(l:chunk)
                                  let l:width += strdisplaywidth(l:chunk[0])
                                endif
                              endfor
                            
                              return l:width
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_error_message.vim
Sourced 1 time
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
    1              0.000002 function! wilder#renderer#component#popupmenu_error_message#() abort
                              return {ctx, error -> s:error_message(ctx, error)}
                            endfunction
                            
    1              0.000001 function! s:error_message(ctx, message) abort
                              let l:max_width = a:ctx.max_width
                              let l:min_width = a:ctx.min_width
                              let l:max_height = a:ctx.max_height
                              let l:min_height = a:ctx.min_height
                            
                              let l:message = substitute(a:message, "\t", '  ', 'g')
                              let l:chars = split(l:message, '\zs')
                              let l:lines = []
                              let l:line = ''
                              let l:line_width = 0
                            
                              let l:i = 0
                              while l:i < len(l:chars)
                                let [l:i, l:whitespace, l:word, l:new_line] = s:find_next_word(l:chars, l:i)
                            
                                let l:whitespace_width = strdisplaywidth(l:whitespace)
                                let l:word_width = strdisplaywidth(l:word)
                            
                                " whitespace + word does not fit in current line
                                " move word to next line and omit whitespace
                                if l:line_width + l:whitespace_width + l:word_width > l:max_width
                                  if !empty(l:line)
                                    call add(l:lines, l:line)
                                    let l:line = ''
                                    let l:line_width = 0
                                  endif
                            
                                  " word does not fit in 1 line
                                  if l:word_width > l:line_width
                                    let [l:split_word, l:line, l:line_width] = s:split_word_into_lines(l:chars, l:i - len(l:word) - 1, l:i, l:max_width)
                                    let l:lines += l:split_word
                                  else
                                    let l:line = l:word
                                    let l:line_width = l:word_width
                                  endif
                                else
                                  " skip whitespace if at start of line
                                  let l:line .= l:whitespace
                                  let l:line_width += l:whitespace_width
                            
                                  let l:line .= l:word
                                  let l:line_width += l:word_width
                                endif
                            
                                if l:new_line
                                  call add(l:lines, l:line)
                                  let l:line = ''
                                  let l:line_width = 0
                                endif
                              endwhile
                            
                              if !empty(l:line)
                                call add(l:lines, l:line)
                              endif
                            
                              " truncate under max height
                              let l:lines = l:lines[: l:max_height]
                            
                              " get maximum line width
                              let l:max_width = l:min_width
                              for l:line in l:lines
                                let l:line_width = strdisplaywidth(l:line)
                                if l:line_width > l:max_width
                                  let l:max_width = l:line_width
                                endif
                              endfor
                            
                              let l:hl = a:ctx.highlights.error
                            
                              let l:chunkss = []
                              for l:line in l:lines
                                let l:line = wilder#render#truncate_and_pad(l:max_width, l:line)
                                let l:chunk = [l:line, l:hl]
                                call add(l:chunkss, [l:chunk])
                              endfor
                            
                              if len(l:chunkss) < l:min_height
                                let l:padding = repeat(' ', l:max_width)
                                let l:chunkss += repeat([[[padding, l:hl]]], l:min_height - len(l:chunkss))
                              endif
                            
                              return l:chunkss
                            endfunction
                            
    1              0.000001 function! s:find_next_word(chars, i) abort
                              let l:whitespace = ''
                              let l:new_line = 0
                            
                              " find whitespace
                              let l:i = a:i
                              while l:i < len(a:chars)
                                let l:char = a:chars[l:i]
                                if l:char ==# "\<CR>" || l:char ==# "\<NL>"
                                  let l:i += 1
                                  let l:new_line = 1
                                  break
                                elseif l:char !~# '\s'
                                  break
                                endif
                            
                                let l:whitespace .= l:char
                                let l:i += 1
                              endwhile
                            
                              let l:word = ''
                              if !l:new_line
                                while l:i < len(a:chars)
                                  let l:char = a:chars[l:i]
                                  if l:char ==# "\<CR>" || l:char ==# "\<NL>"
                                    let l:i += 1
                                    let l:new_line = 1
                                    break
                                  elseif l:char !~# '\S'
                                    break
                                  endif
                            
                                  let l:word .= l:char
                                  let l:i += 1
                                endwhile
                              endif
                            
                              return [l:i, l:whitespace, l:word, l:new_line]
                            endfunction
                            
    1              0.000001 function! s:split_word_into_lines(chars, start, end, max_width) abort
                              let l:lines = []
                              let l:line = ''
                              let l:line_width = 0
                              let l:seen_non_whitespace = 0
                            
                              let l:i = a:start
                              while l:i < a:end
                                let l:char = a:chars[l:i]
                            
                                " trim leading whitespace
                                if l:char =~# '\s'
                                  if !l:seen_non_whitespace
                                    let l:i += 1
                                    continue
                                  endif
                                else
                                  let l:seen_non_whitespace = 1
                                endif
                            
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:char ==# "\<CR>" || l:char ==# "\<NL>"
                                  call add(l:lines, l:line)
                                  let l:line = ''
                                  let l:line_width = 0
                            
                                  let l:i += 1
                                  continue
                                elseif l:line_width + l:width > a:max_width
                                  call add(l:lines, l:line)
                                  let l:line = ''
                                  let l:line_width = 0
                                endif
                            
                                let l:line .= l:char
                                let l:line_width += l:width
                            
                                let l:i += 1
                              endwhile
                            
                              return [l:lines, l:line, l:line_width]
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim
Sourced 1 time
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    1              0.000001 function! wilder#cache#cache() abort
                              return {
                                    \ '_cache': {},
                                    \ 'get': funcref('s:get'),
                                    \ 'set': funcref('s:set'),
                                    \ 'has_key': funcref('s:has_key'),
                                    \ 'clear': funcref('s:clear'),
                                    \ }
                            endfunction
                            
    1              0.000001 function! s:get(key) dict abort
                              return self['_cache'][a:key]
                            endfunction
                            
    1              0.000001 function! s:set(key, value) dict abort
                              let self['_cache'][a:key] = a:value
                            endfunction
                            
    1              0.000001 function! s:has_key(key) dict abort
                              return has_key(self['_cache'], a:key)
                            endfunction
                            
    1              0.000001 function! s:clear() dict abort
                              let self['_cache'] = {}
                            endfunction
                            
    1              0.000001 function! wilder#cache#mru_cache(max_size) abort
                              return {
                                    \ '_cache': {},
                                    \ '_queue': [],
                                    \ '_counts': {},
                                    \ '_max_size': a:max_size,
                                    \ 'get': funcref('s:mru_get'),
                                    \ 'set': funcref('s:mru_set'),
                                    \ 'has_key': funcref('s:has_key'),
                                    \ 'clear': funcref('s:mru_clear'),
                                    \ 'mru_update': funcref('s:mru_update'),
                                    \ }
                            endfunction
                            
    1              0.000001 function! s:mru_get(key) dict abort
                              return self['_cache'][a:key]
                            endfunction
                            
    1              0.000001 function! s:mru_set(key, value) dict abort
                              let self['_cache'][a:key] = a:value
                            
                              call self.mru_update(a:key)
                            endfunction
                            
    1              0.000001 function! s:mru_clear() dict abort
                              let self['_cache'] = {}
                              let self['_queue'] = []
                            endfunction
                            
    1              0.000001 function! s:mru_update(key) dict abort
                              let l:queue = self['_queue']
                              let l:counts = self['_counts']
                            
                              call add(l:queue, a:key)
                              if !has_key(l:counts, a:key)
                                let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
                              endif
                            
                              if len(l:queue) > self['_max_size']
                                let l:removed_key = remove(l:queue, 0)
                                let l:counts[l:removed_key] -= 1
                            
                                if l:counts[l:removed_key] == 0
                                  unlet l:counts[l:removed_key]
                                  unlet self['_cache'][l:removed_key]
                                endif
                              endif
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000002 function! wilder#renderer#component#popupmenu_scrollbar#(opts) abort
                              let l:state = {}
                            
                              let l:thumb_char = get(a:opts, 'thumb_char', '█')
                              let l:thumb_hl = get(a:opts, 'thumb_hl', 'PmenuThumb')
                              let l:scrollbar_char = get(a:opts, 'scrollbar_char', ' ')
                              let l:scrollbar_hl = get(a:opts, 'scrollbar_hl', 'PmenuSbar')
                            
                              let l:state.thumb_chunk = [l:thumb_char, l:thumb_hl]
                              let l:state.scrollbar_chunk = [l:scrollbar_char, l:scrollbar_hl]
                            
                              let l:state.collapse = get(a:opts, 'collapse', 1)
                            
                              return {ctx, result -> s:scrollbar(l:state, ctx, result)}
                            endfunction
                            
    1              0.000001 function! s:scrollbar(state, ctx, result) abort
                              let [l:start, l:end] = a:ctx.page
                              let l:num_candidates = len(a:result.value)
                              let l:height = a:ctx.height
                            
                              if l:num_candidates <= l:height
                                if a:state.collapse
                                  return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
                              endif
                            
                              let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
                              let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
                              let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
                              if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
                              endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
                              if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
                              endif
                            
                              let l:thumb_chunk = a:state.thumb_chunk
                              let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
                              let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
                              let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
                              let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
                              return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim
Sourced 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    1              0.000002 let s:hl_list = []
                            
    1              0.000003 let s:attr_list = ['bold', 'underline', 'undercurl', 'strikethrough',
                                  \ 'italic', 'standout', 'reverse', 'inverse']
                            
    1              0.000004 let s:attr_map = {
                                  \ 'bold': 0,
                                  \ 'underline': 0,
                                  \ 'undercurl': 0,
                                  \ 'strikethrough': 0,
                                  \ 'italic': 0,
                                  \ 'standout': 0,
                                  \ 'reverse': 0,
                                  \ }
                            
    1              0.000001 function! wilder#highlight#init_hl() abort
                              for [l:name, l:x, l:xs] in s:hl_list
                                call s:make_hl(l:name, l:x, l:xs)
                              endfor
                            endfunction
                            
    1              0.000003 function! wilder#highlight#make_hl(name, x, xs) abort
                              call s:make_hl(a:name, a:x, a:xs)
                              call filter(s:hl_list, {i, elem -> elem[0] !=# a:name})
                              call add(s:hl_list, [a:name, deepcopy(a:x), deepcopy(a:xs)])
                              return a:name
                            endfunction
                            
    1              0.000001 function! wilder#highlight#make_temp_hl(name, x, xs) abort
                              call s:make_hl(a:name, a:x, a:xs)
                              return a:name
                            endfunction
                            
    1              0.000001 function! s:make_hl(name, x, xs) abort
                              let l:x = s:to_hl_list(a:x)
                            
                              for l:elem in a:xs
                                let l:y = s:to_hl_list(l:elem)
                                let l:x = s:combine_hl_list(l:x, l:y)
                              endfor
                            
                              call s:make_hl_from_list(a:name, l:x)
                            endfunction
                            
    1              0.000001 function! s:to_hl_list(x) abort
                              if type(a:x) is v:t_string
                                let l:x = wilder#highlight#get_hl(a:x)
                              else
                                let l:x = a:x
                              endif
                            
                              if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
                              endif
                            
                              let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
                              let l:cterm_hl = [
                                    \ get(l:x[1], 'foreground', 'NONE'),
                                    \ get(l:x[1], 'background', 'NONE')
                                    \ ] + s:get_attrs_as_list(l:x[1])
                            
                              let l:gui_hl = [
                                    \ get(l:x[2], 'foreground', 'NONE'),
                                    \ get(l:x[2], 'background', 'NONE')
                                    \ ] + s:get_attrs_as_list(l:x[2])
                            
                              return [l:term_hl, l:cterm_hl, l:gui_hl]
                            endfunction
                            
    1              0.000001 function! s:combine_hl_list(l, m) abort
                              let l:term_hl = copy(a:l[0])
                              let l:cterm_hl = copy(a:l[1])
                              let l:gui_hl = copy(a:l[2])
                            
                              if len(l:term_hl) <= 2
                                let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
                              endif
                            
                              let l:cterm_fg = get(a:m[1], 0, -1)
                              if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
                              endif
                            
                              let l:cterm_bg = get(a:m[1], 1, -1)
                              if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
                              endif
                            
                              if len(a:m[1]) > 2
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
                                else
                                  let l:cterm_hl += a:m[1][2:]
                                endif
                              endif
                            
                              let l:gui_fg = get(a:m[2], 0, -1)
                              if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
                                else
                                  let l:gui_hl[0] = l:gui_fg
                                endif
                              endif
                            
                              let l:gui_bg = get(a:m[2], 1, -1)
                              if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
                              endif
                            
                              if len(a:m[2]) > 2
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
                                else
                                  let l:gui_hl += a:m[2][2:]
                                endif
                              endif
                            
                              return [l:term_hl, l:cterm_hl, l:gui_hl]
                            endfunction
                            
    1              0.000001 function! s:normalise_attrs(hl) abort
                              let l:attr_map = copy(s:attr_map)
                            
                              for l:attr in a:hl[2:]
                                if has_key(l:attr_map, l:attr)
                                  let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
                                endif
                              endfor
                            
                              let l:result = []
                              for l:attr in keys(l:attr_map)
                                if l:attr_map[l:attr]
                                  call add(l:result, l:attr)
                                endif
                              endfor
                            
                              return a:hl[:1] + l:result
                            endfunction
                            
    1              0.000001 function! s:make_hl_from_list(name, args) abort
                              let l:term_hl = s:normalise_attrs(a:args[0])
                              let l:cterm_hl = s:normalise_attrs(a:args[1])
                              let l:gui_hl = s:normalise_attrs(a:args[2])
                            
                              let l:cmd = 'hi! ' . a:name . ' '
                            
                              let l:term_attr = l:term_hl[2:]
                              if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
                              endif
                            
                              let l:cterm_attr = l:cterm_hl[2:]
                              if !empty(l:cterm_attr)
                                let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
                              endif
                            
                              if len(l:cterm_hl) >= 1
                                if l:cterm_hl[0] >= 0
                                  let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
                                endif
                            
                                if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
                                  let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
                                endif
                              endif
                            
                              let l:gui_attr = l:gui_hl[2:]
                              if !empty(l:gui_attr)
                                let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
                              endif
                            
                              if len(l:gui_hl) >= 1
                                if type(l:gui_hl[0]) == v:t_number
                                  let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
                                else
                                  let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
                                endif
                            
                                if len(l:gui_hl) >= 2
                                  if type(l:gui_hl[1]) == v:t_number
                                    let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
                                  else
                                    let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
                                  endif
                                endif
                              endif
                            
                              exe l:cmd
                            endfunction
                            
    1              0.000001 function! s:get_attrs_as_list(attrs) abort
                              let l:res = []
                            
                              for l:attr in s:attr_list
                                if has_key(a:attrs, l:attr)
                                  if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
                                  endif
                            
                                  if a:attrs[l:attr]
                                    call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
                                  endif
                                endif
                              endfor
                            
                              return l:res
                            endfunction
                            
    1              0.000001 function! wilder#highlight#get_hl(group) abort
                              if has('nvim')
                                return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#highlight#get_hl_nvim(group) abort
                              try
                                let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
                                let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
                                return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
                              endtry
                            endfunction
                            
    1              0.000001 function! wilder#highlight#get_hl_vim(group) abort
                              try
                                let l:highlight = execute('silent highlight ' . a:group)
                            
                                let l:link_matches = matchlist(l:highlight, 'links to \(\S\+\)')
                                 " follow the link
                                if len(l:link_matches) > 0
                                  return wilder#highlight#get_hl_vim(l:link_matches[1])
                                endif
                            
                                let l:term_hl = {}
                                if match(l:highlight, 'term=\S*') >= 0
                                  call s:get_hl_attrs(l:term_hl, 'term', l:highlight)
                                endif
                            
                                let l:cterm_hl = {}
                                if match(l:highlight, 'cterm=\S*') >= 0
                                  call s:get_hl_attrs(l:cterm_hl, 'cterm', l:highlight)
                                endif
                            
                                let l:cterm_hl.background = get(matchlist(l:highlight, 'ctermbg=\([0-9A-Za-z]\+\)'), 1, 'NONE')
                                let l:cterm_hl.foreground = get(matchlist(l:highlight, 'ctermfg=\([0-9A-Za-z]\+\)'), 1, 'NONE')
                            
                                let l:gui_hl = {}
                                if match(l:highlight, 'gui=\S*') >= 0
                                  call s:get_hl_attrs(l:gui_hl, 'gui', l:highlight)
                                endif
                            
                                let l:gui_hl.background = get(matchlist(l:highlight, 'guibg=\([#0-9A-Za-z]\+\)'), 1, 'NONE')
                                let l:gui_hl.foreground = get(matchlist(l:highlight, 'guifg=\([#0-9A-Za-z]\+\)'), 1, 'NONE')
                            
                                return [l:term_hl, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
                              endtry
                            endfunction
                            
    1              0.000001 function! s:get_hl_attrs(attrs, key, hl) abort
                              let l:prefix = ' ' . a:key . '=\S*'
                            
                              for l:attr in s:attr_list
                                if match(a:hl, l:prefix . l:attr) >= 0
                                  if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
                                  endif
                                  let a:attrs[l:attr] = v:true
                                endif
                              endfor
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim
Sourced 1 time
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
    1              0.000003 let s:index = 0
                            
    1              0.000002 function! wilder#renderer#nvim_api#() abort
                              let l:state = {
                                    \ 'buf': -1,
                                    \ 'dummy_buf': -1,
                                    \ 'win': -1,
                                    \ 'ns_id': nvim_create_namespace(''),
                                    \ 'normal_highlight': 'Normal',
                                    \ 'pumblend': -1,
                                    \ 'zindex': 0,
                                    \ 'window_state': 'hidden',
                                    \ 'dimensions': -1,
                                    \ 'firstline': -1,
                                    \ 'options': {},
                                    \ }
                            
                              let l:api = {
                                    \ 'state': l:state,
                                    \ }
                            
                              for l:f in [
                                    \ 'new',
                                    \ 'show',
                                    \ 'hide',
                                    \ 'move',
                                    \ 'set_option',
                                    \ 'set_firstline',
                                    \ 'delete_all_lines',
                                    \ 'set_line',
                                    \ 'add_highlight',
                                    \ 'clear_all_highlights',
                                    \ 'need_timer',
                                    \ '_open_win',
                                    \ '_set_buf',
                                    \ ]
                                execute 'let l:api.' . l:f . ' = funcref("s:' . l:f . '")'
                              endfor
                            
                              return l:api
                            endfunction
                            
    1              0.000002 function! s:new(opts) dict abort
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
                              if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
                                let self.state.buf = s:new_buf()
                              endif
                            
                              if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
                                let self.state.dummy_buf = s:new_buf()
                              endif
                            
                              let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
                              let self.state.pumblend = get(a:opts, 'pumblend', -1)
                              let self.state.zindex = get(a:opts, 'zindex', 0)
                            endfunction
                            
    1              0.000001 function! s:new_buf() abort
                              let l:buf = nvim_create_buf(v:false, v:true)
                              call nvim_buf_set_name(l:buf, '[Wilder Float ' . s:index . ']')
                              let s:index += 1
                            
                              return l:buf
                            endfunction
                            
    1              0.000001 function! s:show() dict abort
                              if self.state.win != -1 ||
                                    \ self.state.window_state !=# 'hidden'
                                return
                              endif
                            
                              let self.state.window_state = 'pending'
                            
                              try
                                call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
                              endtry
                            endfunction
                            
    1              0.000001 function! s:_open_win() dict abort
                              " window might have been open or closed already.
                              if self.state.window_state !=# 'pending'
                                return
                              endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
                              let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
                              let l:win_opts = {
                                    \ 'relative': 'editor',
                                    \ 'height': 1,
                                    \ 'width': 1,
                                    \ 'row': &lines - 1,
                                    \ 'col': 0,
                                    \ 'focusable': 0,
                                    \ }
                            
                              if has('nvim-0.5.1')
                                let l:win_opts.zindex = self.state.zindex
                              endif
                            
                              let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
                              let self.state.window_state = 'showing'
                            
                              if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
                              else
                                call nvim_win_set_config(self.state.win, {
                                      \ 'style': 'minimal',
                                      \ })
                              endif
                            
                              call self.set_option('winhighlight',
                                    \ 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
                              if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
                              else
                                call self.set_option('winblend', &pumblend)
                              endif
                            
                              if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
                              endif
                            
                              if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, {
                                      \ 'relative': 'editor',
                                      \ 'row': l:row,
                                      \ 'col': l:col,
                                      \ 'height': l:height,
                                      \ 'width': l:width,
                                      \ })
                              endif
                            
                              for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
                              endfor
                            
                              let self.state.firstline = -1
                              let self.state.dimensions = -1
                              let self.state.options = {}
                            endfunction
                            
    1              0.000001 function! s:_set_buf() dict abort
                              if self.state.window_state !=# 'showing'
                                return
                              endif
                            
                              call nvim_win_set_buf(self.state.win, self.state.buf)
                              call nvim_win_set_config(self.state.win, {
                                    \ 'style': 'minimal',
                                    \ })
                            endfunction
                            
                            " Floating windows can't be hidden so we close the window.
    1              0.000001 function! s:hide() dict abort
                              if self.state.win == -1 ||
                                    \ self.state.window_state ==# 'hidden'
                                return
                              endif
                            
                              if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
                              endif
                            
                              if getcmdwintype() ==# ''
                                try
                                  call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
                                endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
                              endif
                            
                              let self.state.win = -1
                              let self.state.window_state = 'hidden'
                            endfunction
                            
    1              0.000001 function! s:move(row, col, height, width) dict abort
                              if self.state.window_state ==# 'hidden'
                                return
                              endif
                            
                              if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
                              endif
                            
                              call nvim_win_set_config(self.state.win, {
                                    \ 'relative': 'editor',
                                    \ 'row': a:row,
                                    \ 'col': a:col,
                                    \ 'height': a:height,
                                    \ 'width': a:width,
                                    \ })
                            endfunction
                            
    1              0.000001 function! s:set_firstline(line) dict abort
                              if self.state.window_state ==# 'hidden'
                                return
                              endif
                            
                              if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
                              endif
                            
                              call nvim_win_set_cursor(self.state.win, [a:line, 0])
                            endfunction
                            
    1              0.000001 function! s:set_option(option, value) dict abort
                              if self.state.window_state ==# 'hidden'
                                return
                              endif
                            
                              if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
                              endif
                            
                              call nvim_win_set_option(self.state.win, a:option, a:value)
                            endfunction
                            
    1              0.000001 function! s:delete_all_lines() dict abort
                              call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])
                            endfunction
                            
    1              0.000001 function! s:set_line(line, str) dict abort
                              call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])
                            endfunction
                            
    1              0.000001 function! s:add_highlight(hl, line, col_start, col_end) dict abort
                              call nvim_buf_add_highlight(self.state.buf, self.state.ns_id, a:hl, a:line, a:col_start, a:col_end)
                            endfunction
                            
    1              0.000001 function! s:clear_all_highlights() dict abort
                              if !bufexists(self.state.buf)
                                return
                              endif
                            
                              call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)
                            endfunction
                            
    1              0.000001 function! s:need_timer() dict abort
                              if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
                                return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim
Sourced 1 time
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
    1              0.000002 function! wilder#pipe#check#(args) abort
                              return {ctx, x -> s:check(a:args, ctx, x)}
                            endfunction
                            
    1              0.000001 function! s:check(checks, ctx, x) abort
                              let l:i = 0
                            
                              for l:Check in a:checks
                                if !l:Check(a:ctx, a:x)
                                  return v:false
                                endif
                              endfor
                            
                              return a:x
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim
Sourced 1 time
Total time:   0.000595
 Self time:   0.000585

count  total (s)   self (s)
    1   0.000015   0.000005 let s:cmdline_cache = wilder#cache#mru_cache(30)
                            
    1              0.000001 function! wilder#cmdline#parse(cmdline) abort
                              if !s:cmdline_cache.has_key(a:cmdline)
                                let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
                                call wilder#cmdline#main#do(l:ctx)
                            
                                let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
                                let l:ctx['pos'] = l:ctx.pos
                                call s:cmdline_cache.set(a:cmdline, l:ctx)
                              endif
                            
                              return copy(s:cmdline_cache.get(a:cmdline))
                            endfunction
                            
                            " match_arg  : the argument for the fuzzy filter to match against
                            " expand_arg : the argument passed to getcompletion()
                            " expand     : the type passed to getcompletion()
                            " fuzzy_char : the character used to get fuzzy completion if fuzzy mode is 1
    1              0.000001 function! wilder#cmdline#prepare_getcompletion(ctx, res, fuzzy, use_python) abort
                              let a:res.match_arg = a:res.arg
                              let a:res.expand_arg = has_key(a:res, 'subcommand_start')
                                    \ ? a:res.cmdline[a:res.subcommand_start :]
                                    \ : a:res.arg
                            
                              if !a:fuzzy
                                if a:res.expand ==# 'tags' &&
                                      \ !empty(a:res.expand_arg) &&
                                      \ a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
                                endif
                            
                                return a:res
                              endif
                            
                              return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)
                            endfunction
                            
                            " Sets match_arg, expand_arg fuzzy_char based on expand and expand_arg. These
                            " will be used by wilder#cmdline#get_fuzzy_completion() to decide how to get
                            " the completions.
                            " Generally we want to use the first char in expand_arg as fuzzy_char,
                            " set match_arg to expand_arg, and adjust expand_arg to '' since we are only
                            " expanding the fuzzy char.
    1              0.000001 function! s:prepare_fuzzy_completion(ctx, res, use_python) abort
                              " For non-python completion, a maximum of 300 help tags are returned, so
                              " getting all the candidates and filtering will miss out on a lot of matches
                              " If argument is empty, don't fuzzy match except for expanding 'help', where
                              " the default argument is 'help'
                              if (a:res.expand ==# 'help' && !a:use_python) ||
                                    \ a:res.pos == len(a:res.cmdline)
                                return a:res
                              endif
                            
                              " Remove the starting s: and g: so the fuzzy filter does not match against
                              " that them.
                              if (a:res.expand ==# 'expression' || a:res.expand ==# 'var') &&
                                    \ a:res.expand_arg[1] ==# ':' &&
                                    \ (a:res.expand_arg[0] ==# 'g' || a:res.expand_arg[0] ==# 's')
                                let a:res.fuzzy_char = a:res.expand_arg[2]
                                let a:res.match_arg = a:res.expand_arg[2 :]
                                let a:res.expand_arg = a:res.expand_arg[0: 1]
                            
                              " For tag-regexp, keep the argument and don't do fuzzy matching
                              elseif a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let a:res.fuzzy_char = ''
                                let a:res.match_arg = ''
                            
                              " Return all candidates and let the fuzzy filter remove the non-matching
                              " candidates for the following cases:
                              "
                              " mapping: special keys such as <Space> cannot be fuzzy completed since
                              " < will not get completions for <Space>.
                              "
                              " buffer: getcompletion() for buffers checks against the file name, but
                              " we want to check against the full path.
                              "
                              " help: help tag matching does not have to start from beginning of word.
                              elseif a:res.expand ==# 'mapping' ||
                                    \ a:res.expand ==# 'buffer' ||
                                    \ a:res.expand ==# 'help'
                                " Default argument for help completion is 'help'
                                if a:res.expand ==# 'help' && empty(a:res.expand_arg)
                                  let a:res.match_arg = 'help'
                                else
                                  let a:res.match_arg = a:res.expand_arg
                                endif
                            
                                let a:res.expand_arg = ''
                                let a:res.fuzzy_char = ''
                              else
                                " Default case, expand with the fuzzy_char
                                let a:res.fuzzy_char = strcharpart(a:res.expand_arg, 0, 1)
                                let a:res.expand_arg = ''
                              endif
                            
                              return a:res
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#prepare_file_completion(ctx, res, fuzzy)
                              let l:res = copy(a:res)
                              let l:arg = l:res.arg
                            
                              if l:res.expand ==# 'file_in_path'
                                let l:res.fuzzy_char = ''
                                let l:res.expand_arg = l:arg
                                let l:res.match_arg = l:arg
                            
                                return l:res
                              endif
                            
                              " Remove backslash preceding spaces.
                              let l:arg = substitute(l:arg, '\\ ', ' ', 'g')
                            
                              let l:slash = !has('win32') && !has('win64')
                                    \ ? '/'
                                    \ : &shellslash
                                    \ ? '/'
                                    \ : '\'
                            
                              " Special handling for ~. Return the home directory.
                              if l:arg ==# '~'
                                let l:res.fuzzy_char = ''
                                let l:res.expand_arg = ''
                                let l:res.completions = [expand('~') . l:slash]
                            
                                return l:res
                              endif
                            
                              let l:original_len = len(l:arg)
                            
                              " Expand the fnamemodify()-able part, if any.
                              " ^(%|#|<cword>|<cWORD>|<client>)(:[phtre])*
                              let l:matches = matchlist(l:arg,
                                    \ '^\(%\|#\|<cword>|<cWORD>|<client>\)' .
                                    \ '\(\%(:[phtre]\)*\)')
                              if len(l:matches) > 0
                                let l:part_to_fnamemodify = l:matches[0]
                                let l:rest = l:arg[len(l:part_to_fnamemodify) :]
                                let l:arg = expand(l:part_to_fnamemodify) . l:rest
                            
                                " Adjust current directory to empty string.
                                if l:arg ==# '.'
                                  let l:arg = ''
                                endif
                              endif
                            
                              let l:allow_backslash = has('win32') || has('win64')
                            
                              " Pattern for matching directory separator.
                              if !l:allow_backslash
                                let l:dir_sep = l:slash
                              else
                                if l:slash ==# '\'
                                  let l:dir_sep = '\\'
                                else
                                  let l:dir_sep = '/\|\\'
                                endif
                              endif
                            
                              " Handle wildcards.
                              let l:first_wildcard = match(l:arg, '\*')
                              if l:first_wildcard >= 0
                                if l:first_wildcard > 0
                                  " Expand the portion before the wildcard since expand('foo/*') will glob
                                  " for matches.
                                  let l:before_wildcard = l:arg[: l:first_wildcard - 1]
                                  let l:after_wildcard = l:arg[l:first_wildcard :]
                            
                                  let l:expand_arg = expand(l:before_wildcard) . l:after_wildcard
                                else
                                  let l:expand_arg = l:arg
                                endif
                            
                                " Don't use fuzzy matching for wildcards.
                                let l:res.has_wildcard = 1
                                let l:res.match_arg = ''
                                let l:res.expand_arg = l:expand_arg
                            
                                return l:res
                              endif
                            
                              " Split path into head and tail
                              if match(l:arg, l:dir_sep) >= 0
                                let l:head = fnamemodify(l:arg, ':h')
                                let l:tail = fnamemodify(l:arg, ':t')
                              else
                                let l:head = ''
                                let l:tail = l:arg
                              endif
                            
                              " Check if tail is trying to complete an env var.
                              let l:matches = matchlist(l:tail, '\$\(\f*\)$')
                              if len(l:matches)
                                let l:env_var = l:matches[1]
                                let l:path_prefix = l:arg[:-len(l:env_var)-1]
                            
                                let l:res.path_prefix = l:path_prefix
                                let l:res.expand = 'environment'
                                let l:res.expand_arg = ''
                                let l:res.fuzzy_char = ''
                                let l:res.completions = map(getcompletion(l:env_var, 'environment'),
                                      \ {_, x -> l:path_prefix . x})
                            
                                " Get position of the $ in tail.
                                let l:dollar_pos = len(l:tail) - len(l:env_var)
                            
                                " Show cursor after the $.
                                let l:res.pos += l:original_len - len(l:tail) + l:dollar_pos
                            
                                return l:res
                              endif
                            
                              " Append / back to l:head.
                              if !empty(l:head)
                                " Expand env vars.
                                let l:head = s:expand_user_and_env_vars(l:head)
                            
                                " Don't add / if there is already an existing / since // is not
                                " simplified - see :h simplify()).
                                if l:head[-1:] !=# l:slash
                                  let l:head .= l:slash
                                endif
                            
                                let l:head = simplify(l:head)
                              endif
                            
                              let l:res.match_arg = l:tail
                            
                              " Don't trim leading / for absolute paths when drawing.
                              let l:path_prefix = l:head ==# l:slash ? '' : l:head
                            
                              " If arg starts with ~/, show paths relative to ~.
                              " head might no longer be under ~ e.g. simplify('~/../..')
                              if l:arg[0] ==# '~' &&
                                    \ fnamemodify(l:head, ':~')[0] ==# '~' &&
                                    \ match(l:arg[1], l:dir_sep) == 0
                                let l:res.relative_to_home_dir = 1
                                let l:res.path_prefix = fnamemodify(l:path_prefix, ':~')
                              else
                                let l:res.path_prefix = l:path_prefix
                              endif
                            
                              if a:fuzzy
                                let l:res.expand_arg = l:head
                                let l:res.fuzzy_char = strcharpart(l:tail, 0, 1)
                              else
                                let l:res.expand_arg = l:head . l:tail
                                let l:res.fuzzy_char = ''
                              endif
                            
                              if !empty(l:head)
                                " Show cursor at the start of tail.
                                let l:res.pos += l:original_len - len(l:tail)
                              endif
                            
                              return l:res
                            endfunction
                            
    1              0.000002 function! wilder#cmdline#get_fuzzy_completion(ctx, res, getcompletion, fuzzy_mode, use_python) abort
                              " Use tag-regexp to get fuzzy completions from taglist()
                              if a:res.expand ==# 'tags'
                                let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                                if empty(l:fuzzy_char)
                                  let a:res.expand_arg = '.'
                                else
                                  let a:res.expand_arg = '/'
                                  if toupper(l:fuzzy_char) !=# l:fuzzy_char
                                    let a:res.expand_arg .= '\c'
                                  endif
                            
                                  if a:fuzzy_mode == 1
                                    let a:res.expand_arg .= '^'
                                  endif
                            
                                  let a:res.expand_arg .= l:fuzzy_char
                                endif
                            
                                return a:getcompletion(a:ctx, a:res)
                              endif
                            
                              " If argument is empty, use normal completions
                              " Don't fuzzy complete for vim help since a maximum of 300 help tags are returned
                              if a:res.pos == len(a:res.cmdline) ||
                                    \ (a:res.expand ==# 'help' && !a:use_python)
                                return a:getcompletion(a:ctx, a:res)
                              endif
                            
                              let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                              " Keep leading . in file expansion to search hidden directories
                              if a:fuzzy_mode == 2 &&
                                    \ !(wilder#cmdline#is_file_expansion(a:res.expand) && l:fuzzy_char ==# '.')
                                let l:fuzzy_char = ''
                              endif
                            
                              if toupper(l:fuzzy_char) ==# l:fuzzy_char
                                let a:res.expand_arg = a:res.expand_arg . l:fuzzy_char
                                return a:getcompletion(a:ctx, a:res)
                              endif
                            
                              let l:lower_res = copy(a:res)
                              let l:lower_res.expand_arg = a:res.expand_arg . l:fuzzy_char
                            
                              let l:upper_res = copy(a:res)
                              let l:upper_res.expand_arg = a:res.expand_arg . toupper(l:fuzzy_char)
                            
                              return wilder#wait(a:getcompletion(a:ctx, l:upper_res),
                                    \ {ctx, upper_xs -> wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res),
                                    \ {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))})
                            endfunction
                            
    1              0.000001 let s:cached_tags = {}
    1              0.000001 let s:cached_tags_session_id = -1
                            
    1              0.000001 function! wilder#cmdline#python_get_file_completion(ctx, res) abort
                              if has_key(a:res, 'completions')
                                return a:res['completions']
                              endif
                            
                              let l:expand_arg = a:res.expand_arg
                            
                              if a:res.expand ==# 'dir' ||
                                    \ a:res.expand ==# 'file' ||
                                    \ a:res.expand ==# 'file_in_path' ||
                                    \ a:res.expand ==# 'shellcmd'
                                return {ctx -> _wilder_python_get_file_completion(
                                      \ ctx,
                                      \ l:expand_arg,
                                      \ a:res.expand,
                                      \ get(a:res, 'has_wildcard', 0),
                                      \ get(a:res, 'path_prefix', ''),
                                      \ )}
                              endif
                            
                              if a:res.expand ==# 'user'
                                return {ctx -> _wilder_python_get_users(ctx, l:expand_arg, a:res.expand)}
                              endif
                            
                              return []
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#getcompletion(ctx, res) abort
                              if has_key(a:res, 'completions')
                                return a:res['completions']
                              endif
                            
                              let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
                              if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
                              endif
                            
                              if a:res.expand ==# 'dir' ||
                                    \ a:res.expand ==# 'file' ||
                                    \ a:res.expand ==# 'file_in_path' ||
                                    \ a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
                              endif
                            
                              if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
                                return []
                              elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
                              elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
                              elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
                              elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
                              elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
                              elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
                              elseif a:res.expand ==# 'command'
                                return getcompletion(l:expand_arg, 'command')
                              elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
                              elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
                              elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
                              elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
                              elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
                              elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
                              elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
                              elseif a:res.expand ==# 'help'
                                return getcompletion(l:expand_arg, 'help')
                              elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
                              elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
                              elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') +
                                      \ filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
                              elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
                              elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>',
                                        \ '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') .
                                      \ ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 ||
                                      \ (l:lines[0] !=# 'No mapping found' &&
                                      \ l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
                              elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
                              elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
                              elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
                              elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
                              elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(),
                                      \ {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
                              elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
                              elseif a:res.expand ==# 'profile'
                                return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'],
                                      \ {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal',
                                      \ 'enable', 'foldlevel', 'include', 'iskeyword',
                                      \ 'keyword', 'list', 'manual', 'match', 'off',
                                      \ 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers',
                                      \ 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count',
                                      \ 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth',
                                      \ 'color', 'command', 'compiler', 'cscope', 'custom',
                                      \ 'customlist', 'dir', 'environment', 'event', 'expression',
                                      \ 'file', 'file_in_path', 'filetype', 'function', 'help',
                                      \ 'highlight', 'history', 'locale', 'mapclear', 'mapping',
                                      \ 'menu', 'messages', 'option', 'packadd', 'shellcmd',
                                      \ 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles',
                                      \ 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' ||
                                      \ l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#is_file_expansion(expand) abort
                              return a:expand ==# 'file' ||
                                    \ a:expand ==# 'file_in_path' ||
                                    \ a:expand ==# 'dir' ||
                                    \ a:expand ==# 'shellcmd' ||
                                    \ a:expand ==# 'user'
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#is_user_command(cmd) abort
                              return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'
                            endfunction
                            
    1              0.000001 let s:cached_commands_session_id = -1
    1              0.000001 let s:has_completion_error = {}
    1              0.000001 let s:cached_user_commands = {}
                            
                            " returns [{handled}, {result}, {res}[, {need_filter}]]
    1              0.000001 function! wilder#cmdline#prepare_user_completion(ctx, res) abort
                              if !wilder#cmdline#is_user_command(a:res.cmd)
                                return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') &&
                                    \ l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') &&
                                    \ l:user_command['complete'] isnot v:null &&
                                    \ l:user_command['complete'] !=# 'custom' &&
                                    \ l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#replace(ctx, x, data) abort
                              let l:result = wilder#cmdline#parse(a:ctx.cmdline)
                            
                              if l:result.pos == 0
                                return a:x
                              endif
                            
                              if wilder#cmdline#is_user_command(l:result.cmd)
                                let l:pos = len(l:result.cmdline)
                                while l:pos >= l:result.pos
                                  if l:result.cmdline[l:pos] ==# ' ' || l:result.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                              else
                                let l:pos = l:result.pos - 1
                              endif
                            
                              return l:result.cmdline[: l:pos] . a:x
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#draw_path(ctx, x, data) abort
                              if get(a:data, 'cmdline.expand', '') ==# 'file_in_path'
                                return a:x
                              endif
                            
                              let l:path_prefix = get(a:data, 'cmdline.path_prefix', '')
                              return a:x[len(l:path_prefix) :]
                            endfunction
                            
    1              0.000001 function! s:convert_result_to_data(res)
                              let l:data = {
                                    \ 'pos': a:res.pos,
                                    \ 'cmdline.command': a:res.cmd,
                                    \ 'cmdline.expand': a:res.expand,
                                    \ 'cmdline.arg': a:res.arg,
                                    \ }
                            
                              if has_key(a:res, 'path_prefix')
                                let l:data['cmdline.path_prefix'] = a:res.path_prefix
                              endif
                            
                              if has_key(a:res, 'match_arg')
                                let l:data['cmdline.match_arg'] = a:res.match_arg
                              endif
                            
                              if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
                              endif
                            
                              return l:data
                            endfunction
                            
                            " Gets completions based on whether res, fuzzy and use_python
    1              0.000001 function! s:getcompletion(ctx, res, fuzzy, use_python) abort
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
                              if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
                                let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
                              elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
                              else
                                let l:Completion_func = funcref('wilder#cmdline#getcompletion')
                              endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
                              if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
                              elseif a:fuzzy
                                let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion(
                                      \ ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
                              else
                                let l:Getcompletion = l:Completion_func
                              endif
                            
                              return wilder#wait(l:Getcompletion(a:ctx, a:res),
                                    \ {ctx, xs -> wilder#resolve(ctx, {
                                    \ 'value': xs,
                                    \ 'pos': a:res.pos,
                                    \ 'data': s:convert_result_to_data(a:res),
                                    \ })})
                            endfunction
                            
    1              0.000001 function wilder#cmdline#should_use_file_finder(res) abort
                              if has_key(a:res, 'completions')
                                return v:false
                              endif
                            
                              let l:arg = a:res.arg
                            
                              if match(l:arg, '\*') != -1
                                return 0
                              endif
                            
                              if l:arg[0] ==# '%' ||
                                    \ l:arg[0] ==# '#' ||
                                    \ l:arg[0] ==# '<'
                                return 0
                              endif
                            
                              let l:path = a:res.expand_arg
                            
                              " Prevent scanning of filesystem accidentally.
                              if l:path ==# '~' ||
                                    \ l:path[0] ==# '/' ||
                                    \ l:path[0] ==# '\' ||
                                    \ l:path[0:1] ==# '..'
                                return 0
                              endif
                            
                              if has('win32') || has('win64')
                                return l:path[1] !=# ':'
                              endif
                            
                              return 1
                            endfunction
                            
    1              0.000004 let s:substitute_commands = {
                                  \ 'substitute': v:true,
                                  \ 'smagic': v:true,
                                  \ 'snomagic': v:true,
                                  \ 'global': v:true,
                                  \ 'vglobal': v:true,
                                  \ }
                            
    1              0.000001 function! wilder#cmdline#is_substitute_command(cmd) abort
                              return has_key(s:substitute_commands, a:cmd)
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#substitute_pipeline(opts) abort
                              if has_key(a:opts, 'hide_in_replace')
                                let l:hide_in_replace = a:opts.hide_in_replace
                              elseif has_key(a:opts, 'hide')
                                " DEPRECATED: use hide_in_replace
                                let l:hide_in_replace = a:opts.hide
                              else
                                let l:hide_in_replace = has('nvim') && !has('nvim-0.3.7')
                              endif
                            
                              if has_key(a:opts, 'pipeline')
                                let l:search_pipeline = a:opts['pipeline']
                              elseif wilder#options#get('use_python_remote_plugin')
                                let l:search_pipeline = wilder#python_search_pipeline({'skip_cmdtype_check': 1})
                              else
                                let l:search_pipeline = wilder#vim_search_pipeline({'skip_cmdtype_check': 1})
                              endif
                            
                              " cmdline
                              " : check getcmdtype()?
                              " |--> return v:false
                              " : parse_cmdline
                              " : check is substitute command
                              " |--> return v:false
                              " : check len(substitute_args) s[/][pattern][/][replace][/][flags]
                              " |--> return v:false or v:true
                              " : extract substitute [pattern]
                              " : search_pipeline
                              " : add command, pos and replace
                              " └--> result
                              return [
                                    \ wilder#check({-> getcmdtype() ==# ':'}),
                                    \ {_, x -> wilder#cmdline#parse(x)},
                                    \ wilder#check({_, res -> wilder#cmdline#is_substitute_command(res.cmd)}),
                                    \ {_, res -> res.cmd ==# 'global' || res.cmd ==# 'vglobal' ||
                                    \   len(res.substitute_args) == 1 || len(res.substitute_args) == 2 ?
                                    \   res :
                                    \   l:hide_in_replace ? v:true : v:false},
                                    \ wilder#subpipeline({ctx, res -> [
                                    \   {_, res -> res.cmd ==# 'global' || res.cmd ==# 'vglobal' ?
                                    \     res.arg :
                                    \     res.substitute_args[1]},
                                    \ ] + l:search_pipeline + [
                                    \   wilder#result({
                                    \     'data': {
                                    \       'cmdline.command': res.cmd,
                                    \     },
                                    \     'pos': res.pos + 1,
                                    \     'replace': ['wilder#cmdline#replace'],
                                    \   }),
                                    \ ]}),
                                    \ ]
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#python_file_finder_pipeline(opts) abort
                              let l:opts = copy(a:opts)
                            
                              let l:should_debounce = get(l:opts, 'debounce', 0) > 0
                              if l:should_debounce
                                let l:debounce_interval = l:opts['debounce']
                                let l:Debounce = wilder#debounce(l:debounce_interval)
                              else
                                let l:Debounce = 0
                              endif
                            
                              if has_key(l:opts, 'filters')
                                let l:checked_filters = []
                            
                                for l:filter in l:opts['filters']
                                  if type(l:filter) isnot v:t_dict
                                    let l:filter = {'name': l:filter}
                                  endif
                            
                                  let l:filter_opts = get(l:filter, 'opts', {})
                                  let l:filter['opts'] = l:filter_opts
                            
                                  if l:filter['name'] ==# 'fruzzy_filter' &&
                                        \ !has_key(l:filter_opts, 'fruzzy_path')
                                    let l:filter_opts['fruzzy_path'] = wilder#fruzzy_path()
                                  endif
                            
                                  if l:filter['name'] ==# 'cpsm_filter' &&
                                        \ !has_key(l:filter_opts, 'cpsm_path')
                                    let l:filter_opts['cpsm_path'] = wilder#cpsm_path()
                                  endif
                            
                                  if l:filter['name'] ==# 'clap_filter'
                                    if !has_key(l:filter_opts, 'clap_path')
                                      let l:filter_opts['clap_path'] = wilder#clap_path()
                                    endif
                            
                                    if !has_key(l:filter_opts, 'use_rust')
                                      let l:use_rust = !empty(wilder#findfile('pythonx/clap/fuzzymatch_rs.so')) ||
                                            \ !empty(wilder#findfile('pythonx/clap/fuzzymatch_rs.dyn'))
                                      let l:filter_opts['use_rust'] = l:use_rust
                                    endif
                                  endif
                            
                                  call add(l:checked_filters, l:filter)
                                endfor
                            
                                let l:opts['filters'] = l:checked_filters
                              else
                                let l:opts['filters'] = [{'name': 'fuzzy_filter', 'opts': {}}, {'name': 'difflib_sorter', 'opts': {}}]
                              endif
                            
                              if !has_key(l:opts, 'path')
                                let l:opts['path'] = wilder#project_root()
                              endif
                            
                              let l:Path = l:opts['path']
                              if type(l:Path) isnot v:t_func
                                let l:opts['path'] = {-> l:Path}
                              endif
                            
                              " cmdline
                              " : check getcmdtype()?
                              " |--> return v:false
                              " : parse_cmdline
                              " : prepare user completion to update res.expand
                              " : if handled
                              " |--> return v:false
                              " : check is file or dir
                              " |--> return v:false
                              " : prepare_file_completion
                              " | reset parsed.pos to original
                              " : should use file finder?
                              " |--> return v:false
                              " : debounce if needed
                              " : _wilder_python_file_finder
                              " : add pos, replace and data
                              " └--> result
                              return [
                                    \ wilder#check({-> getcmdtype() ==# ':'}),
                                    \ {_, x -> wilder#cmdline#parse(x)},
                                    \ {ctx, res -> wilder#cmdline#prepare_user_completion(ctx, res)},
                                    \ {ctx, res -> res[0] ? v:false : res[2]},
                                    \ wilder#check({_, res -> res.expand ==# 'file' || res.expand ==# 'dir'}),
                                    \ wilder#subpipeline({ctx, res1 -> [
                                    \   {ctx, res1 -> wilder#cmdline#prepare_file_completion(ctx, copy(res1), 0)},
                                    \   {ctx, res2 -> extend(res2, {'pos': res1.pos})},
                                    \ ]}),
                                    \ wilder#check({ctx, res -> wilder#cmdline#should_use_file_finder(res)}),
                                    \ wilder#if(l:should_debounce, l:Debounce),
                                    \ wilder#subpipeline({ctx, res -> [
                                    \   {-> s:file_finder(ctx, l:opts, res)},
                                    \   wilder#result({
                                    \     'pos': res.pos,
                                    \     'replace': ['wilder#cmdline#replace'],
                                    \     'data': extend(s:convert_result_to_data(res), {'query': s:expand_user_and_env_vars(res.arg)}),
                                    \   }),
                                    \ ]}),
                                    \ ]
                            endfunction
                            
    1              0.000001 function! s:expand_user_and_env_vars(arg)
                              let l:slash = !has('win32') && !has('win64')
                                    \ ? '/'
                                    \ : &shellslash
                                    \ ? '/'
                                    \ : '\'
                            
                              let l:path_segments = split(a:arg, l:slash, 1)
                            
                              if empty(l:path_segments)
                                return a:arg
                              endif
                            
                              call map(l:path_segments, {_, p -> p[0] ==# '$' ? eval(p) : p})
                            
                              if l:path_segments[0][0] ==# '~'
                                let l:path_segments[0] = expand(l:path_segments[0])
                              endif
                            
                              return join(l:path_segments, l:slash)
                            endfunction
                            
    1              0.000001 function! s:file_finder(ctx, opts, res) abort
                              let l:cwd = getcwd()
                              let l:match_arg = s:expand_user_and_env_vars(a:res.arg)
                              let l:is_dir = a:res.expand ==# 'dir'
                            
                              if !l:is_dir
                                if has_key(a:opts, 'file_command')
                                  let l:Command = a:opts['file_command']
                                else
                                  let l:Command = ['find', '.', '-type', 'f', '-printf', '%P\n']
                                endif
                              else
                                if has_key(a:opts, 'dir_command')
                                  let l:Command = a:opts['dir_command']
                                else
                                  let l:Command = ['find', '.', '-type', 'd', '-printf', '%P\n']
                                endif
                              endif
                            
                              if type(l:Command) is v:t_func
                                let l:Command = l:Command(a:ctx, l:match_arg)
                            
                                if l:Command is v:false
                                  return v:false
                                endif
                              endif
                            
                              if has_key(a:opts, 'cache_timestamp')
                                let l:timestamp = a:opts['cache_timestamp'](a:ctx)
                              else
                                let l:timestamp = a:ctx.session_id
                              endif
                            
                              let l:path = a:opts['path'](a:ctx, l:match_arg)
                            
                              let l:opts = {
                                    \ 'timeout': get(a:opts, 'timeout', 5000),
                                    \ }
                            
                              return {ctx -> _wilder_python_file_finder(ctx, l:opts, l:Command, a:opts['filters'],
                                    \ l:cwd, l:path, l:match_arg, l:is_dir, l:timestamp)}
                            endfunction
                            
    1              0.000001 function! s:simplify(path)
                              let l:path = simplify(a:path)
                            
                              let l:slash = !has('win32') && !has('win64')
                                    \ ? '/'
                                    \ : &shellslash
                                    \ ? '/'
                                    \ : '\'
                            
                              if a:path[-2:-1] ==# '/.' || a:path[-2:-1] ==# l:slash . '.'
                                let l:path .= a:path[-2:-1]
                              endif
                            
                              return l:path
                            endfunction
                            
    1              0.000001 function! s:get_opts(opts) abort
                              if has_key(a:opts, 'language')
                                let l:use_python = a:opts['language'] ==# 'python'
                              elseif has_key(a:opts, 'use_python')
                                let l:use_python = a:opts['use_python']
                              else
                                let l:use_python = wilder#options#get('use_python_remote_plugin')
                              endif
                            
                              let l:fuzzy = get(a:opts, 'fuzzy', 0)
                              let l:with_data = 0
                              if l:fuzzy
                                if has_key(a:opts, 'fuzzy_filter_with_data')
                                  let l:with_data = 1
                                  let l:Filter = a:opts['fuzzy_filter_with_data']
                                elseif has_key(a:opts, 'fuzzy_filter')
                                  let l:Filter = a:opts['fuzzy_filter']
                                elseif l:use_python
                                  let l:Filter = wilder#python_fuzzy_filter()
                                else
                                  let l:Filter = wilder#vim_fuzzy_filter()
                                endif
                              else
                                let l:Filter = 0
                              endif
                            
                              return [l:Filter, l:with_data, l:use_python, l:fuzzy]
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#getcompletion_pipeline(opts) abort
                              let [l:Filter, l:with_data, l:use_python, l:fuzzy] = s:get_opts(a:opts)
                            
                              " parsed cmdline
                              " : prepare_file_completion
                              " : s:getcompletion
                              " : map if relative_to_home_dir
                              " : fuzzy_filter if needed
                              " └--> result
                              let l:file_completion_subpipeline = [
                                    \ wilder#check({_, res -> wilder#cmdline#is_file_expansion(res.expand)}),
                                    \ {ctx, res -> wilder#cmdline#prepare_file_completion(ctx, res, l:fuzzy)},
                                    \ wilder#subpipeline({ctx, res -> [
                                    \   {ctx, res -> s:getcompletion(ctx, res, l:fuzzy, l:use_python)},
                                    \   wilder#result({
                                    \     'value': {ctx, xs, data -> l:fuzzy == 0 ?
                                    \       s:filter_file_in_path(ctx, xs, data) : xs},
                                    \   }),
                                    \   wilder#result({
                                    \     'value': {ctx, xs -> get(res, 'relative_to_home_dir', 0) ?
                                    \       map(xs, {i, x -> fnamemodify(x, ':~')}) : xs},
                                    \   }),
                                    \ ]}),
                                    \ wilder#if(l:fuzzy && !l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, xs, get(data, 'cmdline.path_prefix', '') . get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ wilder#if(l:fuzzy && l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, data, xs, get(data, 'cmdline.path_prefix', '') . get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ wilder#result({
                                    \   'draw': ['wilder#cmdline#draw_path'],
                                    \   'replace': ['wilder#cmdline#replace'],
                                    \ }),
                                    \ wilder#result_output_escape(' '),
                                    \ ]
                            
                              " parsed cmdline
                              " : prepare_completion
                              " : s:getcompletion
                              " : fuzzy_filter if needed
                              " └--> result
                              let l:completion_subpipeline = [
                                    \ {ctx, res -> wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)},
                                    \ {ctx, res -> s:getcompletion(ctx, res, l:fuzzy, l:use_python)},
                                    \ wilder#if(l:fuzzy && !l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, xs, get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ wilder#if(l:fuzzy && l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, data, xs, get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ wilder#result({
                                    \   'replace': ['wilder#cmdline#replace'],
                                    \ }),
                                    \ ]
                            
                              let l:lua_completion_subpipeline = [
                                    \ wilder#check({_, res -> res.expand ==# 'lua'}),
                                    \ {ctx, res -> has('nvim-0.5') ? res : v:false},
                                    \ {ctx, res -> s:get_lua_completion(ctx, res, l:fuzzy)},
                                    \ wilder#if(l:fuzzy && !l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, xs, get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ wilder#if(l:fuzzy && l:with_data, wilder#result({
                                    \   'value': {ctx, xs, data -> l:Filter(
                                    \     ctx, data, xs, get(data, 'cmdline.match_arg', ''))},
                                    \ })),
                                    \ ]
                            
                              " parsed cmdline
                              " : is file expansion?
                              " |--> file_completion_pipeline
                              " └--> completion_pipeline
                              return [
                                    \ wilder#branch(
                                    \   l:lua_completion_subpipeline,
                                    \   l:file_completion_subpipeline,
                                    \   l:completion_subpipeline,
                                    \ ),
                                    \ ]
                            endfunction
                            
    1              0.000001 function! s:filter_file_in_path(ctx, xs, data) abort
                              if get(a:data, 'cmdline.expand', '') !=# 'file_in_path'
                                return a:xs
                              endif
                            
                              let l:arg = get(a:data, 'cmdline.arg', '')
                              return filter(a:xs, {_, x -> stridx(x, l:arg) != -1})
                            endfunction
                            
    1              0.000001 function! s:get_lua_completion(ctx, res, fuzzy) abort
                              let l:last_char = a:res.arg[-1 :]
                              if !empty(l:last_char) &&
                                    \ l:last_char !~# '\w' &&
                                    \ l:last_char !=# '_' &&
                                    \ l:last_char !=# '.'
                                " _expand_arg fails when arg ends with non-identifier
                                let l:candidates = luaeval('{vim._expand_pat("")}')[0]
                                let l:arg_pos = len(a:res.arg)
                              else
                                let [l:candidates, l:arg_pos] = luaeval('{vim._expand_pat("^" .. _A[1])}', [a:res.arg])
                            
                                if a:fuzzy
                                  let l:last_char = a:res.arg[-1 :]
                            
                                  " use arg_pos to calculate where arg starts
                                  let l:arg = l:arg_pos > 0 ?
                                        \ a:res.arg[: l:arg_pos - 1] :
                                        \ ''
                            
                                  let l:last_char = l:arg[-1 :]
                                  if !empty(l:last_char) &&
                                        \ l:last_char !~# '\w' &&
                                        \ l:last_char !=# '_' &&
                                        \ l:last_char !=# '.'
                                    let l:candidates = luaeval('{vim._expand_pat("")}')[0]
                                  else
                                    let l:candidates = luaeval('{vim._expand_pat("^" .. _A[1])}', [l:arg])[0]
                                  endif
                                endif
                              endif
                            
                              if l:arg_pos > 0
                                let l:prefix = a:res.arg[: l:arg_pos - 1]
                                let l:match_arg = a:res.arg[l:arg_pos :]
                                let l:pos = a:res.pos + l:arg_pos - 1
                              else
                                let l:prefix = ''
                                let l:match_arg = a:res.arg
                                let l:pos = a:res.pos
                              endif
                            
                              if a:fuzzy == 1 && !empty(l:match_arg)
                                let l:char = l:match_arg[0]
                                let l:candidates = filter(l:candidates, {_, x -> x[0] ==# tolower(l:char) || x[0] ==# toupper(l:char)})
                              endif
                            
                              return {
                                    \ 'value': l:candidates,
                                    \ 'pos': l:pos,
                                    \ 'replace': ['wilder#cmdline#replace_lua'],
                                    \ 'data': {
                                    \   'cmdline.match_arg': l:match_arg,
                                    \   'cmdline.lua_prefix': l:prefix,
                                    \ },
                                    \ }
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#replace_lua(ctx, x, data)
                              let l:result = wilder#cmdline#parse(a:ctx.cmdline)
                            
                              if l:result.pos > 0
                                let l:cmdline = l:result.cmdline[: l:result.pos - 1]
                              else
                                let l:cmdline = ''
                              endif
                            
                              return l:cmdline . get(a:data, 'cmdline.lua_prefix', '') . a:x
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#pipeline(opts) abort
                              if has_key(a:opts, 'hide_in_substitute')
                                let l:hide_in_substitute = a:opts.hide_in_substitute
                              elseif has_key(a:opts, 'hide')
                                " DEPRECATED: use hide_in_substitute
                                let l:hide_in_substitute = a:opts.hide
                              else
                                let l:hide_in_substitute = has('nvim') && !has('nvim-0.3.7')
                              endif
                            
                              let l:Sorter = get(a:opts, 'sorter', get(a:opts, 'sort', 0))
                            
                              let l:set_pcre2_pattern = get(a:opts, 'set_pcre2_pattern', 0)
                            
                              let l:sort_buffers_lastused = get(a:opts, 'sort_buffers_lastused', 1)
                            
                              let l:should_debounce = get(a:opts, 'debounce', 0) > 0
                              if l:should_debounce
                                let l:debounce_interval = a:opts['debounce']
                                let l:Debounce = wilder#debounce(l:debounce_interval)
                              else
                                let l:Debounce = 0
                              endif
                            
                              let l:opts = s:get_opts(a:opts)
                              let l:F = l:opts[0]
                              let l:with_data = l:opts[1]
                              let l:fuzzy = l:opts[3]
                            
                              if l:fuzzy
                                if l:with_data
                                  let l:Filter = {ctx, xs, q -> l:F(ctx, {}, xs, q)}
                                else
                                  let l:Filter = l:F
                                endif
                              else
                                let l:Filter = {ctx, xs, q -> filter(xs, {_, x -> match(x, q) == 0})}
                              endif
                            
                              " [handled, user_completions, parsed, need_filter]
                              " : handled?
                              " └--> user_completions
                              let l:user_completion_pipeline = [
                                    \ {ctx, res -> res[0] ? res : v:false},
                                    \ wilder#subpipeline({ctx, res -> [
                                    \   {_, res -> res[1]},
                                    \   wilder#result({
                                    \     'value': {ctx, xs -> res[3] ? l:Filter(ctx, xs, res[2].arg) : xs},
                                    \     'pos': res[2].pos,
                                    \     'replace': ['wilder#cmdline#replace'],
                                    \     'data': s:convert_result_to_data(res[2]),
                                    \   }),
                                    \ ]}),
                                    \ ]
                            
                              " [handled, user_completions, parsed]
                              " : not handled, extract parsed
                              " : getcompletion_pipeline 
                              " : sort if needed
                              " : add pcre2 pattern if needed
                              " └--> result
                              let l:getcompletion_pipeline = [{ctx, res -> res[2]}] +
                                    \ wilder#cmdline#getcompletion_pipeline(a:opts) + [
                                    \ wilder#if(l:Sorter isnot 0, wilder#result({
                                    \   'value': {ctx, xs, data ->
                                    \     l:Sorter(ctx, xs, get(data, 'cmdline.match_arg', ''))}
                                    \ })),
                                    \ wilder#if(l:set_pcre2_pattern, wilder#result({
                                    \   'data': {ctx, data -> s:set_pcre2_pattern(data, l:fuzzy)},
                                    \ })),
                                    \ ]
                            
                              " cmdline
                              " : check getcmdtype()?
                              " |--> return v:false
                              " : parse_cmdline
                              " : check is substitute command and should hide?
                              " |--> return v:true
                              " : prepare_user_completion
                              " : is user completion?
                              " |--> user_completion_pipeline
                              " └--> getcompletion_pipeline
                              "    : add data.query
                              "    └--> result
                              return [
                                    \ wilder#check({-> getcmdtype() ==# ':'}),
                                    \ {_, x -> wilder#cmdline#parse(x)},
                                    \ wilder#if(l:hide_in_substitute, {ctx, res -> len(get(res, 'substitute_args', [])) >= 2 ? v:true : res}),
                                    \ wilder#if(l:should_debounce, l:Debounce),
                                    \ {ctx, res -> wilder#cmdline#prepare_user_completion(ctx, res)},
                                    \ wilder#branch(
                                    \   l:user_completion_pipeline,
                                    \   l:getcompletion_pipeline,
                                    \ ),
                                    \ wilder#result({
                                    \   'value': {ctx, xs, data -> l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs},
                                    \   'data': {ctx, data -> s:set_query(data)},
                                    \ }),
                                    \ ]
                            endfunction
                            
    1              0.000001 function! s:set_pcre2_pattern(data, fuzzy) abort
                              let l:data = a:data is v:null ? {} : a:data
                              let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
                              if a:fuzzy
                                let l:pcre2_pattern = wilder#transform#make_python_fuzzy_regex(l:match_arg)
                              else
                                let l:pcre2_pattern = '('. escape(l:match_arg, '\.^$*+?|(){}[]') . ')'
                              endif
                            
                              return extend(l:data, {'pcre2.pattern': l:pcre2_pattern})
                            endfunction
                            
    1              0.000001 function! s:sort_buffers_lastused(ctx, xs, data) abort
                              if get(a:data, 'cmdline.expand', '') !=# 'buffer'
                                return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed ||
                                        \ empty(l:bufname) ||
                                        \ has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})
                            endfunction
                            
    1              0.000001 function! s:sort_buffers_lastused_func(x1, x2, x_to_info, current_bufnr) abort
                              let l:info1 = get(a:x_to_info, a:x1, {})
                              let l:lastused1 = get(l:info1, 'lastused', 1000000000)
                              let l:info2 = get(a:x_to_info, a:x2, {})
                              let l:lastused2 = get(l:info2, 'lastused', 1000000000)
                            
                              if get(l:info1, 'bufnr', -1) == a:current_bufnr
                                return 1
                              endif
                            
                              if get(l:info2, 'bufnr', -1) == a:current_bufnr
                                return -1
                              endif
                            
                              return l:lastused2 - l:lastused1
                            endfunction
                            
    1              0.000001 function! s:set_query(data) abort
                              let l:data = a:data is v:null ? {} : a:data
                              let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
                              return extend(l:data, {'query': l:match_arg})
                            endfunction
                            
    1              0.000001 function! s:is_prefix(str, q) abort
                              if empty(a:q)
                                return 1
                              endif
                            
                              if len(a:q) > len(a:str)
                                return 0
                              endif
                            
                              return a:str[0 : len(a:q) - 1] ==# a:q
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/python3.vim
Sourced 1 time
Total time:   0.145790
 Self time:   0.000402

count  total (s)   self (s)
                            " The Python3 provider uses a Python3 host to emulate an environment for running
                            " python3 plugins. :help provider
                            "
                            " Associating the plugin with the Python3 host is the first step because
                            " plugins will be passed as command-line arguments
                            
    1              0.000002 if exists('g:loaded_python3_provider')
                              finish
    1              0.000000 endif
    1   0.145458   0.000119 let [s:prog, s:err] = provider#pythonx#Detect(3)
    1              0.000004 let g:loaded_python3_provider = empty(s:prog) ? 1 : 2
                            
    1              0.000002 function! provider#python3#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000001 function! provider#python3#Error() abort
                              return s:err
                            endfunction
                            
                            " The Python3 provider plugin will run in a separate instance of the Python3
                            " host.
    1   0.000020   0.000008 call remote#host#RegisterClone('legacy-python3-provider', 'python3')
    1   0.000041   0.000005 call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
                            
    1              0.000001 function! provider#python3#Call(method, args) abort
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim
Sourced 1 time
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
                            " The Python provider helper
    1              0.000002 if exists('s:loaded_pythonx_provider')
                              finish
    1              0.000000 endif
                            
    1              0.000001 let s:loaded_pythonx_provider = 1
                            
    1              0.000001 function! provider#pythonx#Require(host) abort
                              " Python host arguments
                              let prog = provider#python3#Prog()
                              let args = [prog, '-c', 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; neovim.start_host()']
                            
                            
                              " Collect registered Python plugins into args
                              let python_plugins = remote#host#PluginsForHost(a:host.name)
                              for plugin in python_plugins
                                call add(args, plugin.path)
                              endfor
                            
                              return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})
                            endfunction
                            
    1              0.000001 function! s:get_python_executable_from_host_var(major_version) abort
                              return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : execute("throw 'unsupported'")).'_host_prog', ''), v:true)
                            endfunction
                            
    1              0.000001 function! s:get_python_candidates(major_version) abort
                              return {
                                    \ 3: ['python3', 'python3.10', 'python3.9', 'python3.8', 'python3.7', 'python']
                                    \ }[a:major_version]
                            endfunction
                            
                            " Returns [path_to_python_executable, error_message]
    1              0.000001 function! provider#pythonx#Detect(major_version) abort
                              return provider#pythonx#DetectByModule('neovim', a:major_version)
                            endfunction
                            
                            " Returns [path_to_python_executable, error_message]
    1              0.000001 function! provider#pythonx#DetectByModule(module, major_version) abort
                              let python_exe = s:get_python_executable_from_host_var(a:major_version)
                            
                              if !empty(python_exe)
                                return [exepath(expand(python_exe, v:true)), '']
                              endif
                            
                              let candidates = s:get_python_candidates(a:major_version)
                              let errors = []
                            
                              for exe in candidates
                                let [result, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)
                                if result
                                  return [exe, error]
                                endif
                                " Accumulate errors in case we don't find any suitable Python executable.
                                call add(errors, error)
                              endfor
                            
                              " No suitable Python executable found.
                              return ['', 'Could not load Python '.a:major_version.":\n".join(errors, "\n")]
                            endfunction
                            
                            " Returns array: [prog_exitcode, prog_version]
    1              0.000001 function! s:import_module(prog, module) abort
                              let prog_version = system([a:prog, '-c' , printf(
                                    \ 'import sys; ' .
                                    \ 'sys.path = [p for p in sys.path if p != ""]; ' .
                                    \ 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' .
                                    \ 'import pkgutil; ' .
                                    \ 'exit(2*int(pkgutil.get_loader("%s") is None))',
                                    \ a:module)])
                              return [v:shell_error, prog_version]
                            endfunction
                            
                            " Returns array: [was_success, error_message]
    1              0.000001 function! provider#pythonx#CheckForModule(prog, module, major_version) abort
                              let prog_path = exepath(a:prog)
                              if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
                              let min_version = '3.7'
                            
                              " Try to load module, and output Python version.
                              " Exit codes:
                              "   0  module can be loaded.
                              "   2  module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
                              let [prog_exitcode, prog_version] = s:import_module(a:prog, a:module)
                            
                              if prog_exitcode == 2 || prog_exitcode == 0
                                " Check version only for expected return codes.
                                if prog_version !~ '^' . a:major_version
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python '
                                        \ . a:major_version . '.']
                                elseif prog_version =~ '^' . a:major_version && str2nr(prog_version[2:]) < str2nr(min_version[2:])
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python >= '
                                        \ . min_version . '.']
                                endif
                              endif
                            
                              if prog_exitcode == 2
                                return [0, prog_path.' does not have the "' . a:module . '" module.']
                              elseif prog_exitcode == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_version]
                              elseif prog_exitcode
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. '
                                      \ . '(' . prog_exitcode . ', output: ' . prog_version . ')'
                                      \ . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/subpipeline.vim
Sourced 1 time
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    1              0.000002 function! wilder#pipe#subpipeline#(f) abort
                              return {_, x -> {ctx -> s:subpipeline(a:f, ctx, x)}}
                            endfunction
                            
    1              0.000002 function! s:subpipeline(pipeline_func, ctx, x) abort
                              let l:handler_id = a:ctx.handler_id
                              let l:pipeline = a:pipeline_func(a:ctx, a:x)
                            
                              call wilder#pipeline#run(
                                    \ l:pipeline,
                                    \ {ctx, x -> s:on_finish(l:handler_id, ctx, x)},
                                    \ {ctx, x -> s:on_error(l:handler_id, ctx, x)},
                                    \ copy(a:ctx),
                                    \ copy(a:x),
                                    \ )
                            endfunction
                            
    1              0.000001 function! s:on_finish(handler_id, ctx, x) abort
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:handler_id
                            
                              call wilder#resolve(l:ctx, a:x)
                            endfunction
                            
    1              0.000001 function! s:on_error(handler_id, ctx, x) abort
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim
Sourced 1 time
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    1              0.000001 function! wilder#pipe#result#(...) abort
                              let l:args = a:0 ? a:1 : {}
                              return {ctx, x -> s:result_start(l:args, ctx, x)}
                            endfunction
                            
    1              0.000001 function! s:result_start(args, ctx, x) abort
                              let l:kvs = []
                              for l:key in keys(a:args)
                                call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
                              endfor
                            
                              let l:result = type(a:x) isnot v:t_dict
                                    \ ? {'value': a:x}
                                    \ : a:x
                            
                              if empty(l:kvs)
                                return l:result
                              endif
                            
                              return s:result(l:kvs, a:ctx, l:result)
                            endfunction
                            
    1              0.000001 function! s:result(kvs, ctx, result)
                              if empty(a:kvs)
                                return a:result
                              endif
                            
                              let l:kvs = a:kvs
                            
                              while !empty(l:kvs)
                                let l:kv = l:kvs[0]
                                let l:kvs = l:kvs[1:]
                                let l:key = l:kv.key
                                let l:Value = l:kv.value
                            
                                if type(l:Value) is v:t_func
                                  let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
                                  if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value ->
                                          \ wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
                                  endif
                            
                                  let a:result[l:key] = l:R
                                elseif type(l:Value) is v:t_list
                                  let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
                                endif
                              endwhile
                            
                              return a:result
                            endfunction
                            
    1              0.000001 function! s:extend(ctx, key, value)
                              let l:ctx = copy(a:ctx)
                              let l:ctx[a:key] = extend(get(l:ctx, a:key, {}), a:value)
                              return l:ctx
                            endfunction
                            
    1              0.000001 function! s:add_key(result, key, value)
                              let l:result = copy(a:result)
                              let l:result[a:key] = a:value
                              return l:result
                            endfunction
                            
    1              0.000001 function! wilder#pipe#result#escape_output_result(chars) abort
                              return wilder#result({
                                    \ 'output': ['wilder#pipe#result#escape_output'],
                                    \ 'data': {ctx, data -> s:set_data(data, a:chars)},
                                    \ })
                            endfunction
                            
    1              0.000001 function! wilder#pipe#result#escape_output(ctx, x, data) abort
                              return escape(a:x, get(a:data, 'escape_chars', ''))
                            endfunction
                            
    1              0.000001 function! s:set_data(data, chars) abort
                              let l:data = a:data is v:null ? {} : a:data
                            
                              return extend(l:data, {'escape_chars': a:chars})
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000002 function! wilder#pipe#branch#(args) abort
                              if len(a:args) == 0
                                return {_, x -> v:false}
                              endif
                            
                              return {_, x -> {ctx -> s:branch(a:args, ctx, x)}}
                            endfunction
                            
    1              0.000001 function! s:branch(pipelines, ctx, x) abort
                              let l:state = {
                                    \ 'index': 0,
                                    \ 'pipelines': a:pipelines,
                                    \ 'original_ctx': copy(a:ctx),
                                    \ 'original_x': copy(a:x),
                                    \ }
                            
                              call wilder#pipeline#run(
                                    \ l:state.pipelines[0],
                                    \ {ctx, x -> s:on_finish(l:state, ctx, x)},
                                    \ {ctx, x -> s:on_error(l:state, ctx, x)},
                                    \ copy(a:ctx),
                                    \ copy(a:x),
                                    \ )
                            endfunction
                            
    1              0.000001 function! s:on_finish(state, ctx, x) abort
                              if a:x isnot v:false
                                call s:resolve(a:state, a:ctx, a:x)
                                return
                              endif
                            
                              let a:state.index += 1
                            
                              if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
                              endif
                            
                              call wilder#pipeline#run(
                                    \ a:state.pipelines[a:state.index],
                                    \ {ctx, x -> s:on_finish(a:state, ctx, x)},
                                    \ {ctx, x -> s:on_error(a:state, ctx, x)},
                                    \ copy(a:state.original_ctx),
                                    \ copy(a:state.original_x),
                                    \ )
                            endfunction
                            
    1              0.000001 function! s:resolve(state, ctx, x) abort
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
                              call wilder#resolve(l:ctx, a:x)
                            endfunction
                            
    1              0.000001 function! s:on_error(state, ctx, x) abort
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/vim_search.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000001 function! wilder#pipe#vim_search#(opts) abort
                              return {ctx, x -> s:search(a:opts, ctx, x)}
                            endfunction
                            
    1              0.000001 function! s:search(opts, ctx, x) abort
                              let l:cursor_pos = getcurpos()
                              let l:candidates = []
                              let l:candidates_set = {}
                              let l:max_candidates = get(a:opts, 'max_candidates', 300)
                            
                              let l:current_line = l:cursor_pos[1]
                              try
                                silent exe 'keeppatterns ' . l:current_line . ',$s/' . a:x . '/\=s:add(submatch(0), l:candidates, l:candidates_set, l:max_candidates)/gne'
                                silent exe 'keeppatterns 1,' . l:current_line . 's/' . a:x . '/\=s:add(submatch(0), l:candidates, l:candidates_set, l:max_candidates)/gne'
                              catch /^wilder: Max candidates reached/
                                return l:candidates
                              finally
                                call setpos('.', l:cursor_pos)
                              endtry
                            
                              return l:candidates
                            endfunction
                            
    1              0.000001 function! s:add(match, candidates, candidates_set, max_candidates) abort
                              if has_key(a:candidates_set, a:match)
                                return
                              endif
                            
                              let a:candidates_set[a:match] = 1
                              call add(a:candidates, a:match)
                            
                              if a:max_candidates > 0 && len(a:candidates) >= a:max_candidates
                                call s:throw()
                              endif
                            endfunction
                            
    1              0.000001 function! s:throw() abort
                              throw 'wilder: Max candidates reached'
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim
Sourced 1 time
Total time:   0.000429
 Self time:   0.000427

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
                            
                            " wilder is enabled
    1              0.000001 let s:enabled = 1
                            " _wilder_init() has been called
    1              0.000001 let s:init = 0
                            " wilder is active (enabled, after CmdlineEnter, before CmdlineLeave)
    1              0.000001 let s:active = 0
                            " wilder is hidden (v:true returned from pipeline)
    1              0.000001 let s:hidden = 0
                            " timer used when use_cmdlinechanged == 0
    1              0.000001 let s:timer = v:null
                            " number of CmdlineEnter triggered
    1              0.000001 let s:session_id = 0
                            " session_id of last result
    1              0.000001 let s:result_session_id = -1
                            " id of the current pipeline call
    1              0.000001 let s:run_id = 0
                            " run_id of the last result
    1              0.000001 let s:result_run_id = -1
                            " s:draw() was called (used to avoid drawing again when pipeline is sync)
    1              0.000001 let s:draw_done = 0
                            " whether wilder#next() should be called when result is gotten (used by
                            " next_when_available()
    1              0.000001 let s:select_next = 0
                            
                            " current completion (the candidate which was selected)
    1              0.000001 let s:completion = v:null
                            " the cmdline from the previous CmdlineChanged
    1              0.000001 let s:previous_cmdline = v:null
                            " the cmdline replaced when wilder#next() was called (used to reset the
                            " cmdline back to the original one when selected goes back to -1)
    1              0.000001 let s:replaced_cmdline = v:null
                            " the result from the pipeline
    1              0.000002 let s:result = {'value': [], 'data': {}}
                            " the error returned from the pipeline, if any
    1              0.000001 let s:error = v:null
                            " the index of selection (-1 represents no selection)
    1              0.000001 let s:selected = -1
                            " flag to pass to renderer to clear state
    1              0.000001 let s:clear_previous_renderer_state = 0
                            " completion from reject_completion (set so that the new completion won't be
                            " treated as overriding the previous cmdline, which triggers a new pipeline)
    1              0.000001 let s:completion_from_reject_completion = v:null
                            " tracks if wilder#next() has been called (used by noselect == 0)
    1              0.000001 let s:selection_was_made = 0
                            
                            " stack of cmdlines used by accept_completion and reject_completion
    1              0.000001 let s:completion_stack = []
                            
    1   0.000005   0.000003 let s:opts = wilder#options#get()
                            
    1              0.000001 function! wilder#main#in_mode() abort
                              return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0
                            endfunction
                            
    1              0.000001 function! wilder#main#in_context() abort
                              return wilder#main#in_mode() && !s:hidden && s:enabled
                            endfunction
                            
    1              0.000001 function! wilder#main#enable_cmdline_enter() abort
                              if !exists('#WilderCmdlineEnter')
                                augroup WilderCmdlineEnter
                                  autocmd!
                                  autocmd CmdlineEnter * call wilder#main#start()
                                augroup END
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#main#disable_cmdline_enter() abort
                              if exists('#WilderCmdlineEnter')
                                augroup WilderCmdlineEnter
                                  autocmd!
                                augroup END
                                augroup! WilderCmdlineEnter
                              endif
                            endfunction
                            
    1              0.000000 function! wilder#main#start() abort
                              " Workaround for https://github.com/neovim/neovim/issues/15403
                              if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
                                call timer_start(0, {-> s:start()})
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#main#start_from_normal_mode() abort
                              call timer_start(0, {-> s:start()})
                            
                              return ''
                            endfunction
                            
    1              0.000001 function! s:start() abort
                              if !wilder#main#in_mode() || !s:enabled
                                call wilder#main#stop()
                                return
                              endif
                            
                              if !s:init && wilder#options#get('use_python_remote_plugin')
                                let s:init = 1
                            
                                try
                                  if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
                                  endif
                            
                                  call _wilder_init({'num_workers': s:opts.num_workers})
                                catch
                                  echohl ErrorMsg
                                  echomsg 'wilder: Python initialization failed'
                                  echomsg v:exception
                                  echohl Normal
                                endtry
                              endif
                            
                              if s:opts.use_cmdlinechanged
                                if !exists('#WilderCmdlineChanged')
                                  augroup WilderCmdlineChanged
                                    autocmd!
                                    " call from a timer so statusline does not change during mappings
                                    autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
                                  augroup END
                                endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval,
                                        \ {_ -> s:do(1)},
                                        \ {'repeat': -1})
                              endif
                            
                              if !exists('#WilderCmdlineLeave')
                                augroup WilderCmdlineLeave
                                  autocmd!
                                  autocmd CmdlineLeave * call wilder#main#stop()
                                  autocmd CmdwinEnter * call wilder#main#stop()
                                augroup END
                              endif
                            
                              if !exists('#WilderVimResized')
                                augroup WilderVimResized
                                  autocmd!
                                    autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
                                augroup END
                              endif
                            
                              let s:active = 1
                              let s:hidden = 0
                            
                              if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
                              endif
                            
                              if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [
                                      \ wilder#branch(
                                      \   wilder#cmdline_pipeline(),
                                      \   has('nvim') && has('python3')
                                      \     ? wilder#python_search_pipeline()
                                      \     : wilder#vim_search_pipeline(),
                                      \ ),
                                      \ ]
                              endif
                            
                              let s:session_id += 1
                            
                              call s:pre_hook()
                            
                              call s:do(0)
                            endfunction
                            
    1              0.000001 function! wilder#main#stop() abort
                              let s:select_next = 0
                            
                              if !s:active
                                return
                              endif
                            
                              if exists('#WilderCmdlineChanged')
                                augroup WilderCmdlineChanged
                                  autocmd!
                                augroup END
                                augroup! WilderCmdlineChanged
                              endif
                            
                              if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
                              endif
                            
                              if exists('#WilderCmdlineLeave')
                                augroup WilderCmdlineLeave
                                  autocmd!
                                augroup END
                                augroup! WilderCmdlineLeave
                              endif
                            
                              if exists('#WilderVimResized')
                                augroup WilderVimResized
                                  autocmd!
                                augroup END
                                augroup! WilderVimResized
                              endif
                            
                              let s:active = 0
                              let s:result = {'value': [], 'data': {}}
                              let s:selected = -1
                              let s:selection_was_made = 0
                              let s:clear_previous_renderer_state = 0
                              let s:completion_stack = []
                              let s:previous_cmdline = v:null
                              let s:completion = v:null
                              let s:error = v:null
                              let s:replaced_cmdline = v:null
                              let s:completion_from_reject_completion = v:null
                            
                              if !s:hidden
                                call s:post_hook()
                              endif
                            
                              let s:hidden = 0
                            endfunction
                            
    1              0.000001 function! s:pre_hook() abort
                              call wilder#highlight#init_hl()
                            
                              if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
                              endif
                            
                              if has_key(s:opts.renderer, 'pre_hook')
                                call s:opts.renderer.pre_hook({})
                              endif
                            endfunction
                            
    1              0.000001 function! s:post_hook() abort
                              call wilder#pipeline#clear_handlers()
                            
                              if has_key(s:opts.renderer, 'post_hook')
                                call s:opts.renderer.post_hook({})
                              endif
                            
                              if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
                              endif
                            endfunction
                            
    1              0.000001 function! s:do(check) abort
                              if !s:active || !s:enabled
                                return
                              endif
                            
                              if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
                              endif
                            
                              let l:input = s:getcmdline()
                            
                              let l:has_completion = l:input ==# s:completion
                              let l:is_new_input = s:previous_cmdline is v:null
                              let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
                              let l:should_keep_completion = s:completion_from_reject_completion isnot v:null &&
                                    \ s:completion_from_reject_completion ==# l:input
                            
                              if !l:has_completion && !l:should_keep_completion
                                let s:completion = v:null
                                let s:replaced_cmdline = v:null
                                let s:completion_stack = []
                              endif
                            
                              if !l:should_keep_completion
                                let s:completion_from_reject_completion = v:null
                              endif
                            
                              if s:previous_cmdline is v:null || l:input_changed
                                let s:previous_cmdline = l:input
                              endif
                            
                              let s:draw_done = 0
                            
                              if !l:has_completion && (l:input_changed || l:is_new_input)
                                call s:run_pipeline(l:input)
                            
                                if !s:draw_done
                                  call s:draw()
                                endif
                              endif
                            
                              let s:force = 0
                            endfunction
                            
    1              0.000001 function! s:run_pipeline(input, ...) abort
                              let s:run_id += 1
                            
                              let l:ctx = {
                                    \ 'input': a:input,
                                    \ 'run_id': s:run_id,
                                    \ 'session_id': s:session_id,
                                    \ }
                            
                              if a:0 > 0
                                call extend(l:ctx, a:1)
                              endif
                            
                              call wilder#pipeline#run(
                                    \ s:opts.pipeline,
                                    \ function('wilder#main#on_finish'),
                                    \ function('wilder#main#on_error'),
                                    \ l:ctx,
                                    \ a:input,
                                    \ )
                            endfunction
                            
    1              0.000001 function! wilder#main#on_finish(ctx, x) abort
                              if !s:active || !s:enabled
                                return
                              endif
                            
                              if a:ctx.run_id != s:run_id
                                return
                              endif
                            
                              let s:result_run_id = a:ctx.run_id
                              let s:result_session_id = a:ctx.session_id
                            
                              let l:result = (a:x is v:false || a:x is v:true)
                                    \ ? {'value': []}
                                    \ : a:x
                              if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
                              else
                                let s:result = l:result
                              endif
                            
                              if !has_key(s:result, 'data')
                                let s:result.data = {}
                              endif
                            
                              if !has_key(s:result.data, 'query')
                                let s:result.data.query = a:ctx.input
                              endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
                              if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
                              endif
                            
                              let s:selected = -1
                              let s:selection_was_made = 0
                              let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
                              let s:error = v:null
                            
                              if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
                              endif
                            
                              if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
                              endif
                            
                              if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
                              endif
                            
                              if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
                              endif
                            
                              call s:draw()
                            endfunction
                            
    1              0.000001 function! wilder#main#on_error(ctx, x) abort
                              if !s:active || !s:enabled
                                return
                              endif
                            
                              if a:ctx.run_id != s:run_id
                                return
                              endif
                            
                              let s:result_run_id = a:ctx.run_id
                            
                              let s:result = {'value': [], 'data': {}}
                              let s:selected = -1
                              let s:selection_was_made = 0
                              " keep previous completion
                            
                              let s:error = a:x
                            
                              call s:draw()
                            endfunction
                            
    1              0.000000 function! wilder#main#draw() abort
                              if !s:active || !s:enabled
                                return 0
                              endif
                            
                              call s:draw()
                              return 1
                            endfunction
                            
    1              0.000001 function! s:draw_resized() abort
                              if !s:active || !s:enabled
                                return
                              endif
                            
                              call s:draw(0)
                            endfunction
                            
    1              0.000000 function! s:draw(...) abort
                              if s:hidden
                                return
                              endif
                            
                              try
                                  let l:direction = a:0 >= 1 ? a:1 : 0
                            
                                  if s:selected == -1 &&
                                        \ !s:opts.noselect &&
                                        \ !s:selection_was_made &&
                                        \ !empty(s:result.value)
                                    let l:selected = 0
                                  else
                                    let l:selected = s:selected
                                  endif
                            
                                  let l:ctx = {
                                        \ 'clear_previous': get(s:, 'clear_previous_renderer_state', 0),
                                        \ 'selected': l:selected,
                                        \ 'direction': l:direction,
                                        \ 'run_id': s:result_run_id,
                                        \ 'done': s:run_id == s:result_run_id,
                                        \ 'session_id': s:result_session_id,
                                        \ }
                                  let s:clear_previous_renderer_state = 0
                            
                                  let l:has_error = s:error isnot v:null
                            
                                  if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
                                  else
                                    let l:value = s:result
                                  endif
                            
                                  call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
                              finally
                                let s:draw_done = 1
                              endtry
                            endfunction
                            
    1              0.000000 function! wilder#main#next() abort
                              return wilder#main#step(1)
                            endfunction
                            
    1              0.000001 function! wilder#main#next_when_available() abort
                              let s:select_next = 1
                              return ''
                            endfunction
                            
    1              0.000001 function! wilder#main#trigger_change() abort
                              let s:previous_cmdline = v:null
                              let s:completion = v:null
                            
                              call s:do(1)
                              return "\<Insert>\<Insert>"
                            endfunction
                            
    1              0.000000 function! wilder#main#previous() abort
                              return wilder#main#step(-1)
                            endfunction
                            
    1              0.000001 function! wilder#main#step(num_steps) abort
                              if !s:enabled
                                " returning '' seems to prevent async completions from finishing
                                " or prevent redrawing
                                return "\<Insert>\<Insert>"
                              endif
                            
                              if !s:active
                                call s:start()
                                return "\<Insert>\<Insert>"
                              endif
                            
                              if s:hidden
                                return "\<Insert>\<Insert>"
                              endif
                            
                              " If replaced_cmdline is null, this is the first wilder#next() call for the
                              " current result
                              if s:replaced_cmdline is v:null
                                " Original cmdline
                                let s:replaced_cmdline = s:getcmdline()
                              endif
                            
                              let l:previous_selected = s:selected
                            
                              let l:len = len(s:result.value)
                            
                              if s:selected == -1 &&
                                    \ !s:opts.noselect &&
                                    \ !s:selection_was_made
                                let s:selected = 0
                              endif
                            
                              let s:selection_was_made = 1
                            
                              if a:num_steps == 0
                                " pass
                              elseif l:len == 0
                                let s:selected = -1
                              else
                                if s:selected < 0
                                  if a:num_steps > 0
                                    let l:selected = a:num_steps - 1
                                  else
                                    let l:selected = a:num_steps
                                  endif
                            
                                  while l:selected < 0
                                    let l:selected += l:len
                                  endwhile
                                else
                                  let l:selected = s:selected + a:num_steps
                            
                                  while l:selected < -1
                                    let l:selected += l:len
                                  endwhile
                                endif
                            
                                while l:selected > l:len
                                  let l:selected -= l:len
                                endwhile
                            
                                let s:selected = l:selected == l:len ? -1 : l:selected
                              endif
                            
                              if s:selected >= -1
                                if s:selected >= 0
                                  " add the entry to the completion stack if there was no previous selection
                                  if l:previous_selected == -1
                                    call s:push_completion_stack(s:replaced_cmdline)
                                  endif
                            
                                  let l:new_cmdline = s:get_cmdline_from_candidate(s:selected)
                                else
                                  " selected == -1 here
                                  " Go back to original cmdline
                                  let l:new_cmdline = s:replaced_cmdline
                            
                                  " if previous_selected != -1, an entry was added to completion_stack
                                  " remove it here
                                  if l:previous_selected != -1
                                    call s:pop_completion_stack()
                                  endif
                                endif
                            
                                let s:completion = l:new_cmdline
                                call s:feedkeys_cmdline(l:new_cmdline)
                              else
                                " No completion
                                let s:completion = v:null
                            
                                " if previous_selected != -1, an entry was added to completion_stack
                                " remove it here
                                if l:previous_selected != -1
                                  call s:pop_completion_stack()
                                endif
                              endif
                            
                              call s:draw(a:num_steps)
                            
                              return "\<Insert>\<Insert>"
                            endfunction
                            
    1              0.000001 function! wilder#main#get_candidate(ctx, result, index) abort
                              return a:result.value[a:index]
                            endfunction
                            
    1              0.000001 function! s:get_cmdline_from_candidate(index) abort
                              let l:candidate = wilder#main#get_candidate({}, s:result, a:index)
                            
                              let l:output = l:candidate
                            
                              if has_key(s:result, 'output')
                                for l:F in s:result.output
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:output = l:F({}, l:output, s:result.data)
                                endfor
                              endif
                            
                              let l:cmdline = l:output
                              if has_key(s:result, 'replace')
                                for l:F in s:result.replace
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:cmdline = l:F({
                                        \ 'cmdline': s:replaced_cmdline,
                                        \ }, l:cmdline, s:result.data)
                                endfor
                              endif
                            
                              return l:cmdline
                            endfunction
                            
    1              0.000001 function! s:getcmdline(...) abort
                              if s:opts.use_cmdlinechanged || !s:opts.before_cursor
                                return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif
                            endfunction
                            
    1              0.000001 function! s:feedkeys_cmdline(cmdline) abort
                              let l:chars = split(a:cmdline, '\zs')
                            
                              if s:opts.use_cmdlinechanged || !s:opts.before_cursor
                                let l:keys = "\<C-E>\<C-U>"
                              else
                                let l:keys = "\<C-U>"
                              endif
                            
                              for l:char in l:chars
                                " control characters
                                if l:char <# ' '
                                  let l:keys .= "\<C-Q>"
                                endif
                            
                                let l:keys .= l:char
                              endfor
                            
                              call feedkeys(l:keys, 'n')
                            endfunction
                            
    1              0.000001 function! wilder#main#can_accept_completion() abort
                              return wilder#main#in_context() &&
                                    \ (s:selected >= 0 ||
                                    \ (!s:opts.noselect &&
                                    \ s:selected == -1 &&
                                    \ !s:selection_was_made &&
                                    \ !empty(s:result.value)))
                            endfunction
                            
    1              0.000001 function! wilder#main#accept_completion(auto_select) abort
                              " previous_cmdline can be null since feedkeys is not synchronous
                              " this can occur when accept_completion is triggered in quick succession
                              " in this case, ignore the command
                              if s:selected >= 0
                                    \ && s:previous_cmdline isnot v:null
                                let l:cmdline = getcmdline()
                            
                                let s:previous_cmdline = l:cmdline
                            
                                " Reset state as we are running a new pipeline
                                let s:completion = v:null
                                let s:replaced_cmdline = v:null
                                let s:result = {'value': [], 'data': {}}
                                let s:selected = -1
                                let s:selection_was_made = 0
                                let s:clear_previous_renderer_state = 1
                            
                                " add the entry to the completion stack
                                call s:push_completion_stack(l:cmdline)
                            
                                let l:auto_select = s:opts.noselect ? a:auto_select : 0
                                call s:run_pipeline(l:cmdline, {'auto_select': l:auto_select})
                              elseif !s:opts.noselect &&
                                    \ s:selected == -1 &&
                                    \ !s:selection_was_made &&
                                    \ !empty(s:result.value)
                                " simulate wilder#next()
                                " can perhaps be generalised to handle a noinsert == 1 option
                                let l:cmdline = getcmdline()
                            
                                if s:replaced_cmdline is v:null
                                  let s:replaced_cmdline = l:cmdline
                                endif
                            
                                call s:push_completion_stack(l:cmdline)
                            
                                let l:new_cmdline = s:get_cmdline_from_candidate(0)
                            
                                let s:selected = 0
                                let s:completion = l:new_cmdline
                                call s:feedkeys_cmdline(l:new_cmdline)
                              endif
                            
                              return "\<Insert>\<Insert>"
                            endfunction
                            
    1              0.000001 function! wilder#main#can_reject_completion() abort
                              return wilder#main#in_context() && !empty(s:completion_stack)
                            endfunction
                            
    1              0.000001 function! wilder#main#reject_completion() abort
                              if !empty(s:completion_stack)
                                let l:cmdline = s:completion_stack[0]
                                call  s:pop_completion_stack()
                            
                                let s:completion = v:null
                                let s:replaced_cmdline = v:null
                            
                                let s:previous_cmdline = l:cmdline
                                let s:completion_from_reject_completion = l:cmdline
                                let s:result = {'value': [], 'data': {}}
                                let s:selected = -1
                                let s:selection_was_made = 0
                                let s:clear_previous_renderer_state = 1
                            
                                call s:feedkeys_cmdline(l:cmdline)
                                call s:run_pipeline(l:cmdline)
                              endif
                            
                              return "\<Insert>\<Insert>"
                            endfunction
                            
    1              0.000001 function! s:push_completion_stack(cmdline) abort
                              " double-check that the last added entry is not the same value
                              " this can happen when the argument exactly matches the completion
                              if !empty(s:completion_stack) &&
                                    \ s:completion_stack[0] ==# a:cmdline
                                return
                              endif
                            
                              let s:completion_stack = [a:cmdline] + s:completion_stack
                            endfunction
                            
    1              0.000001 function! s:pop_completion_stack() abort
                              let s:completion_stack = s:completion_stack[1:]
                            endfunction
                            
    1              0.000001 function! wilder#main#enable() abort
                              let s:enabled = 1
                            
                              return ''
                            endfunction
                            
    1              0.000001 function! wilder#main#disable() abort
                              let s:enabled = 0
                            
                              call wilder#main#stop()
                            
                              return ''
                            endfunction
                            
    1              0.000000 function! wilder#main#toggle() abort
                              if s:enabled
                                return wilder#main#disable()
                              endif
                            
                              return wilder#main#enable()
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider.vim
Sourced 1 time
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
                            " Common functions for providers
                            
                            " Start the provider and perform a 'poll' request
                            "
                            " Returns a valid channel on success
    1              0.000003 function! provider#Poll(argv, orig_name, log_env, ...) abort
                              let job = {'rpc': v:true, 'stderr_buffered': v:true}
                              if a:0
                                let job = extend(job, a:1)
                              endif
                              try
                                let channel_id = jobstart(a:argv, job)
                                if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
                                  return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000003 function! wilder#renderer#redraw(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 0)
                            endfunction
                            
    1              0.000002 function! wilder#renderer#redrawstatus(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 1)
                            endfunction
                            
    1              0.000001 function! s:redraw(apply_incsearch_fix, is_redrawstatus) abort
                              if a:apply_incsearch_fix &&
                                    \ &incsearch &&
                                    \ (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
                              endif
                            
                              if a:is_redrawstatus
                                redrawstatus
                              else
                                redraw
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#get_cmdheight() abort
                              if !has('nvim')
                                " For Vim, if cmdline exceeds cmdheight, the screen lines are pushed up
                                " similar to :mess, so we draw the popupmenu just above the cmdline.
                                " Lines exceeding cmdheight do not count into target line number.
                                return &cmdheight
                              endif
                            
                              let l:cmdline = getcmdline()
                            
                              " include the cmdline character
                              let l:display_width = strdisplaywidth(l:cmdline) + 1
                              let l:cmdheight = l:display_width / &columns + 1
                            
                              if l:cmdheight < &cmdheight
                                let l:cmdheight = &cmdheight
                              elseif l:cmdheight > 1
                                " Show the pum above the msgsep.
                                let l:has_msgsep = stridx(&display, 'msgsep') >= 0
                            
                                if l:has_msgsep
                                  let l:cmdheight += 1
                                endif
                              endif
                            
                              return l:cmdheight
                            endfunction
                            
    1              0.000001 function! wilder#renderer#pre_draw(components, ctx, result) abort
                              let l:should_draw = 0
                            
                              for l:Component in a:components
                                let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
                              endfor
                            
                              return l:should_draw
                            endfunction
                            
    1              0.000001 function! s:pre_draw(component, ctx, result) abort
                              if type(a:component) isnot v:t_dict
                                return a:ctx.done
                              endif
                            
                              if has_key(a:component, 'pre_draw')
                                return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_pre_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'pre_hook')
                                call a:component['pre_hook'](a:ctx)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_post_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'post_hook')
                                call a:component['post_hook'](a:ctx)
                              endif
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim
Sourced 1 time
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
    1              0.000002 let s:handler_registry = {}
    1              0.000001 let s:partial_results = {}
    1              0.000001 let s:id_index = 0
    1              0.000001 let s:last_cleared_id = -1
                            
    1              0.000001 function! wilder#pipeline#clear_handlers() abort
                              let s:last_cleared_id = s:id_index
                              let s:handler_registry = {}
                              let s:partial_results = {}
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#resolve(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'resolve')
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#reject(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'reject')
                            endfunction
                            
    1              0.000001 function! s:partial_error_message(key, x)
                              let l:message = 'wilder#' . a:key . '()'
                              let l:message .= ' ''partial'' only supported for lists: ' . string(a:x)
                            
                              return l:message
                            endfunction
                            
    1              0.000001 function! s:handle(ctx, x, key) abort
                              let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
                              if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
                              endif
                            
                              let l:X = a:x
                              let l:handler = s:handler_registry[l:handler_id]
                            
                              if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
                              endif
                            
                              unlet s:handler_registry[l:handler_id]
                            
                              if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
                              endif
                            
                              if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
                              endif
                            
                              try
                                call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#run(pipeline, on_finish, on_error, ctx, x) abort
                              let l:pipeline = type(a:pipeline) isnot v:t_list
                                    \ ? [a:pipeline]
                                    \ : a:pipeline
                            
                              return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)
                            endfunction
                            
    1              0.000001 function! s:call(f, ctx, handler_id) abort
                              let a:ctx.handler_id = a:handler_id
                            
                              try
                                call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:prepare_call(f, pipeline, on_finish, on_error, ctx, i)
                              let l:handler = {
                                    \ 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)},
                                    \ 'on_error': {ctx, x -> a:on_error(ctx, x)},
                                    \ }
                            
                              let s:id_index += 1
                              let l:handler_id = s:id_index
                              let s:handler_registry[s:id_index] = l:handler
                            
                              call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})
                            endfunction
                            
    1              0.000001 function! s:run(pipeline, on_finish, on_error, ctx, x, i) abort
                              if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
                              endif
                            
                              if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
                              endif
                            
                              let l:x = a:x
                              let l:i = a:i
                            
                              while l:i < len(a:pipeline)
                                let l:F = a:pipeline[l:i]
                            
                                if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
                                endif
                            
                                try
                                  let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
                                endtry
                            
                                if l:Result is v:false || l:Result is v:true
                                  call a:on_finish(a:ctx, l:Result)
                                  return
                                endif
                            
                                if type(l:Result) is v:t_func
                                  let l:ctx = copy(a:ctx)
                                  call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
                                  return
                                endif
                            
                                let l:x = l:Result
                                let l:i += 1
                              endwhile
                            
                              call a:on_finish(a:ctx, l:x)
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#wait(f, on_finish) abort
                              let l:state = {
                                    \ 'f': a:f,
                                    \ 'on_finish': a:on_finish,
                                    \ }
                            
                              return {ctx -> s:wait_start(l:state, ctx)}
                            endfunction
                            
    1              0.000001 function! s:wait_start(state, ctx)
                              let a:state.wait_handler_id = a:ctx.handler_id
                            
                              let a:state.handler = {
                                    \ 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)},
                                    \ 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)},
                                    \ }
                            
                              call s:wait_call(a:state, a:ctx)
                            endfunction
                            
    1              0.000001 function! s:wait_call(state, ctx)
                              try
                                if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
                                else
                                  let a:ctx.handler_id = a:state.wait_handler_id
                                  call a:state.on_finish(a:ctx, a:state.f)
                                endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_finish(state, ctx, x)
                              if type(a:x) is v:t_func
                                let a:state.f = a:x
                                call s:wait_call(a:state, a:ctx)
                                return
                              endif
                            
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              try
                                call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_error(state, ctx, x)
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction
                            
    1              0.000001 function! s:echoerr(message)
                              " avoid echoerr since this in a try-catch block
                              " see try-echoerr
                              echohl ErrorMsg
                              echomsg a:message
                              echohl Normal
                            endfunction

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim
Sourced 1 time
Total time:   0.003717
 Self time:   0.003717

count  total (s)   self (s)
    1              0.000054 let s:command_modifiers = {
                                  \ 'aboveleft': 1,
                                  \ 'argdo': 1,
                                  \ 'belowright': 1,
                                  \ 'botright': 1,
                                  \ 'browse': 1,
                                  \ 'bufdo': 1,
                                  \ 'cdo': 1,
                                  \ 'cfdo': 1,
                                  \ 'confirm': 1,
                                  \ 'debug': 1,
                                  \ 'folddoclosed': 1,
                                  \ 'folddoopen': 1,
                                  \ 'hide': 1,
                                  \ 'keepalt': 1,
                                  \ 'keepjumps': 1,
                                  \ 'keepmarks': 1,
                                  \ 'keeppatterns': 1,
                                  \ 'ldo': 1,
                                  \ 'leftabove': 1,
                                  \ 'lfdo': 1,
                                  \ 'lockmarks': 1,
                                  \ 'noautocmd': 1,
                                  \ 'noswapfile': 1,
                                  \ 'rightbelow': 1,
                                  \ 'sandbox': 1,
                                  \ 'silent': 1,
                                  \ 'tab': 1,
                                  \ 'tabdo': 1,
                                  \ 'topleft': 1,
                                  \ 'verbose': 1,
                                  \ 'vertical': 1,
                                  \ 'windo': 1,
                                  \ }
                            
    1              0.000008 function! wilder#cmdline#main#do(ctx) abort
                              " default
                              let a:ctx.expand = 'command'
                              let a:ctx.force = 0
                            
                              if empty(a:ctx.cmdline[a:ctx.pos :])
                                return
                              endif
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              " check if comment
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " skip range
                              call wilder#cmdline#skip_range#do(a:ctx)
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " check if starts with | or :
                              " treat as a new command
                              if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              let l:is_user_cmd = 0
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
                              else
                                let l:cmd_start = a:ctx.pos
                            
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' ||
                                        \ l:char >=# 'A' && l:char <=# 'Z' ||
                                        \ l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
                                else
                                  " non-alphabet command
                                  if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
                                    if a:ctx.cmdline[a:ctx.pos] ==# 'p' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
                                    while l:char >=# 'a' && l:char <=# 'z' ||
                                          \ l:char >=# 'A' && l:char <=# 'Z' ||
                                          \ l:char ==# '*'
                                      let a:ctx.pos += 1
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endwhile
                                  endif
                            
                                  if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
                                  endif
                            
                                  " find the command
                                  if a:ctx.pos > l:cmd_start
                                    let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                    let l:len = a:ctx.pos - l:cmd_start
                            
                                    let l:char = l:cmd[0]
                                    if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
                                    endif
                            
                                    let l:next_char = nr2char(char2nr(l:char) + 1)
                            
                                    let l:i = s:command_char_pos[l:char]
                                    let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
                                    while l:i < l:end
                                      let l:command = s:commands[l:i]
                                      if l:cmd ==# l:command[: l:len - 1]
                                        let a:ctx.cmd = l:command
                                        break
                                      endif
                            
                                      let l:i += 1
                                    endwhile
                                  endif
                                endif
                              endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
                              if a:ctx.pos == len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
                                if l:char >=# 'a' && l:char <=# 'z' ||
                                      \ l:char >=# 'A' && l:char <=# 'Z' ||
                                      \ l:char >=# '0' && l:char <=# '9'
                                  let a:ctx.pos = l:cmd_start
                                  let a:ctx.cmd = ''
                                  " expand commands
                                  return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' &&
                                      \ stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                    \ ((and(l:flags, s:EDITCMD) && !l:use_filter) ||
                                    \ and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                      \ a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                        \ && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' &&
                                      \ a:ctx.cmdline[a:ctx.pos] ==# '@' &&
                                      \ a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' ||
                                          \ l:allow_backslash && l:char ==# '\' ||
                                          \ !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) &&
                                        \ a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' ||
                                    \ a:ctx.cmd ==# 'sfind' ||
                                    \ a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' ||
                                    \ a:ctx.cmd ==# 'chdir' ||
                                    \ a:ctx.cmd ==# 'lcd' ||
                                    \ a:ctx.cmd ==# 'lchdir' ||
                                    \ a:ctx.cmd ==# 'tcd' ||
                                    \ a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' ||
                                    \ a:ctx.cmd ==# 'dsearch' ||
                                    \ a:ctx.cmd ==# 'ilist' ||
                                    \ a:ctx.cmd ==# 'dlist' ||
                                    \ a:ctx.cmd ==# 'ijump' ||
                                    \ a:ctx.cmd ==# 'psearch' ||
                                    \ a:ctx.cmd ==# 'djump' ||
                                    \ a:ctx.cmd ==# 'isplit' ||
                                    \ a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' ||
                                    \ a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' ||
                                    \ a:ctx.cmd ==# 'setglobal' ||
                                    \ a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' ||
                                    \ a:ctx.cmd ==# 'stag' ||
                                    \ a:ctx.cmd ==# 'ptag' ||
                                    \ a:ctx.cmd ==# 'ltag' ||
                                    \ a:ctx.cmd ==# 'tselect' ||
                                    \ a:ctx.cmd ==# 'stselect' ||
                                    \ a:ctx.cmd ==# 'tjump' ||
                                    \ a:ctx.cmd ==# 'stjump' ||
                                    \ a:ctx.cmd ==# 'ptselect' ||
                                    \ a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' ||
                                    \ a:ctx.cmd ==# 'if' ||
                                    \ a:ctx.cmd ==# 'elseif' ||
                                    \ a:ctx.cmd ==# 'while' ||
                                    \ a:ctx.cmd ==# 'for' ||
                                    \ a:ctx.cmd ==# 'echo' ||
                                    \ a:ctx.cmd ==# 'echon' ||
                                    \ a:ctx.cmd ==# 'execute' ||
                                    \ a:ctx.cmd ==# 'echomsg' ||
                                    \ a:ctx.cmd ==# 'echoerr' ||
                                    \ a:ctx.cmd ==# 'call' ||
                                    \ a:ctx.cmd ==# 'return' ||
                                    \ a:ctx.cmd ==# 'cexpr' ||
                                    \ a:ctx.cmd ==# 'caddexpr' ||
                                    \ a:ctx.cmd ==# 'cgetexpr' ||
                                    \ a:ctx.cmd ==# 'lexpr' ||
                                    \ a:ctx.cmd ==# 'laddexpr' ||
                                    \ a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' ||
                                    \ a:ctx.cmd ==# 'lcscope' ||
                                    \ a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' ||
                                    \ a:ctx.cmd ==# 'bwipeout' ||
                                    \ a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' ||
                                    \ a:ctx.cmd ==# 'sbuffer' ||
                                    \ a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' ||
                                    \ a:ctx.cmd ==# 'unabbreviate' ||
                                    \ a:ctx.cmd[-3 :] ==# 'map' ||
                                    \ a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' ||
                                        \ l:subcommand ==# 'ctype' ||
                                        \ l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif
                            endfunction
                            
    1              0.000004 function! wilder#cmdline#main#has_file_args(cmd) abort
                              let l:flags = get(s:command_flags, a:cmd, 0)
                              return and(l:flags, s:XFILE)
                            endfunction
                            
    1              0.000003 function! wilder#cmdline#main#is_whitespace(char) abort
                              let l:nr = char2nr(a:char)
                              return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13
                            endfunction
                            
    1              0.000003 function! wilder#cmdline#main#skip_whitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000003 function! wilder#cmdline#main#skip_nonwhitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000004 function! wilder#cmdline#main#find_last_whitespace(ctx) abort
                              let l:arg_start = a:ctx.pos
                              let a:ctx.pos = len(a:ctx.cmdline) - 1
                              while a:ctx.pos >= l:arg_start
                                if wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                  let l:arg_start = a:ctx.pos + 1
                            
                                  break
                                endif
                                let a:ctx.pos -= 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:move_pos_to_last_arg(ctx) abort
                              let l:last_arg = a:ctx.pos
                            
                              " find start of last argument
                              while a:ctx.pos < len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char ==# ' ' || l:char ==# "\t"
                                  let a:ctx.pos += 1
                                  let l:last_arg = a:ctx.pos
                                else
                                  if l:char ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                    let a:ctx.pos += 1
                                  endif
                                  let a:ctx.pos += 1
                                endif
                              endwhile
                            
                              let a:ctx.pos = l:last_arg
                            endfunction
                            
    1              0.000002 function! s:is_filec(c) abort
                              return match(a:c, '\f') != -1
                            endfunction
                            
    1              0.000002 function! s:path_has_wildcard(c) abort
                              if has('win32') || has('win64')
                                let l:wildcards = '?*$[`'
                              else
                                let l:wildcards = "*?[{`'$"
                              endif
                            
                              return stridx(l:wildcards, a:c) != -1
                            endfunction
                            
    1              0.000002 function! s:isfilec_or_wc(c) abort
                              return s:is_filec(a:c) || a:c ==# ']' || s:path_has_wildcard(a:c)
                            endfunction
                            
    1              0.000002 function! s:is_idc(c) abort
                              return match(a:c, '\i') != -1
                            endfunction
                            
    1              0.000002 function! s:or(...) abort
                              let l:result = 0
                            
                              for l:arg in a:000
                                let l:result = or(l:result, l:arg)
                              endfor
                            
                              return l:result
                            endfunc
                            
    1              0.000005 let s:EXTRA      =    0x004
    1              0.000002 let s:XFILE      =    0x008
    1              0.000002 let s:NOSPC      =    0x010
    1              0.000002 let s:TRLBAR     =    0x100
    1              0.000002 let s:EDITCMD    =   0x8000
    1              0.000002 let s:ARGOPT     =  0x40000
                            
    1              0.000027 let s:command_char_pos = {
                                  \ 'a': 0,
                                  \ 'b': 19,
                                  \ 'c': 42,
                                  \ 'd': 104,
                                  \ 'e': 126,
                                  \ 'f': 146,
                                  \ 'g': 161,
                                  \ 'h': 167,
                                  \ 'i': 175,
                                  \ 'j': 193,
                                  \ 'k': 195,
                                  \ 'l': 200,
                                  \ 'm': 258,
                                  \ 'n': 276,
                                  \ 'o': 296,
                                  \ 'p': 307,
                                  \ 'q': 342,
                                  \ 'r': 345,
                                  \ 's': 365,
                                  \ 't': 430,
                                  \ 'u': 471,
                                  \ 'v': 482,
                                  \ 'w': 500,
                                  \ 'x': 516,
                                  \ 'y': 525,
                                  \ 'z': 526,
                                  \ '{': 527,
                                  \ }
                            
    1              0.000716 let s:commands = [
                                  \ 'append',
                                  \ 'abbreviate',
                                  \ 'abclear',
                                  \ 'aboveleft',
                                  \ 'all',
                                  \ 'amenu',
                                  \ 'anoremenu',
                                  \ 'args',
                                  \ 'argadd',
                                  \ 'argdelete',
                                  \ 'argdo',
                                  \ 'argedit',
                                  \ 'argglobal',
                                  \ 'arglocal',
                                  \ 'argument',
                                  \ 'ascii',
                                  \ 'autocmd',
                                  \ 'augroup',
                                  \ 'aunmenu',
                                  \ 'buffer',
                                  \ 'bNext',
                                  \ 'ball',
                                  \ 'badd',
                                  \ 'bdelete',
                                  \ 'behave',
                                  \ 'belowright',
                                  \ 'bfirst',
                                  \ 'blast',
                                  \ 'bmodified',
                                  \ 'bnext',
                                  \ 'botright',
                                  \ 'bprevious',
                                  \ 'brewind',
                                  \ 'break',
                                  \ 'breakadd',
                                  \ 'breakdel',
                                  \ 'breaklist',
                                  \ 'browse',
                                  \ 'buffers',
                                  \ 'bufdo',
                                  \ 'bunload',
                                  \ 'bwipeout',
                                  \ 'change',
                                  \ 'cNext',
                                  \ 'cNfile',
                                  \ 'cabbrev',
                                  \ 'cabclear',
                                  \ 'caddbuffer',
                                  \ 'caddexpr',
                                  \ 'caddfile',
                                  \ 'call',
                                  \ 'catch',
                                  \ 'cbuffer',
                                  \ 'cbottom',
                                  \ 'cc',
                                  \ 'cclose',
                                  \ 'cd',
                                  \ 'cdo',
                                  \ 'center',
                                  \ 'cexpr',
                                  \ 'cfile',
                                  \ 'cfdo',
                                  \ 'cfirst',
                                  \ 'cgetfile',
                                  \ 'cgetbuffer',
                                  \ 'cgetexpr',
                                  \ 'chdir',
                                  \ 'changes',
                                  \ 'checkhealth',
                                  \ 'checkpath',
                                  \ 'checktime',
                                  \ 'chistory',
                                  \ 'clist',
                                  \ 'clast',
                                  \ 'close',
                                  \ 'clearjumps',
                                  \ 'cmap',
                                  \ 'cmapclear',
                                  \ 'cmenu',
                                  \ 'cnext',
                                  \ 'cnewer',
                                  \ 'cnfile',
                                  \ 'cnoremap',
                                  \ 'cnoreabbrev',
                                  \ 'cnoremenu',
                                  \ 'copy',
                                  \ 'colder',
                                  \ 'colorscheme',
                                  \ 'command',
                                  \ 'comclear',
                                  \ 'compiler',
                                  \ 'continue',
                                  \ 'confirm',
                                  \ 'copen',
                                  \ 'cprevious',
                                  \ 'cpfile',
                                  \ 'cquit',
                                  \ 'crewind',
                                  \ 'cscope',
                                  \ 'cstag',
                                  \ 'cunmap',
                                  \ 'cunabbrev',
                                  \ 'cunmenu',
                                  \ 'cwindow',
                                  \ 'delete',
                                  \ 'delmarks',
                                  \ 'debug',
                                  \ 'debuggreedy',
                                  \ 'delcommand',
                                  \ 'delfunction',
                                  \ 'display',
                                  \ 'diffupdate',
                                  \ 'diffget',
                                  \ 'diffoff',
                                  \ 'diffpatch',
                                  \ 'diffput',
                                  \ 'diffsplit',
                                  \ 'diffthis',
                                  \ 'digraphs',
                                  \ 'djump',
                                  \ 'dlist',
                                  \ 'doautocmd',
                                  \ 'doautoall',
                                  \ 'drop',
                                  \ 'dsearch',
                                  \ 'dsplit',
                                  \ 'edit',
                                  \ 'earlier',
                                  \ 'echo',
                                  \ 'echoerr',
                                  \ 'echohl',
                                  \ 'echomsg',
                                  \ 'echon',
                                  \ 'else',
                                  \ 'elseif',
                                  \ 'emenu',
                                  \ 'endif',
                                  \ 'endfunction',
                                  \ 'endfor',
                                  \ 'endtry',
                                  \ 'endwhile',
                                  \ 'enew',
                                  \ 'ex',
                                  \ 'execute',
                                  \ 'exit',
                                  \ 'exusage',
                                  \ 'file',
                                  \ 'files',
                                  \ 'filetype',
                                  \ 'filter',
                                  \ 'find',
                                  \ 'finally',
                                  \ 'finish',
                                  \ 'first',
                                  \ 'fold',
                                  \ 'foldclose',
                                  \ 'folddoopen',
                                  \ 'folddoclosed',
                                  \ 'foldopen',
                                  \ 'for',
                                  \ 'function',
                                  \ 'global',
                                  \ 'goto',
                                  \ 'grep',
                                  \ 'grepadd',
                                  \ 'gui',
                                  \ 'gvim',
                                  \ 'help',
                                  \ 'helpclose',
                                  \ 'helpgrep',
                                  \ 'helptags',
                                  \ 'hardcopy',
                                  \ 'highlight',
                                  \ 'hide',
                                  \ 'history',
                                  \ 'insert',
                                  \ 'iabbrev',
                                  \ 'iabclear',
                                  \ 'if',
                                  \ 'ijump',
                                  \ 'ilist',
                                  \ 'imap',
                                  \ 'imapclear',
                                  \ 'imenu',
                                  \ 'inoremap',
                                  \ 'inoreabbrev',
                                  \ 'inoremenu',
                                  \ 'intro',
                                  \ 'isearch',
                                  \ 'isplit',
                                  \ 'iunmap',
                                  \ 'iunabbrev',
                                  \ 'iunmenu',
                                  \ 'join',
                                  \ 'jumps',
                                  \ 'k',
                                  \ 'keepmarks',
                                  \ 'keepjumps',
                                  \ 'keeppatterns',
                                  \ 'keepalt',
                                  \ 'list',
                                  \ 'lNext',
                                  \ 'lNfile',
                                  \ 'last',
                                  \ 'language',
                                  \ 'laddexpr',
                                  \ 'laddbuffer',
                                  \ 'laddfile',
                                  \ 'later',
                                  \ 'lbuffer',
                                  \ 'lbottom',
                                  \ 'lcd',
                                  \ 'lchdir',
                                  \ 'lclose',
                                  \ 'lcscope',
                                  \ 'ldo',
                                  \ 'left',
                                  \ 'leftabove',
                                  \ 'let',
                                  \ 'lexpr',
                                  \ 'lfile',
                                  \ 'lfdo',
                                  \ 'lfirst',
                                  \ 'lgetfile',
                                  \ 'lgetbuffer',
                                  \ 'lgetexpr',
                                  \ 'lgrep',
                                  \ 'lgrepadd',
                                  \ 'lhelpgrep',
                                  \ 'lhistory',
                                  \ 'll',
                                  \ 'llast',
                                  \ 'llist',
                                  \ 'lmap',
                                  \ 'lmapclear',
                                  \ 'lmake',
                                  \ 'lnoremap',
                                  \ 'lnext',
                                  \ 'lnewer',
                                  \ 'lnfile',
                                  \ 'loadview',
                                  \ 'loadkeymap',
                                  \ 'lockmarks',
                                  \ 'lockvar',
                                  \ 'lolder',
                                  \ 'lopen',
                                  \ 'lprevious',
                                  \ 'lpfile',
                                  \ 'lrewind',
                                  \ 'ltag',
                                  \ 'lunmap',
                                  \ 'lua',
                                  \ 'luado',
                                  \ 'luafile',
                                  \ 'lvimgrep',
                                  \ 'lvimgrepadd',
                                  \ 'lwindow',
                                  \ 'ls',
                                  \ 'move',
                                  \ 'mark',
                                  \ 'make',
                                  \ 'map',
                                  \ 'mapclear',
                                  \ 'marks',
                                  \ 'match',
                                  \ 'menu',
                                  \ 'menutranslate',
                                  \ 'messages',
                                  \ 'mkexrc',
                                  \ 'mksession',
                                  \ 'mkspell',
                                  \ 'mkvimrc',
                                  \ 'mkview',
                                  \ 'mode',
                                  \ 'mzscheme',
                                  \ 'mzfile',
                                  \ 'next',
                                  \ 'nbkey',
                                  \ 'nbclose',
                                  \ 'nbstart',
                                  \ 'new',
                                  \ 'nmap',
                                  \ 'nmapclear',
                                  \ 'nmenu',
                                  \ 'nnoremap',
                                  \ 'nnoremenu',
                                  \ 'noremap',
                                  \ 'noautocmd',
                                  \ 'nohlsearch',
                                  \ 'noreabbrev',
                                  \ 'noremenu',
                                  \ 'noswapfile',
                                  \ 'normal',
                                  \ 'number',
                                  \ 'nunmap',
                                  \ 'nunmenu',
                                  \ 'oldfiles',
                                  \ 'omap',
                                  \ 'omapclear',
                                  \ 'omenu',
                                  \ 'only',
                                  \ 'onoremap',
                                  \ 'onoremenu',
                                  \ 'options',
                                  \ 'ounmap',
                                  \ 'ounmenu',
                                  \ 'ownsyntax',
                                  \ 'print',
                                  \ 'packadd',
                                  \ 'packloadall',
                                  \ 'pclose',
                                  \ 'perl',
                                  \ 'perldo',
                                  \ 'pedit',
                                  \ 'pop',
                                  \ 'popup',
                                  \ 'ppop',
                                  \ 'preserve',
                                  \ 'previous',
                                  \ 'promptfind',
                                  \ 'promptrepl',
                                  \ 'profile',
                                  \ 'profdel',
                                  \ 'psearch',
                                  \ 'ptag',
                                  \ 'ptNext',
                                  \ 'ptfirst',
                                  \ 'ptjump',
                                  \ 'ptlast',
                                  \ 'ptnext',
                                  \ 'ptprevious',
                                  \ 'ptrewind',
                                  \ 'ptselect',
                                  \ 'put',
                                  \ 'pwd',
                                  \ 'python',
                                  \ 'pydo',
                                  \ 'pyfile',
                                  \ 'py3',
                                  \ 'py3do',
                                  \ 'python3',
                                  \ 'py3file',
                                  \ 'quit',
                                  \ 'quitall',
                                  \ 'qall',
                                  \ 'read',
                                  \ 'recover',
                                  \ 'redo',
                                  \ 'redir',
                                  \ 'redraw',
                                  \ 'redrawstatus',
                                  \ 'registers',
                                  \ 'resize',
                                  \ 'retab',
                                  \ 'return',
                                  \ 'rewind',
                                  \ 'right',
                                  \ 'rightbelow',
                                  \ 'rshada',
                                  \ 'runtime',
                                  \ 'rundo',
                                  \ 'ruby',
                                  \ 'rubydo',
                                  \ 'rubyfile',
                                  \ 'rviminfo',
                                  \ 'substitute',
                                  \ 'sNext',
                                  \ 'sargument',
                                  \ 'sall',
                                  \ 'sandbox',
                                  \ 'saveas',
                                  \ 'sbuffer',
                                  \ 'sbNext',
                                  \ 'sball',
                                  \ 'sbfirst',
                                  \ 'sblast',
                                  \ 'sbmodified',
                                  \ 'sbnext',
                                  \ 'sbprevious',
                                  \ 'sbrewind',
                                  \ 'scriptnames',
                                  \ 'scriptencoding',
                                  \ 'scscope',
                                  \ 'set',
                                  \ 'setfiletype',
                                  \ 'setglobal',
                                  \ 'setlocal',
                                  \ 'sfind',
                                  \ 'sfirst',
                                  \ 'simalt',
                                  \ 'sign',
                                  \ 'silent',
                                  \ 'sleep',
                                  \ 'slast',
                                  \ 'smagic',
                                  \ 'smap',
                                  \ 'smapclear',
                                  \ 'smenu',
                                  \ 'snext',
                                  \ 'snomagic',
                                  \ 'snoremap',
                                  \ 'snoremenu',
                                  \ 'source',
                                  \ 'sort',
                                  \ 'split',
                                  \ 'spellgood',
                                  \ 'spelldump',
                                  \ 'spellinfo',
                                  \ 'spellrepall',
                                  \ 'spellundo',
                                  \ 'spellwrong',
                                  \ 'sprevious',
                                  \ 'srewind',
                                  \ 'stop',
                                  \ 'stag',
                                  \ 'startinsert',
                                  \ 'startgreplace',
                                  \ 'startreplace',
                                  \ 'stopinsert',
                                  \ 'stjump',
                                  \ 'stselect',
                                  \ 'sunhide',
                                  \ 'sunmap',
                                  \ 'sunmenu',
                                  \ 'suspend',
                                  \ 'sview',
                                  \ 'swapname',
                                  \ 'syntax',
                                  \ 'syntime',
                                  \ 'syncbind',
                                  \ 't',
                                  \ 'tcd',
                                  \ 'tchdir',
                                  \ 'tNext',
                                  \ 'tag',
                                  \ 'tags',
                                  \ 'tab',
                                  \ 'tabclose',
                                  \ 'tabdo',
                                  \ 'tabedit',
                                  \ 'tabfind',
                                  \ 'tabfirst',
                                  \ 'tabmove',
                                  \ 'tablast',
                                  \ 'tabnext',
                                  \ 'tabnew',
                                  \ 'tabonly',
                                  \ 'tabprevious',
                                  \ 'tabNext',
                                  \ 'tabrewind',
                                  \ 'tabs',
                                  \ 'tcl',
                                  \ 'tcldo',
                                  \ 'tclfile',
                                  \ 'terminal',
                                  \ 'tfirst',
                                  \ 'throw',
                                  \ 'tjump',
                                  \ 'tlast',
                                  \ 'tmap',
                                  \ 'tmapclear',
                                  \ 'tmenu',
                                  \ 'tnext',
                                  \ 'tnoremap',
                                  \ 'topleft',
                                  \ 'tprevious',
                                  \ 'trewind',
                                  \ 'try',
                                  \ 'tselect',
                                  \ 'tunmap',
                                  \ 'tunmenu',
                                  \ 'undo',
                                  \ 'undojoin',
                                  \ 'undolist',
                                  \ 'unabbreviate',
                                  \ 'unhide',
                                  \ 'unlet',
                                  \ 'unlockvar',
                                  \ 'unmap',
                                  \ 'unmenu',
                                  \ 'unsilent',
                                  \ 'update',
                                  \ 'vglobal',
                                  \ 'version',
                                  \ 'verbose',
                                  \ 'vertical',
                                  \ 'visual',
                                  \ 'view',
                                  \ 'vimgrep',
                                  \ 'vimgrepadd',
                                  \ 'viusage',
                                  \ 'vmap',
                                  \ 'vmapclear',
                                  \ 'vmenu',
                                  \ 'vnoremap',
                                  \ 'vnew',
                                  \ 'vnoremenu',
                                  \ 'vsplit',
                                  \ 'vunmap',
                                  \ 'vunmenu',
                                  \ 'write',
                                  \ 'wNext',
                                  \ 'wall',
                                  \ 'while',
                                  \ 'winsize',
                                  \ 'wincmd',
                                  \ 'windo',
                                  \ 'winpos',
                                  \ 'wnext',
                                  \ 'wprevious',
                                  \ 'wq',
                                  \ 'wqall',
                                  \ 'wsverb',
                                  \ 'wshada',
                                  \ 'wundo',
                                  \ 'wviminfo',
                                  \ 'xit',
                                  \ 'xall',
                                  \ 'xmap',
                                  \ 'xmapclear',
                                  \ 'xmenu',
                                  \ 'xnoremap',
                                  \ 'xnoremenu',
                                  \ 'xunmap',
                                  \ 'xunmenu',
                                  \ 'yank',
                                  \ 'z',
                                  \ '!',
                                  \ '#',
                                  \ '&',
                                  \ '<',
                                  \ ':',
                                  \ '>',
                                  \ '@',
                                  \ 'Next',
                                  \ '~',
                                  \ ]
                            
    1              0.001409 let s:command_flags = {
                                  \ 'append': 3150083,
                                  \ 'abbreviate': 1059076,
                                  \ 'abclear': 1048836,
                                  \ 'aboveleft': 2180,
                                  \ 'all': 17667,
                                  \ 'amenu': 1079557,
                                  \ 'anoremenu': 1079557,
                                  \ 'args': 295182,
                                  \ 'argadd': 20751,
                                  \ 'argdelete': 16655,
                                  \ 'argdo': 18599,
                                  \ 'argedit': 315791,
                                  \ 'argglobal': 295182,
                                  \ 'arglocal': 295182,
                                  \ 'argument': 312583,
                                  \ 'ascii': 1573120,
                                  \ 'autocmd': 1058822,
                                  \ 'augroup': 1048854,
                                  \ 'aunmenu': 1059076,
                                  \ 'buffer': 247047,
                                  \ 'bNext': 50435,
                                  \ 'ball': 17665,
                                  \ 'badd': 1081756,
                                  \ 'bdelete': 83207,
                                  \ 'behave': 1048980,
                                  \ 'belowright': 2180,
                                  \ 'bfirst': 49411,
                                  \ 'blast': 49411,
                                  \ 'bmodified': 50435,
                                  \ 'bnext': 50435,
                                  \ 'botright': 2180,
                                  \ 'bprevious': 50435,
                                  \ 'brewind': 49411,
                                  \ 'break': 1573120,
                                  \ 'breakadd': 1048836,
                                  \ 'breakdel': 1048836,
                                  \ 'breaklist': 1048836,
                                  \ 'browse': 1050756,
                                  \ 'buffers': 1048838,
                                  \ 'bufdo': 18599,
                                  \ 'bunload': 83207,
                                  \ 'bwipeout': 214279,
                                  \ 'change': 3147075,
                                  \ 'cNext': 17667,
                                  \ 'cNfile': 17667,
                                  \ 'cabbrev': 1059076,
                                  \ 'cabclear': 1048836,
                                  \ 'caddbuffer': 16661,
                                  \ 'caddexpr': 2452,
                                  \ 'caddfile': 284,
                                  \ 'call': 1575045,
                                  \ 'catch': 1572868,
                                  \ 'cbuffer': 16663,
                                  \ 'cbottom': 256,
                                  \ 'cc': 17667,
                                  \ 'cclose': 17665,
                                  \ 'cd': 1048862,
                                  \ 'cdo': 18599,
                                  \ 'center': 3146053,
                                  \ 'cexpr': 2454,
                                  \ 'cfile': 286,
                                  \ 'cfdo': 18599,
                                  \ 'cfirst': 17667,
                                  \ 'cgetfile': 284,
                                  \ 'cgetbuffer': 16661,
                                  \ 'cgetexpr': 2452,
                                  \ 'chdir': 1048862,
                                  \ 'changes': 1048832,
                                  \ 'checkhealth': 260,
                                  \ 'checkpath': 1048834,
                                  \ 'checktime': 83205,
                                  \ 'chistory': 256,
                                  \ 'clist': 1048838,
                                  \ 'clast': 17667,
                                  \ 'close': 1066243,
                                  \ 'clearjumps': 1048832,
                                  \ 'cmap': 1059076,
                                  \ 'cmapclear': 1048836,
                                  \ 'cmenu': 1079557,
                                  \ 'cnext': 17667,
                                  \ 'cnewer': 17665,
                                  \ 'cnfile': 17667,
                                  \ 'cnoremap': 1059076,
                                  \ 'cnoreabbrev': 1059076,
                                  \ 'cnoremenu': 1079557,
                                  \ 'copy': 3146053,
                                  \ 'colder': 17665,
                                  \ 'colorscheme': 1048852,
                                  \ 'command': 1058822,
                                  \ 'comclear': 1048832,
                                  \ 'compiler': 1048854,
                                  \ 'continue': 1573120,
                                  \ 'confirm': 1050756,
                                  \ 'copen': 17665,
                                  \ 'cprevious': 17667,
                                  \ 'cpfile': 17667,
                                  \ 'cquit': 21763,
                                  \ 'crewind': 17667,
                                  \ 'cscope': 2060,
                                  \ 'cstag': 278,
                                  \ 'cunmap': 1059076,
                                  \ 'cunabbrev': 1059076,
                                  \ 'cunmenu': 1059076,
                                  \ 'cwindow': 17665,
                                  \ 'delete': 3147585,
                                  \ 'delmarks': 1048838,
                                  \ 'debug': 1575044,
                                  \ 'debuggreedy': 1069313,
                                  \ 'delcommand': 1048982,
                                  \ 'delfunction': 1048726,
                                  \ 'display': 1575172,
                                  \ 'diffupdate': 258,
                                  \ 'diffget': 2097413,
                                  \ 'diffoff': 258,
                                  \ 'diffpatch': 2097436,
                                  \ 'diffput': 261,
                                  \ 'diffsplit': 284,
                                  \ 'diffthis': 256,
                                  \ 'digraphs': 1048836,
                                  \ 'djump': 103,
                                  \ 'dlist': 1048679,
                                  \ 'doautocmd': 1048836,
                                  \ 'doautoall': 1048836,
                                  \ 'drop': 295308,
                                  \ 'dsearch': 1048679,
                                  \ 'dsplit': 103,
                                  \ 'edit': 295198,
                                  \ 'earlier': 1048852,
                                  \ 'echo': 1574916,
                                  \ 'echoerr': 1574916,
                                  \ 'echohl': 1573124,
                                  \ 'echomsg': 1574916,
                                  \ 'echon': 1574916,
                                  \ 'else': 1573120,
                                  \ 'elseif': 1574916,
                                  \ 'emenu': 1067397,
                                  \ 'endif': 1573120,
                                  \ 'endfunction': 1048832,
                                  \ 'endfor': 1573120,
                                  \ 'endtry': 1573120,
                                  \ 'endwhile': 1573120,
                                  \ 'enew': 258,
                                  \ 'ex': 295198,
                                  \ 'execute': 1574916,
                                  \ 'exit': 1311103,
                                  \ 'exusage': 256,
                                  \ 'file': 20767,
                                  \ 'files': 1048838,
                                  \ 'filetype': 1048836,
                                  \ 'filter': 2182,
                                  \ 'find': 311583,
                                  \ 'finally': 1573120,
                                  \ 'finish': 1573120,
                                  \ 'first': 295174,
                                  \ 'fold': 1573185,
                                  \ 'foldclose': 1573187,
                                  \ 'folddoopen': 2213,
                                  \ 'folddoclosed': 2213,
                                  \ 'foldopen': 1573187,
                                  \ 'for': 1574916,
                                  \ 'function': 1048582,
                                  \ 'global': 1572967,
                                  \ 'goto': 1590529,
                                  \ 'grep': 18831,
                                  \ 'grepadd': 18831,
                                  \ 'gui': 1343758,
                                  \ 'gvim': 1343758,
                                  \ 'help': 2054,
                                  \ 'helpclose': 17665,
                                  \ 'helpgrep': 2180,
                                  \ 'helptags': 1048972,
                                  \ 'hardcopy': 1319,
                                  \ 'highlight': 1573126,
                                  \ 'hide': 17671,
                                  \ 'history': 1048836,
                                  \ 'insert': 3145987,
                                  \ 'iabbrev': 1059076,
                                  \ 'iabclear': 1048836,
                                  \ 'if': 1574916,
                                  \ 'ijump': 103,
                                  \ 'ilist': 1048679,
                                  \ 'imap': 1059076,
                                  \ 'imapclear': 1048836,
                                  \ 'imenu': 1079557,
                                  \ 'inoremap': 1059076,
                                  \ 'inoreabbrev': 1059076,
                                  \ 'inoremenu': 1079557,
                                  \ 'intro': 1048832,
                                  \ 'isearch': 1048679,
                                  \ 'isplit': 103,
                                  \ 'iunmap': 1059076,
                                  \ 'iunabbrev': 1059076,
                                  \ 'iunmenu': 1059076,
                                  \ 'join': 7341379,
                                  \ 'jumps': 1048832,
                                  \ 'k': 1573141,
                                  \ 'keepmarks': 2180,
                                  \ 'keepjumps': 2180,
                                  \ 'keeppatterns': 2180,
                                  \ 'keepalt': 2180,
                                  \ 'list': 5244225,
                                  \ 'lNext': 17667,
                                  \ 'lNfile': 17667,
                                  \ 'last': 295174,
                                  \ 'language': 1048836,
                                  \ 'laddexpr': 2452,
                                  \ 'laddbuffer': 16661,
                                  \ 'laddfile': 284,
                                  \ 'later': 1048852,
                                  \ 'lbuffer': 16663,
                                  \ 'lbottom': 256,
                                  \ 'lcd': 1048862,
                                  \ 'lchdir': 1048862,
                                  \ 'lclose': 17665,
                                  \ 'lcscope': 2060,
                                  \ 'ldo': 18599,
                                  \ 'left': 3146053,
                                  \ 'leftabove': 2180,
                                  \ 'let': 1574916,
                                  \ 'lexpr': 2454,
                                  \ 'lfile': 286,
                                  \ 'lfdo': 18599,
                                  \ 'lfirst': 17667,
                                  \ 'lgetfile': 284,
                                  \ 'lgetbuffer': 16661,
                                  \ 'lgetexpr': 2452,
                                  \ 'lgrep': 18831,
                                  \ 'lgrepadd': 18831,
                                  \ 'lhelpgrep': 2180,
                                  \ 'lhistory': 256,
                                  \ 'll': 17667,
                                  \ 'llast': 17667,
                                  \ 'llist': 1048838,
                                  \ 'lmap': 1059076,
                                  \ 'lmapclear': 1048836,
                                  \ 'lmake': 2318,
                                  \ 'lnoremap': 1059076,
                                  \ 'lnext': 17667,
                                  \ 'lnewer': 17665,
                                  \ 'lnfile': 17667,
                                  \ 'loadview': 284,
                                  \ 'loadkeymap': 1048576,
                                  \ 'lockmarks': 2180,
                                  \ 'lockvar': 1572998,
                                  \ 'lolder': 17665,
                                  \ 'lopen': 17665,
                                  \ 'lprevious': 17667,
                                  \ 'lpfile': 17667,
                                  \ 'lrewind': 17667,
                                  \ 'ltag': 16662,
                                  \ 'lunmap': 1059076,
                                  \ 'lua': 1048709,
                                  \ 'luado': 1048741,
                                  \ 'luafile': 1048733,
                                  \ 'lvimgrep': 18831,
                                  \ 'lvimgrepadd': 18831,
                                  \ 'lwindow': 17665,
                                  \ 'ls': 1048838,
                                  \ 'move': 3146053,
                                  \ 'mark': 1573141,
                                  \ 'make': 2318,
                                  \ 'map': 1059078,
                                  \ 'mapclear': 1048838,
                                  \ 'marks': 1048836,
                                  \ 'match': 1064965,
                                  \ 'menu': 1079559,
                                  \ 'menutranslate': 1059076,
                                  \ 'messages': 1048837,
                                  \ 'mkexrc': 1048862,
                                  \ 'mksession': 286,
                                  \ 'mkspell': 2446,
                                  \ 'mkvimrc': 1048862,
                                  \ 'mkview': 286,
                                  \ 'mode': 1048852,
                                  \ 'mzscheme': 1573029,
                                  \ 'mzfile': 1048733,
                                  \ 'next': 311567,
                                  \ 'nbkey': 16516,
                                  \ 'nbclose': 1048832,
                                  \ 'nbstart': 1048852,
                                  \ 'new': 311583,
                                  \ 'nmap': 1059076,
                                  \ 'nmapclear': 1048836,
                                  \ 'nmenu': 1079557,
                                  \ 'nnoremap': 1059076,
                                  \ 'nnoremenu': 1079557,
                                  \ 'noremap': 1059078,
                                  \ 'noautocmd': 2180,
                                  \ 'nohlsearch': 1573120,
                                  \ 'noreabbrev': 1059076,
                                  \ 'noremenu': 1079559,
                                  \ 'noswapfile': 2180,
                                  \ 'normal': 1583239,
                                  \ 'number': 5244225,
                                  \ 'nunmap': 1059076,
                                  \ 'nunmenu': 1059076,
                                  \ 'oldfiles': 1573122,
                                  \ 'omap': 1059076,
                                  \ 'omapclear': 1048836,
                                  \ 'omenu': 1079557,
                                  \ 'only': 17667,
                                  \ 'onoremap': 1059076,
                                  \ 'onoremenu': 1079557,
                                  \ 'options': 256,
                                  \ 'ounmap': 1059076,
                                  \ 'ounmenu': 1059076,
                                  \ 'ownsyntax': 1574916,
                                  \ 'print': 5768513,
                                  \ 'packadd': 1573278,
                                  \ 'packloadall': 1573122,
                                  \ 'pclose': 258,
                                  \ 'perl': 1573029,
                                  \ 'perldo': 1048741,
                                  \ 'pedit': 295198,
                                  \ 'pop': 21763,
                                  \ 'popup': 1051014,
                                  \ 'ppop': 21763,
                                  \ 'preserve': 256,
                                  \ 'previous': 312583,
                                  \ 'promptfind': 1050628,
                                  \ 'promptrepl': 1050628,
                                  \ 'profile': 1048838,
                                  \ 'profdel': 1048836,
                                  \ 'psearch': 103,
                                  \ 'ptag': 20759,
                                  \ 'ptNext': 20739,
                                  \ 'ptfirst': 20739,
                                  \ 'ptjump': 278,
                                  \ 'ptlast': 258,
                                  \ 'ptnext': 20739,
                                  \ 'ptprevious': 20739,
                                  \ 'ptrewind': 20739,
                                  \ 'ptselect': 278,
                                  \ 'put': 3150659,
                                  \ 'pwd': 1048832,
                                  \ 'python': 1048709,
                                  \ 'pydo': 1048741,
                                  \ 'pyfile': 1048733,
                                  \ 'py3': 1048709,
                                  \ 'py3do': 1048741,
                                  \ 'python3': 1048709,
                                  \ 'py3file': 1048733,
                                  \ 'quit': 1066243,
                                  \ 'quitall': 258,
                                  \ 'qall': 1048834,
                                  \ 'read': 3412319,
                                  \ 'recover': 286,
                                  \ 'redo': 1048832,
                                  \ 'redir': 1048846,
                                  \ 'redraw': 1048834,
                                  \ 'redrawstatus': 1048834,
                                  \ 'registers': 1050884,
                                  \ 'resize': 1065237,
                                  \ 'retab': 3146103,
                                  \ 'return': 1574916,
                                  \ 'rewind': 295174,
                                  \ 'right': 3146053,
                                  \ 'rightbelow': 2180,
                                  \ 'rshada': 1048862,
                                  \ 'runtime': 1573262,
                                  \ 'rundo': 156,
                                  \ 'ruby': 1048709,
                                  \ 'rubydo': 1048741,
                                  \ 'rubyfile': 1048733,
                                  \ 'rviminfo': 1048862,
                                  \ 'substitute': 1048645,
                                  \ 'sNext': 312583,
                                  \ 'sargument': 312583,
                                  \ 'sall': 17667,
                                  \ 'sandbox': 2180,
                                  \ 'saveas': 1311038,
                                  \ 'sbuffer': 247047,
                                  \ 'sbNext': 50433,
                                  \ 'sball': 50433,
                                  \ 'sbfirst': 33024,
                                  \ 'sblast': 33024,
                                  \ 'sbmodified': 50433,
                                  \ 'sbnext': 50433,
                                  \ 'sbprevious': 50433,
                                  \ 'sbrewind': 33024,
                                  \ 'scriptnames': 1048832,
                                  \ 'scriptencoding': 1048852,
                                  \ 'scscope': 2052,
                                  \ 'set': 1573124,
                                  \ 'setfiletype': 1048964,
                                  \ 'setglobal': 1573124,
                                  \ 'setlocal': 1573124,
                                  \ 'sfind': 311583,
                                  \ 'sfirst': 295174,
                                  \ 'simalt': 1048980,
                                  \ 'sign': 1065093,
                                  \ 'silent': 1575046,
                                  \ 'sleep': 1066245,
                                  \ 'slast': 295174,
                                  \ 'smagic': 1048645,
                                  \ 'smap': 1059076,
                                  \ 'smapclear': 1048836,
                                  \ 'smenu': 1079557,
                                  \ 'snext': 311567,
                                  \ 'snomagic': 1048645,
                                  \ 'snoremap': 1059076,
                                  \ 'snoremenu': 1079557,
                                  \ 'source': 1573150,
                                  \ 'sort': 2099303,
                                  \ 'split': 311583,
                                  \ 'spellgood': 16775,
                                  \ 'spelldump': 258,
                                  \ 'spellinfo': 256,
                                  \ 'spellrepall': 256,
                                  \ 'spellundo': 16775,
                                  \ 'spellwrong': 16775,
                                  \ 'sprevious': 312583,
                                  \ 'srewind': 295174,
                                  \ 'stop': 1048834,
                                  \ 'stag': 20759,
                                  \ 'startinsert': 1048834,
                                  \ 'startgreplace': 1048834,
                                  \ 'startreplace': 1048834,
                                  \ 'stopinsert': 1048834,
                                  \ 'stjump': 278,
                                  \ 'stselect': 278,
                                  \ 'sunhide': 17665,
                                  \ 'sunmap': 1059076,
                                  \ 'sunmenu': 1059076,
                                  \ 'suspend': 1048834,
                                  \ 'sview': 311583,
                                  \ 'swapname': 1048832,
                                  \ 'syntax': 1050628,
                                  \ 'syntime': 1048980,
                                  \ 'syncbind': 256,
                                  \ 't': 3146053,
                                  \ 'tcd': 1048862,
                                  \ 'tchdir': 1048862,
                                  \ 'tNext': 20739,
                                  \ 'tag': 20759,
                                  \ 'tags': 1048832,
                                  \ 'tab': 2180,
                                  \ 'tabclose': 1069335,
                                  \ 'tabdo': 18597,
                                  \ 'tabedit': 315679,
                                  \ 'tabfind': 315807,
                                  \ 'tabfirst': 256,
                                  \ 'tabmove': 20757,
                                  \ 'tablast': 256,
                                  \ 'tabnext': 20757,
                                  \ 'tabnew': 315679,
                                  \ 'tabonly': 1069335,
                                  \ 'tabprevious': 20757,
                                  \ 'tabNext': 20757,
                                  \ 'tabrewind': 256,
                                  \ 'tabs': 1048832,
                                  \ 'tcl': 1048709,
                                  \ 'tcldo': 1048741,
                                  \ 'tclfile': 1048733,
                                  \ 'terminal': 1048590,
                                  \ 'tfirst': 20739,
                                  \ 'throw': 1572996,
                                  \ 'tjump': 278,
                                  \ 'tlast': 258,
                                  \ 'tmap': 1059076,
                                  \ 'tmapclear': 1048836,
                                  \ 'tmenu': 1079557,
                                  \ 'tnext': 20739,
                                  \ 'tnoremap': 1059076,
                                  \ 'topleft': 2180,
                                  \ 'tprevious': 20739,
                                  \ 'trewind': 20739,
                                  \ 'try': 1573120,
                                  \ 'tselect': 278,
                                  \ 'tunmap': 1059076,
                                  \ 'tunmenu': 1059076,
                                  \ 'undo': 1070337,
                                  \ 'undojoin': 1048832,
                                  \ 'undolist': 1048832,
                                  \ 'unabbreviate': 1059076,
                                  \ 'unhide': 17665,
                                  \ 'unlet': 1572998,
                                  \ 'unlockvar': 1572998,
                                  \ 'unmap': 1059078,
                                  \ 'unmenu': 1059078,
                                  \ 'unsilent': 1575044,
                                  \ 'update': 262527,
                                  \ 'vglobal': 1048677,
                                  \ 'version': 1048836,
                                  \ 'verbose': 1591429,
                                  \ 'vertical': 2180,
                                  \ 'visual': 295198,
                                  \ 'view': 295198,
                                  \ 'vimgrep': 18831,
                                  \ 'vimgrepadd': 18831,
                                  \ 'viusage': 256,
                                  \ 'vmap': 1059076,
                                  \ 'vmapclear': 1048836,
                                  \ 'vmenu': 1079557,
                                  \ 'vnoremap': 1059076,
                                  \ 'vnew': 311583,
                                  \ 'vnoremenu': 1079557,
                                  \ 'vsplit': 311583,
                                  \ 'vunmap': 1059076,
                                  \ 'vunmenu': 1059076,
                                  \ 'write': 1311103,
                                  \ 'wNext': 278879,
                                  \ 'wall': 1048834,
                                  \ 'while': 1574916,
                                  \ 'winsize': 388,
                                  \ 'wincmd': 1065109,
                                  \ 'windo': 18597,
                                  \ 'winpos': 1048836,
                                  \ 'wnext': 278815,
                                  \ 'wprevious': 278815,
                                  \ 'wq': 262527,
                                  \ 'wqall': 262462,
                                  \ 'wsverb': 16516,
                                  \ 'wshada': 1048862,
                                  \ 'wundo': 158,
                                  \ 'wviminfo': 1048862,
                                  \ 'xit': 1311103,
                                  \ 'xall': 258,
                                  \ 'xmap': 1059076,
                                  \ 'xmapclear': 1048836,
                                  \ 'xmenu': 1079557,
                                  \ 'xnoremap': 1059076,
                                  \ 'xnoremenu': 1079557,
                                  \ 'xunmap': 1059076,
                                  \ 'xunmenu': 1059076,
                                  \ 'yank': 1050433,
                                  \ 'z': 5243205,
                                  \ '!': 1048655,
                                  \ '#': 5244225,
                                  \ '&': 3145797,
                                  \ '<': 7341377,
                                  \ ':': 5243169,
                                  \ '>': 7341377,
                                  \ '@': 1048901,
                                  \ 'Next': 312583,
                                  \ '~': 3145797,
                                  \ }

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim
Sourced 1 time
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    1              0.000009 let s:chars = " \t0123456789.$%'/?-+,;\\"
                            
    1              0.000005 function! wilder#cmdline#skip_range#do(ctx) abort
                              while a:ctx.pos < len(a:ctx.cmdline) &&
                                    \ stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' ||
                                        \ l:second_char ==# '/' ||
                                        \ l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
                              endwhile
                            endfunc

SCRIPT  /Users/klasseg/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/profile.vim
Sourced 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
    1              0.000005 function! wilder#cmdline#profile#do(ctx) abort
                              let l:arg_start = a:ctx.pos
                            
                              if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                let a:ctx.expand = 'profile'
                                let a:ctx.pos = l:arg_start
                                return
                              endif
                            
                              let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                            
                              if l:subcommand ==# 'start'
                                let a:ctx.expand = 'files'
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            endfunction

FUNCTION  <SNR>86_make_hl_from_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:158
Called 8 times
Total time:   0.001750
 Self time:   0.000501

count  total (s)   self (s)
    8   0.000299   0.000038   let l:term_hl = s:normalise_attrs(a:args[0])
    8   0.000720   0.000035   let l:cterm_hl = s:normalise_attrs(a:args[1])
    8   0.000341   0.000037   let l:gui_hl = s:normalise_attrs(a:args[2])
                            
    8              0.000012   let l:cmd = 'hi! ' . a:name . ' '
                            
    8              0.000008   let l:term_attr = l:term_hl[2:]
    8              0.000008   if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
    8              0.000002   endif
                            
    8              0.000009   let l:cterm_attr = l:cterm_hl[2:]
    8              0.000008   if !empty(l:cterm_attr)
    8              0.000025     let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
    8              0.000002   endif
                            
    8              0.000008   if len(l:cterm_hl) >= 1
    8              0.000006     if l:cterm_hl[0] >= 0
    8              0.000015       let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
    8              0.000002     endif
                            
    8              0.000013     if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
    8              0.000012       let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
    8              0.000002     endif
    8              0.000002   endif
                            
    8              0.000009   let l:gui_attr = l:gui_hl[2:]
    8              0.000007   if !empty(l:gui_attr)
    8              0.000017     let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
    8              0.000002   endif
                            
    8              0.000006   if len(l:gui_hl) >= 1
    8              0.000011     if type(l:gui_hl[0]) == v:t_number
    8              0.000029       let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
                                else
                                  let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
    8              0.000002     endif
                            
    8              0.000006     if len(l:gui_hl) >= 2
    8              0.000009       if type(l:gui_hl[1]) == v:t_number
    8              0.000018         let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
                                  else
                                    let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
    8              0.000002       endif
    8              0.000002     endif
    8              0.000002   endif
                            
    8              0.000071   exe l:cmd

FUNCTION  remote#define#FunctionOnChannel()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:159
Called 2 times
Total time:   0.000230
 Self time:   0.000173

count  total (s)   self (s)
    2              0.000009   let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
    2              0.000005   if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
    2              0.000001   endif
    2   0.000047   0.000020   call s:AddEval(rpcargs, a:opts)
                            
    2   0.000136   0.000106   let function_def = s:GetFunctionPrefix(a:name, a:opts) . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')' . "\nendfunction"
    2              0.000021   exe function_def

FUNCTION  1()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:135
Called 341 times
Total time:   0.010097
 Self time:   0.009557

count  total (s)   self (s)
  341              0.000427   if exists('w:matchup_match_id_list')
   88              0.000117     for l:id in w:matchup_match_id_list
                                  silent! call matchdelete(l:id)
   88              0.000040     endfor
   88              0.000105     unlet! w:matchup_match_id_list
  341              0.000083   endif
  341              0.000304   if exists('s:ns_id')
  341              0.001673     call nvim_buf_clear_namespace(0, s:ns_id, 0, -1)
  341              0.000086   endif
                            
  341              0.001072   if !has('nvim') && exists('t:match_popup') && (exists('*win_gettype') ? win_gettype() !=# 'popup' : &buftype !=# 'terminal')
                                call s:do_popup_autocmd_leave(t:match_popup)
                                call popup_hide(t:match_popup)
  341              0.000318   elseif has('nvim')
  341   0.001537   0.000997     call s:close_floating_win()
  341              0.000070   endif
                            
  341              0.000290   if exists('w:matchup_oldstatus')
                                let &l:statusline = w:matchup_oldstatus
                                unlet w:matchup_oldstatus
                                if exists('#User#MatchupOffscreenLeave')
                                  doautocmd <nomodeline> User MatchupOffscreenLeave
                                endif
  341              0.000065   endif
  341              0.000260   if exists('w:matchup_statusline')
                                unlet w:matchup_statusline
  341              0.000060   endif
                            
  341              0.000260   let w:matchup_need_clear = 0

FUNCTION  2()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:203
Called 516 times
Total time:   0.012535
 Self time:   0.002730

count  total (s)   self (s)
                              ""
                              " fade feature: remove highlights after a certain time
                              " {level}
                              "   =  0: prepare for possible loss of cursor support
                              "   =  1: new highlights are coming (cancel prior fade)
                              "   =  2: end of new highlights
                              " {pos}     [lnum, column] of current match
                              " {token}   in/out saves state between calls
                              "
                              " returns 1 if highlighting should be canceled
                            
  516              0.000584   if !g:matchup_matchparen_deferred || !exists('w:matchup_fade_timer')
  516              0.000290     if a:level <= 0
  338   0.010252   0.000448       call s:matchparen.clear()
  516              0.000104     endif
  516              0.000188     return 0
                              endif
                            
                              " jumping between windows
                              if a:level == 0 && win_getid() != get(s:, 'save_win')
                                call timer_pause(w:matchup_fade_timer, 1)
                                if exists('w:matchup_fade_pos')
                                  unlet w:matchup_fade_pos
                                endif
                                call s:matchparen.clear()
                                let s:save_win = win_getid()
                              endif
                            
                              " highlighting might be stale
                              if a:level == 0
                                if exists('w:matchup_fade_pos')
                                  let a:token.save_pos = w:matchup_fade_pos
                                  unlet w:matchup_fade_pos
                                endif
                                if !w:matchup_need_clear
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                                return 0
                              endif
                            
                              " prepare for new highlighting
                              if a:level == 1
                                " if token has no save_pos, cursor was previously off of a match
                                if !has_key(a:token, 'save_pos') || a:pos != a:token.save_pos
                                  " clear immediately
                                  call timer_pause(w:matchup_fade_timer, 1)
                                  call s:matchparen.clear()
                                  return 0
                                endif
                                let w:matchup_fade_pos = a:token.save_pos
                                return 1
                              endif
                            
                              " new highlighting is active
                              if a:level == 2 && a:pos != get(w:, 'matchup_fade_pos', [])
                                " init fade request
                                let w:matchup_fade_pos = a:pos
                                let w:matchup_fade_start = reltime()
                                call timer_pause(w:matchup_fade_timer, 0)
                              endif
                            
                              return 0

FUNCTION  3()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:290
Called 338 times
Total time:   0.235345
 Self time:   0.003143

count  total (s)   self (s)
  338              0.001772   if !get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
  338   0.233320   0.001118     return s:matchparen.highlight()
                              endif
                            
                              if !exists('w:matchup_timer')
                                let s:show_delay = g:matchup_matchparen_deferred_show_delay
                                let s:hide_delay = g:matchup_matchparen_deferred_hide_delay
                                let w:matchup_timer = timer_start(s:show_delay, function('s:timer_callback', [ win_getid() ]), {'repeat': -1})
                                if !exists('w:matchup_need_clear')
                                  let w:matchup_need_clear = 0
                                endif
                                let s:fade_time = g:matchup_matchparen_deferred_fade_time
                                if s:fade_time > 0
                                  let w:matchup_fade_timer = timer_start(s:fade_time, function('s:fade_timer_callback', [ win_getid() ]), {'repeat': -1})
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                              endif
                            
                              " keep the timer alive with a heartbeat
                              let w:matchup_pulse_time = reltime()
                            
                              " if the timer is paused, some time has passed
                              if timer_info(w:matchup_timer)[0].paused
                                " unpause the timer
                                call timer_pause(w:matchup_timer, 0)
                            
                                " set the hi time to the pulse time
                                let w:matchup_hi_time = w:matchup_pulse_time
                              endif

FUNCTION  4()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:329
Called 338 times
Total time:   0.232202
 Self time:   0.034833

count  total (s)   self (s)
  338              0.000697   if !g:matchup_matchparen_enabled | return | endif
                            
  338              0.000908   if has('vim_starting') | return | endif
                            
  338              0.000622   if !g:matchup_matchparen_pumvisible && s:pumvisible() | return | endif
                            
                              " try to avoid interfering with some auto-complete plugins
  338              0.000675   if has('*state') && state('a') !=# '' | return | endif
                            
  338              0.000996   if !get(b:, 'matchup_matchparen_enabled', 1) && get(b:, 'matchup_matchparen_fallback', 1) && s:pi_paren_sid()
                                return call(s:pi_paren_fcn, [])
  338              0.000068   endif
                            
  338              0.000460   if !get(b:, 'matchup_matchparen_enabled', 1) | return | endif
                            
  338              0.000768   let l:force_update    = a:0 >= 1 ? a:1 : 0
  338              0.000325   let l:changing_insert = a:0 >= 2 ? a:2 : 0
  338              0.000598   let l:real_mode = l:changing_insert ? v:insertmode : mode()
                            
  338   0.015697   0.003461   if !l:force_update && exists('w:last_changedtick') && exists('w:last_cursor') && matchup#pos#equal(w:last_cursor, matchup#pos#get_cursor()) && w:last_changedtick == b:changedtick
                                return
  338              0.000075   endif
  338              0.000288   let w:last_changedtick = b:changedtick
  338   0.001150   0.000894   let w:last_cursor = matchup#pos#get_cursor()
                            
  338   0.001783   0.000962   call matchup#perf#tic('matchparen.highlight')
                            
                              " request eventual clearing of stale matches
  338              0.000221   let l:token = {}
  338   0.012402   0.000673   call self.fade(0, [], l:token)
                            
  338              0.000332   let l:modes = g:matchup_matchparen_nomode
  338              0.000428   if get(g:, 'matchup_matchparen_novisual', 0)  " deprecated option name
                                let l:modes .= "vV\<c-v>"
  338              0.000060   endif
  338              0.000468   if stridx(l:modes, l:real_mode) >= 0
                                return
  338              0.000055   endif
                            
                              " prevent problems in visual block mode at the end of a line
  338   0.001472   0.001218   if get(matchup#pos#get_cursor(), 4, 0) == 2147483647 && "v\<c-v>" =~? mode()
                                return
  338              0.000056   endif
                            
                              " don't get matches when inside a closed fold
  338              0.000525   if foldclosed(line('.')) > -1
                                return
  338              0.000054   endif
                            
                              " give up when cursor is far into a very long line
  338              0.000669   if &synmaxcol && col('.') > &synmaxcol
                                return
  338              0.000053   endif
                            
                              " in insert mode, cursor is treated as being one behind
  338              0.000338   let l:insertmode = l:real_mode ==# 'i'
                            
                              " start the timeout period
  338              0.001214   let l:timeout = l:insertmode ? get(b:, 'matchup_matchparen_insert_timeout',           g:matchup_matchparen_insert_timeout) : get(b:, 'matchup_matchparen_timeout',           g:matchup_matchparen_timeout)
  338   0.002214   0.001064   call matchup#perf#timeout_start(l:timeout)
                            
  338   0.102921   0.003489   let l:current = matchup#delim#get_current('all', 'both_all', { 'insertmode': l:insertmode,   'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
  338   0.004435   0.000805   call matchup#perf#toc('matchparen.highlight', 'get_current')
                            
  338              0.000475   if get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
                                let l:hsa = get(b:, 'matchup_matchparen_hi_surround_always', g:matchup_matchparen_hi_surround_always)
                                if l:hsa > 0 && empty(l:current) || l:hsa > 1
                                  call s:highlight_surrounding(l:insertmode, !empty(l:current))
                                endif
  338              0.000060   endif
                            
  338              0.000215   if empty(l:current)
  249              0.000074     return
   89              0.000014   endif
                            
   89   0.057074   0.000691   let l:corrlist = matchup#delim#get_matching(l:current, { 'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
   89   0.001207   0.000238   call matchup#perf#toc('matchparen.highlight', 'get_matching')
   89              0.000105   if empty(l:corrlist) | return | endif
                            
   89              0.000063   if g:matchup_transmute_enabled
                                if !exists('w:matchup_matchparen_context')
                                  let w:matchup_matchparen_context = { 'normal': {   'current':   {},   'corrlist':  [],  }, 'prior': {}, 'counter': 0,}
                                endif
                            
                                let w:matchup_matchparen_context.counter += 1
                            
                                if !l:insertmode
                                  let w:matchup_matchparen_context.prior = copy(w:matchup_matchparen_context.normal)
                            
                                  let w:matchup_matchparen_context.normal.current = l:current
                                  let w:matchup_matchparen_context.normal.corrlist = l:corrlist
                                endif
                            
                                " if transmuted, highlight again (will reset timeout)
                                if matchup#transmute#tick(l:insertmode)
                                  " no force_update here because it would screw up prior
                                  return s:matchparen.highlight(0, l:changing_insert)
                                endif
   89              0.000015   endif
                            
   89              0.000280   if !has_key(l:current, 'match_index') || len(l:corrlist) <= (l:current.side ==# 'mid' ? 2 : 1) && !g:matchup_matchparen_singleton
                                " TODO this doesn't catch every case, needs refactor
                                " TODO singleton doesn't work right for mids
                                return
   89              0.000015   endif
                            
                              " prepare for (possibly) new highlights
   89              0.000089   let l:pos = [l:current.lnum, l:current.cnum]
   89   0.000739   0.000326   if self.fade(1, l:pos, l:token)
                                return
   89              0.000015   endif
                            
                              " store flag meaning highlighting is active
   89              0.000059   let w:matchup_need_clear = 1
                            
                              " disable off-screen when scrolling with j/k
   89              0.000482   let l:scrolling = get(g:matchup_matchparen_offscreen, 'scrolloff', 0) && winheight(0) > 2*&scrolloff && (line('.') == line('w$')-&scrolloff     && line('$') != line('w$')     || line('.') == line('w0')+&scrolloff)
                            
                              " show off-screen matches
   89              0.000119   let l:method = get(g:matchup_matchparen_offscreen, 'method', '')
   89              0.000207   if !empty(l:method) && l:method !=# 'none' && !l:current.skip && !l:scrolling && winheight(0) > 0
                                call s:do_offscreen(l:current, l:method)
   89              0.000016   endif
                            
                              " add highlighting matches
   89   0.008996   0.000292   call s:add_matches(l:corrlist, l:current)
                            
                              " highlight the background between parentheses
   89              0.000081   if g:matchup_matchparen_hi_background >= 1
                                call s:highlight_background(l:corrlist)
   89              0.000017   endif
                            
                              " new highlights done, request fade away
   89   0.000570   0.000177   call self.fade(2, l:pos, l:token)
                            
   89   0.001208   0.000207   call matchup#perf#toc('matchparen.highlight', 'end')

FUNCTION  5()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:499
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   if g:matchup_transmute_enabled
                                call matchup#transmute#reset()
    1              0.000000   endif

FUNCTION  <SNR>89_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:777
Called 19 times
Total time:   0.024884
 Self time:   0.002664

count  total (s)   self (s)
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
   19   0.000334   0.000222   if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
    1              0.000014     let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
   18              0.000050   elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
   18              0.000010   else
   18              0.000906     let l:Completion_func = funcref('wilder#cmdline#getcompletion')
   19              0.000012   endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
   19              0.000050   if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
   19              0.000019   elseif a:fuzzy
                                let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
   19              0.000009   else
   19              0.000197     let l:Getcompletion = l:Completion_func
   19              0.000010   endif
                            
   19   0.022735   0.000626   return wilder#wait(l:Getcompletion(a:ctx, a:res), {ctx, xs -> wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })})

FUNCTION  remote#host#Require()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/host.vim:33
Called 2 times
Total time:   0.070961
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000010   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    2              0.000001   endif
    2              0.000005   let host = s:hosts[a:name]
    2              0.000005   if !host.channel && !host.initialized
    1              0.000003     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    1   0.070909   0.000008     let host.channel = call(host.factory, [host_info])
    1              0.000001     let host.initialized = 1
    2              0.000001   endif
    2              0.000003   return host.channel

FUNCTION  provider#pythonx#DetectByModule()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:39
Called 1 time
Total time:   0.145225
 Self time:   0.000068

count  total (s)   self (s)
    1   0.000057   0.000005   let python_exe = s:get_python_executable_from_host_var(a:major_version)
                            
    1              0.000001   if !empty(python_exe)
                                return [exepath(expand(python_exe, v:true)), '']
    1              0.000000   endif
                            
    1   0.000007   0.000004   let candidates = s:get_python_candidates(a:major_version)
    1              0.000001   let errors = []
                            
    4              0.000004   for exe in candidates
    4   0.145133   0.000032     let [result, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)
    4              0.000002     if result
    1              0.000001       return [exe, error]
    3              0.000001     endif
                                " Accumulate errors in case we don't find any suitable Python executable.
    3              0.000009     call add(errors, error)
    3              0.000002   endfor
                            
                              " No suitable Python executable found.
                              return ['', 'Could not load Python '.a:major_version.":\n".join(errors, "\n")]

FUNCTION  wilder#pipe#check#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 5 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    5              0.000010   return {ctx, x -> s:check(a:args, ctx, x)}

FUNCTION  <SNR>93_result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:23
Called 41 times
Total time:   0.005295
 Self time:   0.004449

count  total (s)   self (s)
   41              0.000064   if empty(a:kvs)
                                return a:result
   41              0.000018   endif
                            
   41              0.000054   let l:kvs = a:kvs
                            
  103              0.000153   while !empty(l:kvs)
   62              0.000095     let l:kv = l:kvs[0]
   62              0.000100     let l:kvs = l:kvs[1:]
   62              0.000081     let l:key = l:kv.key
   62              0.000104     let l:Value = l:kv.value
                            
   62              0.000185     if type(l:Value) is v:t_func
   41   0.001232   0.000386       let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
   41              0.000073       if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value -> wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
   41              0.000020       endif
                            
   41              0.000079       let a:result[l:key] = l:R
   21              0.000047     elseif type(l:Value) is v:t_list
   21              0.000105       let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
   62              0.000046     endif
  103              0.000313   endwhile
                            
   41              0.000046   return a:result

FUNCTION  wilder#hl_with_attr()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:94
Called 2 times
Total time:   0.001275
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000001   let l:attrs = {}
    6              0.000003   for l:attr in a:000
    4              0.000003     if l:attr[:1] ==# 'no'
                                  let l:attrs[l:attr[2:]] = v:false
    4              0.000001     else
    4              0.000004       let l:attrs[l:attr] = v:true
    4              0.000001     endif
    6              0.000002   endfor
    2   0.001255   0.000008   return wilder#make_hl(a:name, a:hl_group, [{}, l:attrs, l:attrs])

FUNCTION  <SNR>99_wait_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:186
Called 19 times
Total time:   0.001453
 Self time:   0.000591

count  total (s)   self (s)
   19              0.000017   try
   19              0.000049     if type(a:state.f) is v:t_func
    1              0.000005       let l:ctx = copy(a:ctx)
                            
    1              0.000003       let s:id_index += 1
    1              0.000003       let l:id_index = s:id_index
    1              0.000005       let s:handler_registry[s:id_index] = a:state.handler
                            
    1              0.000009       call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
   18              0.000012     else
   18              0.000035       let a:ctx.handler_id = a:state.wait_handler_id
   18   0.000970   0.000107       call a:state.on_finish(a:ctx, a:state.f)
   19              0.000011     endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
   19              0.000012   endtry

FUNCTION  <SNR>99_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:95
Called 78 times
Total time:   0.122691
 Self time:   0.001592

count  total (s)   self (s)
   78              0.000263   let a:ctx.handler_id = a:handler_id
                            
   78              0.000065   try
   78   0.121973   0.000874     call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
   78              0.000053   endtry

FUNCTION  matchup#util#in_comment_or_string()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/util.vim:33
Called 595 times
Total time:   0.007118
 Self time:   0.003070

count  total (s)   self (s)
  595   0.007031   0.002982   return call('matchup#util#in_syntax', ['\%(String\|Comment\)'] + a:000)

FUNCTION  <SNR>81_clamp()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:818
Called 123 times
Total time:   0.000719
 Self time:   0.000719

count  total (s)   self (s)
  123              0.000145   if a:value < 1
   59              0.000044     return 1
   64              0.000025   endif
                            
   64              0.000147   let l:max = a:is_height ? (&lines - 1) : &columns
   64              0.000065   if a:value > l:max
                                return l:max
   64              0.000023   endif
                            
   64              0.000056   return a:value

FUNCTION  <SNR>92_subpipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/subpipeline.vim:5
Called 1 time
Total time:   0.000584
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000003   let l:handler_id = a:ctx.handler_id
    1   0.000120   0.000008   let l:pipeline = a:pipeline_func(a:ctx, a:x)
                            
    1   0.000457   0.000030   call wilder#pipeline#run( l:pipeline, {ctx, x -> s:on_finish(l:handler_id, ctx, x)}, {ctx, x -> s:on_error(l:handler_id, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  remote#host#IsRunning()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/host.vim:49
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    1              0.000000   endif
    1              0.000001   return s:hosts[a:name].channel != 0

FUNCTION  matchup#delim#fill_backrefs()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:940
Called 267 times
Total time:   0.000898
 Self time:   0.000898

count  total (s)   self (s)
  267              0.000858   return substitute(a:re, g:matchup#re#backref, '\=s:get_backref(a:groups, submatch(1), a:warn)', 'g')
                                    " \ '\=get(a:groups, submatch(1), "")', 'g')

FUNCTION  highlighturl#set_url_highlight()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:42
Called 1 time
Total time:   0.000077
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000077   0.000012   execute 'highlight default HighlightUrl' highlighturl#get_url_highlight(0)

FUNCTION  <SNR>67_StartHL()
    Defined: ~/.local/share/nvim/lazy/vim-cool/plugin/cool.vim:28
Called 338 times
Total time:   0.000761
 Self time:   0.000761

count  total (s)   self (s)
  338              0.000451     if !v:hlsearch || mode() isnot 'n'
  338              0.000103         return
                                endif
                                let g:cool_is_searching = 1
                                let [pos, rpos] = [winsaveview(), getpos('.')]
                                silent! exe "keepjumps go".(line2byte('.')+col('.')-(v:searchforward ? 2 : 0))
                                try
                                    silent keepjumps norm! n
                                    if getpos('.') != rpos
                                        throw 0
                                    endif
                                catch /^\%(0$\|Vim\%(\w\|:Interrupt$\)\@!\)/
                                    call <SID>StopHL()
                                    return
                                finally
                                    call winrestview(pos)
                                endtry
                                if !get(g:,'cool_total_matches') || !exists('*reltimestr')
                                    return
                                endif
                                exe "silent! norm! :let g:cool_char=nr2char(screenchar(screenrow(),1))\<cr>"
                                let cool_char = remove(g:,'cool_char')
                                if cool_char !~ '[/?]'
                                    return
                                endif
                                let [f, ws, now, noOf] = [0, &wrapscan, reltime(), [0,0]]
                                set nowrapscan
                                try
                                    while f < 2
                                        if reltimestr(reltime(now))[:-6] =~ '[1-9]'
                                            " time >= 100ms
                                            return
                                        endif
                                        let noOf[v:searchforward ? f : !f] += 1
                                        try
                                            silent exe "keepjumps norm! ".(f ? 'n' : 'N')
                                        catch /^Vim[^)]\+):E38[45]\D/
                                            call setpos('.',rpos)
                                            let f += 1
                                        endtry
                                    endwhile
                                finally
                                    call winrestview(pos)
                                    let &wrapscan = ws
                                endtry
                                redraw|echo cool_char.@/ 'match' noOf[0] 'of' noOf[0] + noOf[1] - 1

FUNCTION  wilder#cmdline#prepare_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:20
Called 18 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
   18              0.000045   let a:res.match_arg = a:res.arg
   18              0.000114   let a:res.expand_arg = has_key(a:res, 'subcommand_start') ? a:res.cmdline[a:res.subcommand_start :] : a:res.arg
                            
   18              0.000019   if !a:fuzzy
   18              0.000075     if a:res.expand ==# 'tags' && !empty(a:res.expand_arg) && a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
   18              0.000010     endif
                            
   18              0.000019     return a:res
                              endif
                            
                              return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)

FUNCTION  wilder#cmdline#parse()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:3
Called 19 times
Total time:   0.031466
 Self time:   0.002861

count  total (s)   self (s)
   19   0.000328   0.000235   if !s:cmdline_cache.has_key(a:cmdline)
   19              0.000114     let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
   19   0.029237   0.001962     call wilder#cmdline#main#do(l:ctx)
                            
   19              0.000075     let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
   19              0.000037     let l:ctx['pos'] = l:ctx.pos
   19   0.001380   0.000193     call s:cmdline_cache.set(a:cmdline, l:ctx)
   19              0.000009   endif
                            
   19   0.000212   0.000162   return copy(s:cmdline_cache.get(a:cmdline))

FUNCTION  wilder#highlight#init_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:16
Called 3 times
Total time:   0.004904
 Self time:   0.000128

count  total (s)   self (s)
    9              0.000025   for [l:name, l:x, l:xs] in s:hl_list
    6   0.004868   0.000092     call s:make_hl(l:name, l:x, l:xs)
    9              0.000003   endfor

FUNCTION  <SNR>91_get_python_candidates()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:27
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return { 3: ['python3', 'python3.10', 'python3.9', 'python3.8', 'python3.7', 'python'] }[a:major_version]

FUNCTION  lightline#tab#filename()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline/tab.vim:11
Called 59 times
Total time:   0.000559
 Self time:   0.000559

count  total (s)   self (s)
   59              0.000136   let buflist = tabpagebuflist(a:n)
   59              0.000105   let winnr = tabpagewinnr(a:n)
   59              0.000215   let _ = expand('#'.buflist[winnr - 1].':t')
   59              0.000075   return _ !=# '' ? _ : '[No Name]'

FUNCTION  wilder#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:37
Called 78 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
   78              0.000414   call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})

FUNCTION  <SNR>96_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:236
Called 3 times
Total time:   0.001352
 Self time:   0.000337

count  total (s)   self (s)
    3   0.000141   0.000098   call wilder#pipeline#clear_handlers()
                            
    3              0.000022   if has_key(s:opts.renderer, 'post_hook')
    3   0.001165   0.000193     call s:opts.renderer.post_hook({})
    3              0.000002   endif
                            
    3              0.000006   if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
    3              0.000001   endif

FUNCTION  <SNR>62_evaluate_expand()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:330
Called 59 times
Total time:   0.006006
 Self time:   0.002053

count  total (s)   self (s)
   59              0.000048   try
   59   0.003214   0.000519     let result = eval(a:component . '()')
   59              0.000127     if type(result) == 1 && result ==# ''
                                  return []
   59              0.000018     endif
                              catch
                                return []
   59              0.000045   endtry
   59   0.002399   0.001142   return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')

FUNCTION  <SNR>62_normalize()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:320
Called 177 times
Total time:   0.001258
 Self time:   0.001258

count  total (s)   self (s)
  177              0.000211   if type(a:result) == 3
  177              0.000994     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
                              elseif type(a:result) == 1
                                return [a:result]
                              else
                                return [string(a:result)]
                              endif

FUNCTION  matchup#perf#timeout()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/perf.vim:79
Called 425 times
Total time:   0.000484
 Self time:   0.000484

count  total (s)   self (s)
  425              0.000418   return float2nr(s:timeout)

FUNCTION  <SNR>67_PlayItCool()
    Defined: ~/.local/share/nvim/lazy/vim-cool/plugin/cool.vim:97
Called 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000004     if a:old == 0 && a:new == 1
                                    " nohls --> hls
                                    "   set up coolness
    1              0.000028         noremap <silent> <Plug>(StopHL) :<C-U>nohlsearch<cr>
    1              0.000004         if !exists('*execute')
                                        noremap! <expr> <Plug>(StopHL) <SID>AuNohlsearch()
                            
                                        " If no "execute()", ":tnoremap" isn't probably implemented too.
    1              0.000001         else
    1              0.000010             noremap! <expr> <Plug>(StopHL) execute('nohlsearch')[-1]
    1              0.000004             if exists(':tnoremap')
    1              0.000008                 tnoremap <expr> <Plug>(StopHL) execute('nohlsearch')[-1]
    1              0.000001             endif
    1              0.000001         endif
                            
    1              0.000008         autocmd Cool CursorMoved * call <SID>StartHL()
    1              0.000005         autocmd Cool InsertEnter * call <SID>StopHL()
                                elseif a:old == 1 && a:new == 0
                                    " hls --> nohls
                                    "   tear down coolness
                                    nunmap <Plug>(StopHL)
                                    unmap! <expr> <Plug>(StopHL)
                                    if exists(':tunmap')
                                        tunmap <Plug>(StopHL)
                                    endif
                            
                                    autocmd! Cool CursorMoved
                                    autocmd! Cool InsertEnter
                                else
                                    " nohls --> nohls
                                    "   do nothing
                                    return
    1              0.000001     endif

FUNCTION  wilder#pipe#branch#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:1
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000003   if len(a:args) == 0
                                return {_, x -> v:false}
    3              0.000001   endif
                            
    3              0.000005   return {_, x -> {ctx -> s:branch(a:args, ctx, x)}}

FUNCTION  <SNR>81_draw_candidates_chunks()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:615
Called 28 times
Total time:   0.002084
 Self time:   0.000436

count  total (s)   self (s)
   28              0.000049   let l:is_selected = a:ctx.selected == a:i
                            
   28   0.001881   0.000233   let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
   28              0.000039   let l:Highlighter = a:state.highlighter
                            
   28              0.000028   if l:Highlighter is 0
   28              0.000030     return [[l:str]]
                              endif
                            
                              if !l:is_selected && a:state.highlight_cache.has_key(l:str)
                                return copy(a:state.highlight_cache.get(l:str))
                              endif
                            
                              let l:data = get(a:result, 'data', {})
                              let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
                              if l:spans is 0
                                return [[l:str]]
                              endif
                            
                              if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
                              endif
                            
                              let l:chunks = wilder#render#spans_to_chunks( l:str, l:spans, l:is_selected, a:ctx.highlights)
                            
                              if !l:is_selected
                                call a:state.highlight_cache.set(l:str, l:chunks)
                                let l:chunks = copy(l:chunks)
                              endif
                            
                              return l:chunks

FUNCTION  <SNR>51_anchor_regex()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:960
Called 360 times
Total time:   0.001337
 Self time:   0.001337

count  total (s)   self (s)
  360              0.000156   if a:method
                                " trick to re-match at a particular column
                                " handles the case where pattern contains \ze, \zs, and assertions
                                " but doesn't work with overlapping matches and is possibly slower
                                return '\%<'.(a:cnum+1).'c\%('.a:re.'\)\%>'.(a:cnum).'c'
  360              0.000079   else
                                " fails to match with \zs
  360              0.000439     return '\%'.(a:cnum).'c\%('.a:re.'\)'
                              endif

FUNCTION  wilder#cmdline#prepare_file_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:101
Called 1 time
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
    1              0.000006   let l:res = copy(a:res)
    1              0.000003   let l:arg = l:res.arg
                            
    1              0.000003   if l:res.expand ==# 'file_in_path'
                                let l:res.fuzzy_char = ''
                                let l:res.expand_arg = l:arg
                                let l:res.match_arg = l:arg
                            
                                return l:res
    1              0.000001   endif
                            
                              " Remove backslash preceding spaces.
    1              0.000025   let l:arg = substitute(l:arg, '\\ ', ' ', 'g')
                            
    1              0.000026   let l:slash = !has('win32') && !has('win64') ? '/' : &shellslash ? '/' : '\'
                            
                              " Special handling for ~. Return the home directory.
    1              0.000002   if l:arg ==# '~'
                                let l:res.fuzzy_char = ''
                                let l:res.expand_arg = ''
                                let l:res.completions = [expand('~') . l:slash]
                            
                                return l:res
    1              0.000001   endif
                            
    1              0.000004   let l:original_len = len(l:arg)
                            
                              " Expand the fnamemodify()-able part, if any.
                              " ^(%|#|<cword>|<cWORD>|<client>)(:[phtre])*
    1              0.000083   let l:matches = matchlist(l:arg, '^\(%\|#\|<cword>|<cWORD>|<client>\)' . '\(\%(:[phtre]\)*\)')
    1              0.000004   if len(l:matches) > 0
                                let l:part_to_fnamemodify = l:matches[0]
                                let l:rest = l:arg[len(l:part_to_fnamemodify) :]
                                let l:arg = expand(l:part_to_fnamemodify) . l:rest
                            
                                " Adjust current directory to empty string.
                                if l:arg ==# '.'
                                  let l:arg = ''
                                endif
    1              0.000001   endif
                            
    1              0.000009   let l:allow_backslash = has('win32') || has('win64')
                            
                              " Pattern for matching directory separator.
    1              0.000002   if !l:allow_backslash
    1              0.000003     let l:dir_sep = l:slash
                              else
                                if l:slash ==# '\'
                                  let l:dir_sep = '\\'
                                else
                                  let l:dir_sep = '/\|\\'
                                endif
    1              0.000001   endif
                            
                              " Handle wildcards.
    1              0.000007   let l:first_wildcard = match(l:arg, '\*')
    1              0.000002   if l:first_wildcard >= 0
                                if l:first_wildcard > 0
                                  " Expand the portion before the wildcard since expand('foo/*') will glob
                                  " for matches.
                                  let l:before_wildcard = l:arg[: l:first_wildcard - 1]
                                  let l:after_wildcard = l:arg[l:first_wildcard :]
                            
                                  let l:expand_arg = expand(l:before_wildcard) . l:after_wildcard
                                else
                                  let l:expand_arg = l:arg
                                endif
                            
                                " Don't use fuzzy matching for wildcards.
                                let l:res.has_wildcard = 1
                                let l:res.match_arg = ''
                                let l:res.expand_arg = l:expand_arg
                            
                                return l:res
    1              0.000001   endif
                            
                              " Split path into head and tail
    1              0.000006   if match(l:arg, l:dir_sep) >= 0
                                let l:head = fnamemodify(l:arg, ':h')
                                let l:tail = fnamemodify(l:arg, ':t')
    1              0.000001   else
    1              0.000002     let l:head = ''
    1              0.000002     let l:tail = l:arg
    1              0.000001   endif
                            
                              " Check if tail is trying to complete an env var.
    1              0.000010   let l:matches = matchlist(l:tail, '\$\(\f*\)$')
    1              0.000003   if len(l:matches)
                                let l:env_var = l:matches[1]
                                let l:path_prefix = l:arg[:-len(l:env_var)-1]
                            
                                let l:res.path_prefix = l:path_prefix
                                let l:res.expand = 'environment'
                                let l:res.expand_arg = ''
                                let l:res.fuzzy_char = ''
                                let l:res.completions = map(getcompletion(l:env_var, 'environment'), {_, x -> l:path_prefix . x})
                            
                                " Get position of the $ in tail.
                                let l:dollar_pos = len(l:tail) - len(l:env_var)
                            
                                " Show cursor after the $.
                                let l:res.pos += l:original_len - len(l:tail) + l:dollar_pos
                            
                                return l:res
    1              0.000001   endif
                            
                              " Append / back to l:head.
    1              0.000003   if !empty(l:head)
                                " Expand env vars.
                                let l:head = s:expand_user_and_env_vars(l:head)
                            
                                " Don't add / if there is already an existing / since // is not
                                " simplified - see :h simplify()).
                                if l:head[-1:] !=# l:slash
                                  let l:head .= l:slash
                                endif
                            
                                let l:head = simplify(l:head)
    1              0.000001   endif
                            
    1              0.000003   let l:res.match_arg = l:tail
                            
                              " Don't trim leading / for absolute paths when drawing.
    1              0.000005   let l:path_prefix = l:head ==# l:slash ? '' : l:head
                            
                              " If arg starts with ~/, show paths relative to ~.
                              " head might no longer be under ~ e.g. simplify('~/../..')
    1              0.000009   if l:arg[0] ==# '~' && fnamemodify(l:head, ':~')[0] ==# '~' && match(l:arg[1], l:dir_sep) == 0
                                let l:res.relative_to_home_dir = 1
                                let l:res.path_prefix = fnamemodify(l:path_prefix, ':~')
    1              0.000001   else
    1              0.000003     let l:res.path_prefix = l:path_prefix
    1              0.000001   endif
                            
    1              0.000002   if a:fuzzy
                                let l:res.expand_arg = l:head
                                let l:res.fuzzy_char = strcharpart(l:tail, 0, 1)
    1              0.000001   else
    1              0.000004     let l:res.expand_arg = l:head . l:tail
    1              0.000002     let l:res.fuzzy_char = ''
    1              0.000001   endif
                            
    1              0.000002   if !empty(l:head)
                                " Show cursor at the start of tail.
                                let l:res.pos += l:original_len - len(l:tail)
    1              0.000001   endif
                            
    1              0.000002   return l:res

FUNCTION  <SNR>84_mru_set()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:45
Called 19 times
Total time:   0.001186
 Self time:   0.000237

count  total (s)   self (s)
   19              0.000061   let self['_cache'][a:key] = a:value
                            
   19   0.001101   0.000151   call self.mru_update(a:key)

FUNCTION  <SNR>96_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:429
Called 43 times
Total time:   0.021434
 Self time:   0.005873

count  total (s)   self (s)
   43              0.000044   if s:hidden
                                return
   43              0.000018   endif
                            
   43              0.000026   try
   43              0.000102       let l:direction = a:0 >= 1 ? a:1 : 0
                            
   43              0.000201       if s:selected == -1 && !s:opts.noselect && !s:selection_was_made && !empty(s:result.value)
                                    let l:selected = 0
   43              0.000041       else
   43              0.000062         let l:selected = s:selected
   43              0.000022       endif
                            
   43              0.000504       let l:ctx = { 'clear_previous': get(s:, 'clear_previous_renderer_state', 0), 'selected': l:selected, 'direction': l:direction, 'run_id': s:result_run_id, 'done': s:run_id == s:result_run_id, 'session_id': s:result_session_id, }
   43              0.000071       let s:clear_previous_renderer_state = 0
                            
   43              0.000091       let l:has_error = s:error isnot v:null
                            
   43              0.000048       if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
   43              0.000020       else
   43              0.000071         let l:value = s:result
   43              0.000019       endif
                            
   43   0.019256   0.003695       call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
   43              0.000063   finally
   43              0.000059     let s:draw_done = 1
   43              0.000033   endtry

FUNCTION  <SNR>87_show()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:67
Called 16 times
Total time:   0.003385
 Self time:   0.000103

count  total (s)   self (s)
   16              0.000052   if self.state.win != -1 || self.state.window_state !=# 'hidden'
   14              0.000009     return
    2              0.000001   endif
                            
    2              0.000003   let self.state.window_state = 'pending'
                            
    2              0.000001   try
    2   0.003293   0.000011     call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
    2              0.000001   endtry

FUNCTION  wilder#highlight#get_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:229
Called 8 times
Total time:   0.000191
 Self time:   0.000075

count  total (s)   self (s)
    8              0.000025   if has('nvim')
    8   0.000161   0.000045     return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif

FUNCTION  _wilder_python_get_file_completion()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:169
Called 1 time
Total time:   0.009237
 Self time:   0.000019

count  total (s)   self (s)
    1   0.009236   0.000018 return remote#define#request(4, "/Users/klasseg/.local/share/nvim/lazy/wilder.nvim/rplugin/python3/wilder:function:_wilder_python_get_file_completion", a:000)

FUNCTION  <SNR>21_init_delim_lists_fast()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:523
Called 3 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
    3              0.000009   let l:lists = { 'delim_tex': { 'regex': [], 'regex_capture': [] } }
                            
    3              0.000010   let l:sets = split(a:mps, ',')
    3              0.000004   let l:seen = {}
                            
   15              0.000011   for l:s in l:sets
   21              0.000034     if l:s =~# '^\s*$' | continue | endif
                            
   12              0.000013     if l:s ==# '[:]' || l:s ==# '\[:\]'
    3              0.000002       let l:s = '\[:]'
   12              0.000003     endif
                            
   21              0.000019     if has_key(l:seen, l:s) | continue | endif
   12              0.000013     let l:seen[l:s] = 1
                            
   12              0.000023     let l:words = split(l:s, ':')
   21              0.000015     if len(l:words) < 2 | continue | endif
                            
   12              0.000053     call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'augments' : {},})
   12              0.000095     call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'need_grp' : {}, 'grp_renu' : {}, 'aug_comp' : {}, 'has_zs'   : 0, 'extra_list' : [{}, {}], 'extra_info' : { 'has_zs': 0, },})
   15              0.000007   endfor
                            
                              " TODO if this is empty!
                            
                              " generate combined lists
    3              0.000004   let l:lists.delim_all = {}
    3              0.000003   let l:lists.all = {}
    9              0.000008   for l:k in ['regex', 'regex_capture']
    6              0.000012     let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
    6              0.000010     let l:lists.all[l:k] = l:lists.delim_all[l:k]
    9              0.000003   endfor
                            
    3              0.000002   return l:lists

FUNCTION  highlighturl#delete_url_match()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:56
Called 4 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    5              0.000012   for m in getmatches()
    1              0.000002     if m.group ==# 'HighlightUrl' || m.group ==# 'HighlightUrlCursor'
    1              0.000002       call matchdelete(m.id)
    1              0.000000     endif
    5              0.000003   endfor

FUNCTION  <SNR>99_wait_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:175
Called 19 times
Total time:   0.001915
 Self time:   0.000462

count  total (s)   self (s)
   19              0.000051   let a:state.wait_handler_id = a:ctx.handler_id
                            
   19              0.000217   let a:state.handler = { 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)}, 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)}, }
                            
   19   0.001614   0.000161   call s:wait_call(a:state, a:ctx)

FUNCTION  wilder#pipe#vim_search#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/vim_search.vim:1
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return {ctx, x -> s:search(a:opts, ctx, x)}

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/ftplugin.vim:14
Called 2 times
Total time:   0.004729
 Self time:   0.003546

count  total (s)   self (s)
    2              0.000009     if exists("b:undo_ftplugin")
    1              0.000038       exe b:undo_ftplugin
    1              0.000001       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000001     endif
                            
    2              0.000007     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000012       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000009       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    2   0.004629   0.003445         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
    4              0.000003       endfor
    2              0.000001     endif

FUNCTION  <SNR>21_init_delim_lists()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:144
Called 3 times
Total time:   0.000579
 Self time:   0.000124

count  total (s)   self (s)
    3              0.000013   let l:lists = { 'delim_tex': {   'regex': [],   'regex_capture': [],   'midmap': {}, },}
                            
                              " very tricky examples:
                              " good: let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                              " bad:  let b:match_words = '\(foo\)\(bar\):more\1:and\2:end\1\2'
                            
                              " *subtlety*: there is a huge assumption in matchit:
                              "   ``It should be possible to resolve back references
                              "     from any pattern in the group.''
                              " we don't explicitly check this, but the behavior might
                              " be unpredictable if such groups are encountered.. (ref-1)
                            
    3              0.000008   if exists('g:matchup_hotfix') && has_key(g:matchup_hotfix, &filetype)
                                call call(g:matchup_hotfix[&filetype], [])
    3              0.000006   elseif exists('g:matchup_hotfix_'.&filetype)
                                call call(g:matchup_hotfix_{&filetype}, [])
    3              0.000004   elseif exists('b:matchup_hotfix')
                                call call(b:matchup_hotfix, [])
    3              0.000001   endif
                            
                              " parse matchpairs and b:match_words
    3              0.000009   let l:match_words = !a:no_words ? get(b:, 'match_words', '') : ''
    3              0.000006   if !empty(l:match_words) && l:match_words !~# ':'
                                execute 'let l:match_words =' b:match_words
    3              0.000001   endif
    3              0.000005   let l:simple = empty(l:match_words)
                            
    3              0.000008   let l:mps = escape(&matchpairs, '[$^.*~\\/?]')
    3              0.000007   if !get(b:, 'matchup_delim_nomatchpairs', 0) && !empty(l:mps)
    3              0.000008     let l:match_words .= (l:simple ? '' : ',').l:mps
    3              0.000001   endif
                            
    3              0.000002   if l:simple
    3   0.000474   0.000020     return s:init_delim_lists_fast(l:match_words)
                              endif
                            
                              let l:sets = split(l:match_words, g:matchup#re#not_bslash.',')
                            
                              if a:filter_words
                                call filter(l:sets, 'v:val =~? "^[^a-zA-Z]\\{3,18\\}$"')
                                if empty(l:sets)
                                  return s:init_delim_lists_fast(l:match_words)
                                endif
                              endif
                            
                              " do not duplicate whole groups of match words
                              let l:seen = {}
                              for l:s in l:sets
                                " very special case, escape bare [:]
                                " TODO: the bare [] bug might show up in other places too
                                if l:s ==# '[:]' || l:s ==# '\[:\]'
                                  let l:s = '\[:]'
                                endif
                            
                                if has_key(l:seen, l:s) | continue | endif
                                let l:seen[l:s] = 1
                            
                                if l:s =~# '^\s*$' | continue | endif
                            
                                let l:words = split(l:s, g:matchup#re#not_bslash.':')
                            
                                if len(l:words) < 2 | continue | endif
                            
                                " stores series-level information
                                let l:extra_info = {}
                            
                                " stores information for each word
                                let l:extra_list = map(range(len(l:words)), '{}')
                            
                                " pre-process various \g{special} instructions
                                let l:replacement = { 'hlend': '\%(hlend\)\{0}', 'syn': ''}
                                for l:i in range(len(l:words))
                                  let l:special_flags = []
                                  let l:words[l:i] = substitute(l:words[l:i], g:matchup#re#gspec, '\=[get(l:replacement,submatch(1),""),' . 'add(l:special_flags,' . '[submatch(1),submatch(2)])][0]', 'g')
                                  for [l:f, l:a] in l:special_flags
                                    let l:extra_list[l:i][l:f] = len(l:a) ? l:a : 1
                                  endfor
                                endfor
                            
                                " we will resolve backrefs to produce two sets of words,
                                " one with \(foo\)s and one with \1s, along with a set of
                                " bookkeeping structures
                                let l:words_backref = copy(l:words)
                            
                                " *subtlety*: backref numbers refer to the capture groups
                                " in the 'open' pattern so we have to carefully keep track
                                " of the group renumbering
                                let l:group_renumber = {}
                                let l:augment_comp = {}
                                let l:all_needed_groups = {}
                            
                                " *subtlety*: when replacing things like \1 with \(...\)
                                " the insertion could possibly contain back references of
                                " its own; this poses a very difficult bookkeeping problem,
                                " so we just disallow it.. (ref-2)
                            
                                " get the groups like \(foo\) in the 'open' pattern
                                let l:cg = matchup#loader#get_capture_groups(l:words[0])
                            
                                " if any of these contain \d raise a warning
                                " and substitute it out (ref-2)
                                for l:cg_i in keys(l:cg)
                                  if l:cg[l:cg_i].str =~# g:matchup#re#backref
                                    echohl WarningMsg
                                    echom 'match-up: capture group' l:cg[l:cg_i].str 'should not contain backrefs (ref-2)'
                                    echohl None
                                    let l:cg[l:cg_i].str = substitute(l:cg[l:cg_i].str, g:matchup#re#backref, '', 'g')
                                  endif
                                endfor
                            
                                " for the 'open' pattern, create a series of replacements
                                " of the capture groups with corresponding \9, \8, ..., \1
                                " this must be done deepest to shallowest
                                let l:augments = {}
                                let l:order = matchup#loader#capture_group_replacement_order(l:cg)
                            
                                let l:curaug = l:words[0]
                                " TODO: \0 should match the whole pattern..
                                " augments[0] is the original words[0] with original capture groups
                                let l:augments[0] = l:curaug " XXX does putting this in 0 make sense?
                                for l:j in l:order
                                  " these indexes are not invalid because we work backwards
                                  let l:curaug = strpart(l:curaug, 0, l:cg[l:j].pos[0]) .('\'.l:j).strpart(l:curaug, l:cg[l:j].pos[1])
                                  let l:augments[l:j] = l:curaug
                                endfor
                            
                                " TODO this logic might be bad BADLOGIC
                                " should we not fill groups that aren't needed?
                                " dragons: create the augmentation operators from the
                                " open pattern- this is all super tricky!!
                                " TODO we should be building the augment later, so
                                " we can remove augments that can never be filled
                            
                                " now for the rest of the words...
                                for l:i in range(1, len(l:words)-1)
                            
                                  " first get rid of the capture groups in this pattern
                                  let l:words_backref[l:i] = matchup#loader#remove_capture_groups( l:words_backref[l:i])
                            
                                  " get the necessary \1, \2, etc back-references
                                  let l:needed_groups = []
                                  call substitute(l:words_backref[l:i], g:matchup#re#backref, '\=len(add(l:needed_groups, submatch(1)))', 'g')
                                  call filter(l:needed_groups, 'index(l:needed_groups, v:val) == v:key')
                            
                                  " warn if the back-referenced groups don't actually exist
                                  for l:ng in l:needed_groups
                                    if has_key(l:cg, l:ng)
                                      let l:all_needed_groups[l:ng] = 1
                                    else
                                      echohl WarningMsg
                                      echom 'match-up: backref \' . l:ng 'requested but no ' . 'matching capture group provided'
                                      echohl None
                                    endif
                                  endfor
                            
                                  " substitute capture groups into the backrefs and keep
                                  " track of the mapping to the original backref number
                                  let l:group_renumber[l:i] = {}
                            
                                  let l:cg2 = {}
                                  for l:bref in l:needed_groups
                            
                                    " turn things like \1 into \(...\)
                                    " replacement is guaranteed to exist and not contain \d
                                    let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#backref, '\='''.l:cg[l:bref].str."'", '')    " not global!!
                            
                                    " complicated: need to count the number of inserted groups
                                    let l:prev_max = max(keys(l:cg2))
                                    let l:cg2 = matchup#loader#get_capture_groups(l:words_backref[l:i])
                            
                                    for l:cg2_i in sort(keys(l:cg2), s:Nsort)
                                      if l:cg2_i > l:prev_max
                                        " maps capture groups to 'open' back reference numbers
                                        let l:group_renumber[l:i][l:cg2_i] = l:bref + (l:cg2_i - 1 - l:prev_max)
                                      endif
                                    endfor
                            
                                    " if any backrefs remain, replace with re-numbered versions
                                    let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#not_bslash.'\\'.l:bref, '\\\=l:group_renumber[l:i][submatch(1)]', 'g')
                                  endfor
                            
                                  " mostly a sanity check
                                  if matchup#util#has_duplicate_str(values(l:group_renumber[l:i]))
                                    echohl ErrorMsg
                                    echom 'match-up: duplicate bref in set ' l:s ':' l:i
                                    echohl None
                                  endif
                            
                                  " compile the augment list for this set of backrefs, going
                                  " deepest first and combining as many steps as possible
                                  let l:resolvable = {}
                                  let l:dependency = {}
                            
                                  let l:instruct = []
                                  for l:j in l:order
                                    " the in group is the local number from this word pattern
                                    let l:in_grp_l = keys(filter( deepcopy(l:group_renumber[l:i]), 'v:val == l:j'))
                            
                                    if empty(l:in_grp_l) | continue | endif
                                    let l:in_grp = l:in_grp_l[0]
                            
                                    " if anything depends on this, flush out the current resolvable
                                    if has_key(l:dependency, l:j)
                                      call add(l:instruct, copy(l:resolvable))
                                      let l:dependency = {}
                                    endif
                            
                                    " walk up the tree marking any new dependency
                                    let l:node = l:j
                                    for l:dummy in range(11)
                                      let l:node = l:cg[l:node].parent
                                      if l:node == 0 | break | endif
                                      let l:dependency[l:node] = 1
                                    endfor
                            
                                    " mark l:j as resolvable
                                    let l:resolvable[l:j] = l:in_grp
                                  endfor
                            
                                  if !empty(l:resolvable)
                                    call add(l:instruct, copy(l:resolvable))
                                  endif
                            
                                  " *note*: recall that l:augments[2] is the result of augments
                                  " up to and including 2
                            
                                  " this is a set of instructions of which brefs to resolve
                                  let l:augment_comp[l:i] = []
                                  for l:instr in l:instruct
                                    " the smallest key is the greediest, due to l:order
                                    let l:minkey = min(keys(l:instr))
                                    call insert(l:augment_comp[l:i], { 'inputmap': {}, 'outputmap': {}, 'str': l:augments[l:minkey],})
                            
                                    let l:remaining_out = {}
                                    for l:out_grp in keys(l:cg)
                                      let l:remaining_out[l:out_grp] = 1
                                    endfor
                            
                                    " input map turns this word pattern numbers into 'open' numbers
                                    for [l:out_grp, l:in_grp] in items(l:instr)
                                      let l:augment_comp[l:i][0].inputmap[l:in_grp] = l:out_grp
                                      if has_key(l:remaining_out, l:out_grp)
                                        call remove(l:remaining_out, l:out_grp)
                                      endif
                                    endfor
                            
                                    " output map turns remaining group numbers into 'open' numbers
                                    let l:counter = 1
                                    for l:out_grp in sort(keys(l:remaining_out), s:Nsort)
                                      let l:augment_comp[l:i][0].outputmap[l:counter] = l:out_grp
                                      let l:counter += 1
                                    endfor
                                  endfor
                            
                                  " if l:instruct was empty, there are no constraints
                                  if empty(l:instruct) && !empty(l:augments)
                                    let l:augment_comp[l:i] = [{ 'inputmap': {}, 'outputmap': {}, 'str': l:augments[0],}]
                                    for l:cg_i in keys(l:cg)
                                      let l:augment_comp[l:i][0].outputmap[l:cg_i] = l:cg_i
                                    endfor
                                  endif
                                endfor
                            
                                " strip out unneeded groups in output maps
                                for l:i in keys(l:augment_comp)
                                  for l:aug in l:augment_comp[l:i]
                                    call filter(l:aug.outputmap, 'has_key(l:all_needed_groups, v:key)')
                                  endfor
                                endfor
                            
                                " TODO should l:words[0] actually be used? BADLOGIC
                                " the last element in the order gives the most augmented string
                                " this includes groups that might not actually be needed elsewhere
                                " as a concrete example,
                                " l:augments = { '0': '\<\(wh\%[ile]\|for\)\>', '1': '\<\1\>'}
                                " l:words[0] = \<\1\> (bad)
                                " instead, get the furthest out needed augment.. Heuristic TODO
                                for l:g in add(reverse(copy(l:order)), 0)
                                  if has_key(l:all_needed_groups, l:g)
                                    let l:words[0] = l:augments[l:g]
                                    break
                                  endif
                                endfor
                            
                                " check whether any of these patterns has \zs
                                let l:extra_info.has_zs = match(l:words_backref, g:matchup#re#zs) >= 0
                            
                                " check if hlend is used in any mid
                                if !empty(filter(copy(l:extra_list[1:-2]), 'get(v:val, "hlend")'))
                                  let l:extra_info.mid_hlend = 1
                                endif
                            
                                " this is the original set of words plus the set of augments
                                " TODO this should probably be renamed
                                " (also called regexone)
                                call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : join(l:words[1:-2], '\|'), 'mid_list' : l:words[1:-2], 'augments' : l:augments,})
                            
                                " this list has \(groups\) and we also stuff recapture data
                                " TODO this should probably be renamed
                                " (also called regextwo)
                                call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words_backref[0], 'close'    : l:words_backref[-1], 'mid'      : join(l:words_backref[1:-2], '\|'), 'mid_list' : l:words_backref[1:-2], 'need_grp' : l:all_needed_groups, 'grp_renu' : l:group_renumber, 'aug_comp' : l:augment_comp, 'extra_list' : l:extra_list, 'extra_info' : l:extra_info,})
                              endfor
                            
                              " load info for advanced mid-mapper
                              if exists('b:match_midmap') && type(b:match_midmap) == type([])
                                let l:elems = deepcopy(b:match_midmap)
                                let l:lists.delim_tex.midmap = { 'elements': l:elems, 'strike': '\%(' . join(map(range(len(l:elems)),   '"\\(".l:elems[v:val][1]."\\)"'), '\|') . '\)'}
                              endif
                            
                              " generate combined lists
                              let l:lists.delim_all = {}
                              let l:lists.all = {}
                              for l:k in ['regex', 'regex_capture', 'midmap']
                                let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
                                let l:lists.all[l:k] = l:lists.delim_all[l:k]
                              endfor
                            
                              return l:lists

FUNCTION  <SNR>87_need_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:263
Called 16 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   16              0.000104   if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
   16              0.000010     return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0

FUNCTION  <SNR>86_to_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:45
Called 16 times
Total time:   0.003404
 Self time:   0.000620

count  total (s)   self (s)
   16              0.000026   if type(a:x) is v:t_string
    8   0.000228   0.000037     let l:x = wilder#highlight#get_hl(a:x)
    8              0.000003   else
    8              0.000006     let l:x = a:x
   16              0.000005   endif
                            
   16              0.000043   if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
   16              0.000004   endif
                            
   16   0.001221   0.000203   let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
   16   0.000915   0.000119   let l:cterm_hl = [ get(l:x[1], 'foreground', 'NONE'), get(l:x[1], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[1])
                            
   16   0.000878   0.000099   let l:gui_hl = [ get(l:x[2], 'foreground', 'NONE'), get(l:x[2], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[2])
                            
   16              0.000020   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>81_draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:656
Called 28 times
Total time:   0.001648
 Self time:   0.000486

count  total (s)   self (s)
   28              0.000045   let l:use_cache = a:ctx.selected == a:i
   28              0.000057   if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
   28              0.000009   endif
                            
   28   0.001340   0.000178   let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
   28              0.000021   if l:use_cache
                                call a:state.draw_cache.set(a:i, l:x)
   28              0.000009   endif
                            
   28              0.000022   return l:x

FUNCTION  <SNR>58_lastplace_open_folds()
    Defined: ~/.local/share/nvim/lazy/vim-lastplace/plugin/vim-lastplace.vim:75
Called 3 times
Total time:   0.000126
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000119   0.000015 	if !s:lastplace_can_run()
    2              0.000001 		return
    1              0.000000 	endif
                            
    1              0.000002 	if foldclosed(".") != -1 && g:lastplace_open_folds
                            		"if we're in a fold, make the current line visible and recenter screen
                            		execute "normal! zvzz"
    1              0.000000 	endif

FUNCTION  <SNR>96_run_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:293
Called 24 times
Total time:   0.015745
 Self time:   0.000917

count  total (s)   self (s)
   24              0.000069   let s:run_id += 1
                            
   24              0.000175   let l:ctx = { 'input': a:input, 'run_id': s:run_id, 'session_id': s:session_id, }
                            
   24              0.000030   if a:0 > 0
                                call extend(l:ctx, a:1)
   24              0.000012   endif
                            
   24   0.015326   0.000498   call wilder#pipeline#run( s:opts.pipeline, function('wilder#main#on_finish'), function('wilder#main#on_error'), l:ctx, a:input, )

FUNCTION  LightlineMode()
    Defined: Lua:0
Called 395 times
Total time:   0.003482
 Self time:   0.002632

count  total (s)   self (s)
  395              0.000566           let cmdtype = getcmdtype()
  395   0.002676   0.001826           return  cmdtype == ':' ? 'COMMAND' : cmdtype == '/' ? 'SEARCH' : cmdtype == '?' ? 'REV-SEARCH' :                   lightline#mode()

FUNCTION  wilder#render#chunks_displaywidth()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:250
Called 84 times
Total time:   0.001099
 Self time:   0.001099

count  total (s)   self (s)
   84              0.000093   let l:width = 0
                            
  168              0.000137   for l:chunk in a:chunks
   84              0.000096     if !empty(l:chunk)
   84              0.000173       let l:width += strdisplaywidth(l:chunk[0])
   84              0.000030     endif
  168              0.000206   endfor
                            
   84              0.000061   return l:width

FUNCTION  <SNR>58_lastplace_can_run()
    Defined: ~/.local/share/nvim/lazy/vim-lastplace/plugin/vim-lastplace.vim:29
Called 4 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    4              0.000032 	if index(split(g:lastplace_ignore_buftype, ","), &buftype) != -1 
    2              0.000002 		return 0
    2              0.000001    	endif
                            
    2              0.000005 	if index(split(g:lastplace_ignore, ","), &filetype) != -1
                            		return 0
    2              0.000000 	endif
                            
    2              0.000001 	try
                            		"if the file does not exist on disk (a new, unsaved file) then do nothing
    2              0.000119 		if empty(glob(@%))
                            			return 0
    2              0.000000 		endif
                            	catch
                            		return 0
    2              0.000001 	endtry
                            
    2              0.000001 	return 1

FUNCTION  <SNR>98_redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:9
Called 16 times
Total time:   0.022453
 Self time:   0.022453

count  total (s)   self (s)
   16              0.000060   if a:apply_incsearch_fix && &incsearch && (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
   16              0.000006   endif
                            
   16              0.000018   if a:is_redrawstatus
                                redrawstatus
   16              0.000008   else
   16              0.022237     redraw
   16              0.000016   endif

FUNCTION  <SNR>87_new()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:43
Called 3 times
Total time:   0.000309
 Self time:   0.000053

count  total (s)   self (s)
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
    3              0.000011   if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
    1   0.000172   0.000003     let self.state.buf = s:new_buf()
    3              0.000001   endif
                            
    3              0.000007   if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
    1   0.000090   0.000003     let self.state.dummy_buf = s:new_buf()
    3              0.000001   endif
                            
    3              0.000007   let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
    3              0.000005   let self.state.pumblend = get(a:opts, 'pumblend', -1)
    3              0.000004   let self.state.zindex = get(a:opts, 'zindex', 0)

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/indent.vim:13
Called 2 times
Total time:   0.001195
 Self time:   0.000760

count  total (s)   self (s)
    2              0.000003     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    2              0.000001     endif
    2              0.000003     let s = expand("<amatch>")
    2              0.000002     if s != ""
    2              0.000002       if exists("b:did_indent")
    1              0.000001 	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000006       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    2   0.001166   0.000730         exe $'runtime! indent/{name}[.]{{vim,lua}}'
    4              0.000002       endfor
    2              0.000001     endif

FUNCTION  <SNR>89_set_query()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1473
Called 19 times
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
   19              0.000055   let l:data = a:data is v:null ? {} : a:data
   19              0.000063   let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
   19              0.000204   return extend(l:data, {'query': l:match_arg})

FUNCTION  <SNR>94_branch()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:9
Called 57 times
Total time:   0.107299
 Self time:   0.003368

count  total (s)   self (s)
   57              0.000532   let l:state = { 'index': 0, 'pipelines': a:pipelines, 'original_ctx': copy(a:ctx), 'original_x': copy(a:x), }
                            
   57   0.106674   0.002742   call wilder#pipeline#run( l:state.pipelines[0], {ctx, x -> s:on_finish(l:state, ctx, x)}, {ctx, x -> s:on_error(l:state, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  wilder#renderer#get_cmdheight()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:24
Called 16 times
Total time:   0.000390
 Self time:   0.000390

count  total (s)   self (s)
   16              0.000035   if !has('nvim')
                                " For Vim, if cmdline exceeds cmdheight, the screen lines are pushed up
                                " similar to :mess, so we draw the popupmenu just above the cmdline.
                                " Lines exceeding cmdheight do not count into target line number.
                                return &cmdheight
   16              0.000006   endif
                            
   16              0.000035   let l:cmdline = getcmdline()
                            
                              " include the cmdline character
   16              0.000047   let l:display_width = strdisplaywidth(l:cmdline) + 1
   16              0.000035   let l:cmdheight = l:display_width / &columns + 1
                            
   16              0.000022   if l:cmdheight < &cmdheight
                                let l:cmdheight = &cmdheight
   16              0.000020   elseif l:cmdheight > 1
                                " Show the pum above the msgsep.
                                let l:has_msgsep = stridx(&display, 'msgsep') >= 0
                            
                                if l:has_msgsep
                                  let l:cmdheight += 1
                                endif
   16              0.000006   endif
                            
   16              0.000016   return l:cmdheight

FUNCTION  wilder#highlight#make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:22
Called 2 times
Total time:   0.000971
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000956   0.000008   call s:make_hl(a:name, a:x, a:xs)
    2   0.000009   0.000008   call filter(s:hl_list, {i, elem -> elem[0] !=# a:name})
    2              0.000006   call add(s:hl_list, [a:name, deepcopy(a:x), deepcopy(a:xs)])
    2              0.000001   return a:name

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:79
Called 3 times
Total time:   0.000144
 Self time:   0.000080

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
    3   0.000096   0.000032   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
    3              0.000030     call timer_start(0, {-> s:start()})
    3              0.000004   endif

FUNCTION  <SNR>84_mru_get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:41
Called 19 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
   19              0.000042   return self['_cache'][a:key]

FUNCTION  matchup#loader#bufwinenter()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:99
Called 3 times
Total time:   0.001402
 Self time:   0.000019

count  total (s)   self (s)
    3              0.000008   if get(b:, 'matchup_delim_enabled', 0)
    2              0.000001     return
    1              0.000000   endif
    1   0.001390   0.000007   call matchup#loader#init_buffer()

FUNCTION  <SNR>89_filter_file_in_path()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1205
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if get(a:data, 'cmdline.expand', '') !=# 'file_in_path'
    1              0.000002     return a:xs
                              endif
                            
                              let l:arg = get(a:data, 'cmdline.arg', '')
                              return filter(a:xs, {_, x -> stridx(x, l:arg) != -1})

FUNCTION  wilder#vim_search()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:230
Called 1 time
Total time:   0.000142
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000001   let l:args = a:0 > 0 ? a:1 : {}
    1   0.000141   0.000070   return wilder#pipe#vim_search#(l:args)

FUNCTION  wilder#result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:209
Called 15 times
Total time:   0.000318
 Self time:   0.000147

count  total (s)   self (s)
   15              0.000008   if !a:0
                                return wilder#pipe#result#()
   15              0.000004   else
   15   0.000287   0.000116     return wilder#pipe#result#(a:1)
                              endif

FUNCTION  matchup#pos#equal()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/pos.vim:106
Called 338 times
Total time:   0.011519
 Self time:   0.002726

count  total (s)   self (s)
  338   0.006479   0.001235   let l:pos1 = s:parse_args(a:p1)
  338   0.004345   0.000795   let l:pos2 = s:parse_args(a:p2)
  338              0.000532   return l:pos1[:1] == l:pos2[:1]

FUNCTION  <SNR>33_GetRpcFunction()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:175
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000004   if a:sync ==# 'urgent'
                                return 'rpcnotify'
    2              0.000002   elseif a:sync
    2              0.000002     return 'remote#define#request'
                              endif
                              return 'remote#define#notify'

FUNCTION  matchup#delim#set_invert_skip()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:919
Called 425 times
Total time:   0.000394
 Self time:   0.000394

count  total (s)   self (s)
  425              0.000340   let s:invert_skip = a:val

FUNCTION  wilder#cmdline#getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:345
Called 18 times
Total time:   0.021497
 Self time:   0.021060

count  total (s)   self (s)
   18              0.000054   if has_key(a:res, 'completions')
                                return a:res['completions']
   18              0.000008   endif
                            
   18              0.000036   let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
   18              0.000043   if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
   18              0.000007   endif
                            
   18              0.000075   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
   18              0.000007   endif
                            
   18              0.000040   if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
    3              0.000003     return []
   15              0.000020   elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
   15              0.000017   elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
   15              0.000017   elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
   15              0.000018   elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
   15              0.000017   elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
   15              0.000016   elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
   15              0.000016   elseif a:res.expand ==# 'command'
    8              0.001250     return getcompletion(l:expand_arg, 'command')
    7              0.000007   elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
    7              0.000007   elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
    7              0.000007   elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
    7              0.000008   elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
    7              0.000008   elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
    7              0.000008   elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
    7              0.000007   elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
    7              0.000008   elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
    7              0.000007   elseif a:res.expand ==# 'help'
    1              0.017698     return getcompletion(l:expand_arg, 'help')
    6              0.000006   elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
    6              0.000006   elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
    6              0.000006   elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') + filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
    6              0.000006   elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
    6              0.000007   elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
    6              0.000006   elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>', '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') . ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 || (l:lines[0] !=# 'No mapping found' && l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
    6              0.000007   elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
    6              0.000006   elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
    6              0.000006   elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
    6              0.000006   elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
    6              0.000006   elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(), {_, x -> s:is_prefix(x, l:expand_arg)})
    6              0.000006   elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
    6              0.000006   elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
    6              0.000006   elseif a:res.expand ==# 'profile'
    6   0.000633   0.000196     return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal', 'enable', 'foldlevel', 'include', 'iskeyword', 'keyword', 'list', 'manual', 'match', 'off', 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers', 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count', 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth', 'color', 'command', 'compiler', 'cscope', 'custom', 'customlist', 'dir', 'environment', 'event', 'expression', 'file', 'file_in_path', 'filetype', 'function', 'help', 'highlight', 'history', 'locale', 'mapclear', 'mapping', 'menu', 'messages', 'option', 'packadd', 'shellcmd', 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles', 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' || l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []

FUNCTION  <SNR>99_handle()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:27
Called 78 times
Total time:   0.045043
 Self time:   0.005258

count  total (s)   self (s)
   78              0.000293   let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
   78              0.000219   if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
   78              0.000039   endif
                            
   78              0.000092   let l:X = a:x
   78              0.000203   let l:handler = s:handler_registry[l:handler_id]
                            
   78              0.000142   if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
   78              0.000033   endif
                            
   78              0.000174   unlet s:handler_registry[l:handler_id]
                            
   78              0.000173   if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
   78              0.000033   endif
                            
   78              0.000103   if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
   78              0.000031   endif
                            
   78              0.000049   try
   78   0.040246   0.000461     call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
   78              0.000045   endtry

FUNCTION  <SNR>62_line()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:390
Called 60 times
Total time:   0.023220
 Self time:   0.008423

count  total (s)   self (s)
   60              0.000115   let _ = a:tabline ? '' : '%{lightline#link()}'
   60              0.000159   if s:lightline.palette == {}
                                call lightline#colorscheme()
   60              0.000020   endif
   60              0.000248   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   60              0.000269   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   60              0.000245   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   60              0.000113   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   60              0.000243   let ls = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   60   0.013219   0.000415   let [lc, le, li] = s:expand(ls)
   60              0.000227   let rs = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   60   0.002273   0.000358   let [rc, re, ri] = s:expand(rs)
  122              0.000119   for i in range(len(lc))
   62              0.000196     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
  125              0.000115     for j in range(len(lc[i]))
   63   0.000360   0.000356       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
   63              0.000472       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   63              0.000122       if j < len(lc[i]) - 1 && s.left !=# ''
    1   0.000035   0.000005         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
   63              0.000020       endif
  125              0.000067     endfor
   62              0.000210     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
   62              0.000352     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
  122              0.000057   endfor
   60              0.000105   let _ .= '%#LightlineMiddle_' . mode . '#%='
   62              0.000120   for i in range(len(rc) - 1, 0, -1)
    2              0.000004     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
    2              0.000006     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
    2              0.000003     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
    6              0.000003     for j in range(len(rc[i]))
    4              0.000011       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
    4              0.000014       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
    4              0.000004       if j < len(rc[i]) - 1 && s.right !=# ''
    2   0.000057   0.000012         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
    4              0.000001       endif
    6              0.000001     endfor
   62              0.000036   endfor
   60              0.000043   return _

FUNCTION  <SNR>87_set_firstline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:217
Called 16 times
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
   16              0.000023   if self.state.window_state ==# 'hidden'
                                return
   16              0.000007   endif
                            
   16              0.000018   if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
   16              0.000006   endif
                            
   16              0.000177   call nvim_win_set_cursor(self.state.win, [a:line, 0])

FUNCTION  wilder#pipeline#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:166
Called 19 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
   19              0.000087   let l:state = { 'f': a:f, 'on_finish': a:on_finish, }
                            
   19              0.000089   return {ctx -> s:wait_start(l:state, ctx)}

FUNCTION  <SNR>93_set_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:80
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003   let l:data = a:data is v:null ? {} : a:data
                            
    1              0.000014   return extend(l:data, {'escape_chars': a:chars})

FUNCTION  matchup#delim#get_matching()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:65
Called 89 times
Total time:   0.056383
 Self time:   0.010095

count  total (s)   self (s)
   89              0.000221   if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
   89              0.000184   let l:opts = a:0 && type(a:1) == type({}) ? a:1 : {}
   89              0.000113   let l:stopline = get(l:opts, 'stopline', s:stopline)
                            
                              " get all the matching position(s)
                              " *important*: in the case of mid, we search up before searching down
                              " this gives us a context object which we use for the other side
                              " TODO: what if no open is found here?
   89              0.000051   let l:matches = []
   89   0.000306   0.000223   let l:save_pos = matchup#pos#get_cursor()
  178              0.000287   for l:down in {'open': [1], 'close': [0], 'mid': [0,1]}[a:delim.side]
   89   0.002707   0.001739     call matchup#pos#set_cursor(a:delim)
                            
                                " second iteration: [] refers to the current match
   89              0.000063     if !empty(l:matches)
                                  call add(l:matches, [])
   89              0.000018     endif
                            
   89   0.044667   0.000523     let l:res = a:delim.get_matching(l:down, l:stopline)
   89              0.000060     if empty(l:res)
   89              0.000094     elseif l:res[0][1] > 0
   89              0.000104       call extend(l:matches, l:res)
                                elseif l:down
                                  let l:matches = []
   89              0.000017     endif
  178              0.000078   endfor
   89   0.001322   0.000228   call matchup#pos#set_cursor(l:save_pos)
                            
   89              0.000065   if a:delim.side ==# 'open'
   24              0.000028     call insert(l:matches, [])
   89              0.000018   endif
   89              0.000045   if a:delim.side ==# 'close'
   65              0.000070     call add(l:matches, [])
   89              0.000017   endif
                            
                              " create the match result(s)
   89              0.000062   let l:matching_list = []
  267              0.000172   for l:i in range(len(l:matches))
  178              0.000146     if empty(l:matches[l:i])
   89              0.000083       let a:delim.match_index = l:i
   89              0.000082       call add(l:matching_list, a:delim)
   89              0.000028       continue
   89              0.000021     end
                            
   89              0.000132     let [l:match, l:lnum, l:cnum] = l:matches[l:i]
                            
   89              0.000219     let l:matching = copy(a:delim)
   89              0.000119     let l:matching.class = copy(a:delim.class)
                            
   89              0.000057     let l:matching.lnum = l:lnum
   89              0.000045     let l:matching.cnum = l:cnum
   89              0.000054     let l:matching.match = l:match
   89              0.000175     let l:matching.side = l:i == 0 ? 'open' : l:i == len(l:matches)-1 ? 'close' : 'mid'
   89              0.000069     let l:matching.class[1] = '__mid__'
   89              0.000077     let l:matching.match_index = l:i
                            
   89              0.000089     call add(l:matching_list, l:matching)
  178              0.000098   endfor
                            
                              " set up links between matches
  267              0.000154   for l:i in range(len(l:matching_list))
  178              0.000132     let l:c = l:matching_list[l:i]
  178              0.000117     let l:c.links = {}
  178              0.000265     let l:c.links.next = l:matching_list[(l:i+1) % len(l:matching_list)]
  178              0.000157     let l:c.links.prev = l:matching_list[l:i-1]
  178              0.000117     let l:c.links.open = l:matching_list[0]
  178              0.000131     let l:c.links.close = l:matching_list[-1]
  267              0.000064   endfor
                            
                              " allow empty marker ending
                              " TODO: use a sentinel value instead of empty
   89              0.000157   if len(l:matching_list) >= 2 && empty(l:matching_list[-1].match)
                                if get(l:opts, 'highlighting', 0) && len(l:matching_list) <= 2
                                  return []
                                endif
                                let l:matching_list[0].links.prev = l:matching_list[-2]
                                let l:matching_list[-2].links.next = l:matching_list[0]
   89              0.000016   endif
                            
   89              0.000044   return l:matching_list

FUNCTION  matchup#delim#skip_default()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:885
Called 417 times
Total time:   0.006284
 Self time:   0.002232

count  total (s)   self (s)
  417   0.006219   0.002167   return matchup#util#in_comment_or_string(line('.'), col('.')) ? !s:invert_skip : s:invert_skip

FUNCTION  wilder#setup#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/setup.vim:1
Called 1 time
Total time:   0.000320
 Self time:   0.000195

count  total (s)   self (s)
    1              0.000003   let l:config = get(a:, 1, {})
                            
                              " Duplicate wilder#main#enable_cmdline_enter() and
                              " wilder#main#disable_cmdline_enter() here so we don't have to autoload
                              " autoload/wilder/main.vim.
    1              0.000002   if get(l:config, 'enable_cmdline_enter', 1)
    1              0.000002     if !exists('#WilderCmdlineEnter')
    1              0.000002       augroup WilderCmdlineEnter
    1              0.000007         autocmd!
    1              0.000003         autocmd CmdlineEnter * call wilder#main#start()
    1              0.000000       augroup END
    1              0.000001     endif
                              else
                                if exists('#WilderCmdlineEnter')
                                  augroup WilderCmdlineEnter
                                    autocmd!
                                  augroup END
                                  augroup! WilderCmdlineEnter
                                endif
    1              0.000000   endif
                            
    1              0.000002   let l:wildcharm = get(l:config, 'wildcharm', &wildchar)
    1              0.000001   if l:wildcharm isnot v:false
    1   0.000006   0.000006     execute 'set wildcharm='. &wildchar
    1              0.000000   endif
                            
    1              0.000002   let l:modes = get(l:config, 'modes', ['/', '?'])
    1   0.000194   0.000070   call wilder#options#set('modes', l:modes)
                            
    5              0.000012   for [l:key, l:default_mapping, l:function, l:condition] in [ ['next_key', '<Tab>', 'wilder#next()', 'wilder#in_context()'], ['previous_key', '<S-Tab>', 'wilder#previous()', 'wilder#in_context()'], ['reject_key', '<Up>', 'wilder#reject_completion()', 'wilder#can_reject_completion()'], ['accept_key', '<Down>', 'wilder#accept_completion()', 'wilder#can_accept_completion()'], ]
    4              0.000005     let l:mapping = get(l:config, l:key, l:default_mapping)
    4              0.000002     if l:mapping is v:false
                                  continue
    4              0.000001     endif
                            
    4              0.000004     if type(l:mapping) is v:t_list
                                  let l:fallback_mapping = l:mapping[1]
                                  let l:mapping = l:mapping[0]
    4              0.000001     else
    4              0.000003       let l:fallback_mapping = l:mapping
    4              0.000001     endif
                            
    4              0.000005     if l:key ==# 'accept_key' && !get(l:config, 'accept_completion_auto_select', 1)
                                  let l:function = 'wilder#accept_completion(0)'
    4              0.000001     endif
                            
    4              0.000002     if l:fallback_mapping isnot 0
    4              0.000025       execute 'cnoremap <expr>' l:mapping l:condition ' ? ' l:function ' : ' string(l:fallback_mapping)
                                else
                                  execute 'cmap ' l:mapping '<Cmd>call' l:function '<CR>'
    4              0.000001     endif
    5              0.000002   endfor
                            

FUNCTION  wilder#renderer#popupmenu#draw_column()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:572
Called 48 times
Total time:   0.001373
 Self time:   0.001072

count  total (s)   self (s)
   48              0.000111   let l:Column = a:column
   48              0.000056   let l:height = a:ctx.height
                            
   48              0.000086   if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
   48              0.000019   endif
                            
   48              0.000070   if type(l:Column) is v:t_func
   16   0.000415   0.000114     let l:Column = l:Column(a:ctx, a:result)
   48              0.000020   endif
                            
   48              0.000084   if type(l:Column) is v:t_string
   32              0.000042     if empty(l:Column)
                                  return []
   32              0.000014     endif
                            
   32              0.000096     return repeat([[[l:Column]]], l:height)
   16              0.000006   endif
                            
                              " v:t_list
   16              0.000019   if empty(l:Column)
   16              0.000012     return []
                              endif
                            
                              if empty(l:Column[0])
                                return []
                              endif
                            
                              " highlight chunk
                              if type(l:Column[0]) is v:t_string
                                return repeat([[l:Column]], l:height)
                              endif
                            
                              " list of highlight chunks
                              if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
                              endif
                            
                              " list of list of highlight chunks
                              return l:Column

FUNCTION  wilder#check()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:193
Called 5 times
Total time:   0.000293
 Self time:   0.000107

count  total (s)   self (s)
    5   0.000288   0.000102   return wilder#pipe#check#(a:000)

FUNCTION  matchup#util#in_syntax()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/util.vim:39
Called 595 times
Total time:   0.004049
 Self time:   0.004049

count  total (s)   self (s)
                              " usage: matchup#util#in_syntax(name, [line, col])
  595              0.000978   let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                            
                              " check syntax at position (same as matchit's s: method)
  595              0.001470   let l:syn = synIDattr(synID(l:pos[0], l:pos[1], 1), 'name')
  595              0.001206   return l:syn =~? a:name

FUNCTION  lightline#link()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:222
Called 395 times
Total time:   0.008441
 Self time:   0.008441

count  total (s)   self (s)
  395              0.002351   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  395              0.000461   if s:mode ==# mode
  387              0.000245     return ''
    8              0.000012   endif
    8              0.000018   let s:mode = mode
    8              0.000036   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
    8              0.000004   endif
    8              0.000166   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   24              0.000117   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   88              0.000191     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   72              0.000063       if i != l
   56              0.000497         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   72              0.000029       endif
  400              0.000666       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  328              0.000540         if i + 1 == j || t || s && i != l
  152              0.001053           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  328              0.000118         endif
  400              0.000177       endfor
   88              0.000041     endfor
   24              0.000016   endfor
    8              0.000036   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    8              0.000009   return ''

FUNCTION  wilder#cmdline#main#is_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:678
Called 92 times
Total time:   0.000534
 Self time:   0.000534

count  total (s)   self (s)
   92              0.000240   let l:nr = char2nr(a:char)
   92              0.000247   return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13

FUNCTION  <SNR>33_AddEval()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:278
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000005   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
    2              0.000001   endif

FUNCTION  <SNR>81_get_position()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:853
Called 16 times
Total time:   0.000772
 Self time:   0.000382

count  total (s)   self (s)
   16              0.000034   let l:col = a:pos % &columns
                            
   16              0.000037   if !has('nvim')
                                if l:col + a:dimensions.width > &columns
                                  let l:col = &columns - a:dimensions.width
                                endif
                                if l:col < 0
                                  let l:col = 0
                                endif
   16              0.000006   endif
                            
   16   0.000506   0.000116   let l:cmdheight = wilder#renderer#get_cmdheight()
   16              0.000042   let l:row = &lines - l:cmdheight - a:dimensions.height
                            
   16              0.000022   return [l:row, l:col]

FUNCTION  <SNR>96_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:94
Called 3 times
Total time:   0.080154
 Self time:   0.000556

count  total (s)   self (s)
    3   0.000073   0.000035   if !wilder#main#in_mode() || !s:enabled
                                call wilder#main#stop()
                                return
    3              0.000003   endif
                            
    3   0.000018   0.000008   if !s:init && wilder#options#get('use_python_remote_plugin')
    1              0.000001     let s:init = 1
                            
    1              0.000000     try
    1              0.000002       if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
    1              0.000000       endif
                            
    1   0.072355   0.000007       call _wilder_init({'num_workers': s:opts.num_workers})
                                catch
                                  echohl ErrorMsg
                                  echomsg 'wilder: Python initialization failed'
                                  echomsg v:exception
                                  echohl Normal
    1              0.000000     endtry
    3              0.000001   endif
                            
    3              0.000004   if s:opts.use_cmdlinechanged
    3              0.000012     if !exists('#WilderCmdlineChanged')
    3              0.000011       augroup WilderCmdlineChanged
    3              0.000064         autocmd!
                                    " call from a timer so statusline does not change during mappings
    3              0.000036         autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
    3              0.000002       augroup END
    3              0.000001     endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
    3              0.000002   endif
                            
    3              0.000005   if !exists('#WilderCmdlineLeave')
    3              0.000003     augroup WilderCmdlineLeave
    3              0.000008       autocmd!
    3              0.000009       autocmd CmdlineLeave * call wilder#main#stop()
    3              0.000009       autocmd CmdwinEnter * call wilder#main#stop()
    3              0.000002     augroup END
    3              0.000001   endif
                            
    3              0.000005   if !exists('#WilderVimResized')
    3              0.000002     augroup WilderVimResized
    3              0.000007       autocmd!
    3              0.000010         autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
    3              0.000001     augroup END
    3              0.000001   endif
                            
    3              0.000006   let s:active = 1
    3              0.000002   let s:hidden = 0
                            
    3              0.000005   if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
    3              0.000001   endif
                            
    3              0.000003   if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
    3              0.000001   endif
                            
    3              0.000005   let s:session_id += 1
                            
    3   0.005945   0.000016   call s:pre_hook()
                            
    3   0.001282   0.000010   call s:do(0)

FUNCTION  provider#pythonx#Detect()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:34
Called 1 time
Total time:   0.145230
 Self time:   0.000005

count  total (s)   self (s)
    1   0.145230   0.000005   return provider#pythonx#DetectByModule('neovim', a:major_version)

FUNCTION  wilder#render#draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:10
Called 28 times
Total time:   0.001161
 Self time:   0.000753

count  total (s)   self (s)
   28   0.000258   0.000200   let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
   28              0.000041   if has_key(a:result, 'draw')
    1              0.000004     let l:ctx = { 'i': a:i, 'selected': a:ctx.selected == a:i, }
                            
    2              0.000003     for l:F in a:result.draw
    1              0.000002       if type(l:F) isnot v:t_func
    1              0.000003         let l:F = function(l:F)
    1              0.000001       endif
                            
    1   0.000022   0.000010       let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
    2              0.000015     endfor
   28              0.000009   endif
                            
   28   0.000492   0.000154   return wilder#render#to_printable(l:x)

FUNCTION  <SNR>81_render_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:285
Called 16 times
Total time:   0.047813
 Self time:   0.006930

count  total (s)   self (s)
   16              0.000039   if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
   16              0.000043     let l:pos = get(a:result, 'pos', 0) + 1
   16              0.000030     let l:pos -= a:state.left_offset
   16              0.000017     if l:pos < 0
                                  let l:pos = 0
   16              0.000007     endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
   16              0.000006   endif
                            
   16              0.000023   let l:selected = a:ctx.selected
   16              0.000024   let l:reverse = a:state.reverse
                            
   16              0.000042   let [l:page_start, l:page_end] = a:state.page
                            
   16              0.000026   if a:state.page != [-1, -1]
                                " draw candidates
   16   0.012264   0.000184     let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
   16              0.000046     let l:lines = l:reverse ? reverse(l:lines) : l:lines
                              else
                                if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
                                else
                                  " draw empty message
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
                                endif
                            
                                let l:width = empty(l:lines) ? a:state.get_min_width(a:ctx, a:result) : wilder#render#chunks_displaywidth(l:lines[0])
   16              0.000006   endif
                            
   16              0.000127   let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
   16              0.000034   let l:lines_height = len(l:lines)
                            
   16              0.000021   let l:top_lines = []
   16              0.000021   let l:top_height = 0
   16              0.000022   for l:Top in a:state.top
                                let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
                                if empty(l:line)
                                  continue
                                endif
                            
                                call add(l:top_lines, l:line)
                                let l:top_height += 1
   16              0.000014   endfor
   16              0.000033   let l:lines = l:top_lines + l:lines
                            
   16              0.000021   let l:bottom_height = 0
   16              0.000023   for l:Bottom in a:state.bottom
                                let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
                                if empty(l:line)
                                  continue
                                endif
                            
                                call add(l:lines, l:line)
                                let l:bottom_height += 1
   16              0.000011   endfor
                            
   16              0.000020   if empty(l:lines)
                                call a:state.api.hide()
                                return
   16              0.000006   endif
                            
   16   0.003462   0.000077   call a:state.api.show()
                            
   16              0.000047   let l:height = len(l:lines)
   16   0.000357   0.000120   let l:max_height = a:state.get_max_height(a:ctx, a:result)
   16              0.000023   if l:max_height > &lines
                                let l:max_height = &lines
   16              0.000006   endif
   16   0.000984   0.000212   let [l:row, l:col] = a:state.position(a:ctx, l:pos, {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
   16   0.000554   0.000155   call a:state.api.move(l:row, l:col, l:height, l:width)
   16   0.000438   0.000084   call a:state.api.set_option('wrap', v:false)
   16   0.000251   0.000093   call a:state.api.clear_all_highlights()
   16   0.000565   0.000107   call a:state.api.delete_all_lines()
                            
   16              0.000045   let l:default_hl = a:state.highlights['default']
   16              0.000033   let l:selected_hl = a:state.highlights['selected']
                            
   16              0.000016   let l:i = 0
   44              0.000069   while l:i < len(l:lines)
   28              0.000046     let l:chunks = l:lines[l:i]
                            
   28              0.000031     let l:text = ''
  140              0.000096     for l:chunk in l:chunks
  112              0.000167       let l:text .= l:chunk[0]
  140              0.000054     endfor
                            
   28   0.000350   0.000152     call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
   28              0.000133     if l:page_start == -1 || (!l:reverse && l:i < l:top_height) || (l:reverse && l:i >= l:top_height + l:lines_height)
                                  let l:is_selected = 0
   28              0.000013     else
   28              0.000159       let l:is_selected = l:reverse ?  l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected : l:page_start + l:i - l:top_height == l:selected
   28              0.000011     endif
                            
   28              0.000027     let l:start = 0
  140              0.000089     for l:chunk in l:chunks
  112              0.000217       let l:end = l:start + len(l:chunk[0])
                            
  112              0.000082       if l:is_selected
                                    if len(l:chunk) == 1
                                      let l:hl = l:selected_hl
                                    elseif len(l:chunk) == 2
                                      let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
                                    endif
  112              0.000039       else
  112              0.000251         let l:hl = get(l:chunk, 1, l:default_hl)
  112              0.000040       endif
                            
  112              0.000122       if l:hl !=# l:default_hl
                                    call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
  112              0.000040       endif
                            
  112              0.000108       let l:start = l:end
  140              0.000063     endfor
                            
   28              0.000028     let l:i += 1
   44              0.000060   endwhile
                            
   16   0.000365   0.000078   call a:state.api.set_firstline(1)
   16   0.022659   0.000105   call wilder#renderer#redraw(a:state.apply_incsearch_fix)

FUNCTION  <SNR>96_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:224
Called 3 times
Total time:   0.005929
 Self time:   0.000084

count  total (s)   self (s)
    3   0.004926   0.000022   call wilder#highlight#init_hl()
                            
    3              0.000005   if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
    3              0.000001   endif
                            
    3              0.000006   if has_key(s:opts.renderer, 'pre_hook')
    3   0.000985   0.000045     call s:opts.renderer.pre_hook({})
    3              0.000001   endif

FUNCTION  wilder#lua#call_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:44
Called 263 times
Total time:   0.165514
 Self time:   0.008209

count  total (s)   self (s)
  263              0.001978   let l:F = s:functions[a:index]
  263   0.066381   0.006209   let l:Result = call(l:F, a:000)
  263   0.035003   0.002082   return wilder#lua#wrap(l:Result)

FUNCTION  wilder#renderer#nvim_api#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:3
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000008   let l:state = { 'buf': -1, 'dummy_buf': -1, 'win': -1, 'ns_id': nvim_create_namespace(''), 'normal_highlight': 'Normal', 'pumblend': -1, 'zindex': 0, 'window_state': 'hidden', 'dimensions': -1, 'firstline': -1, 'options': {}, }
                            
    1              0.000001   let l:api = { 'state': l:state, }
                            
   14              0.000009   for l:f in [ 'new', 'show', 'hide', 'move', 'set_option', 'set_firstline', 'delete_all_lines', 'set_line', 'add_highlight', 'clear_all_highlights', 'need_timer', '_open_win', '_set_buf', ]
   13              0.000037     execute 'let l:api.' . l:f . ' = funcref("s:' . l:f . '")'
   14              0.000003   endfor
                            
    1              0.000001   return l:api

FUNCTION  wilder#result_output_escape()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:217
Called 2 times
Total time:   0.000030
 Self time:   0.000008

count  total (s)   self (s)
    2   0.000029   0.000007   return wilder#pipe#result#escape_output_result(a:chars)

FUNCTION  wilder#renderer#component#popupmenu_error_message#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_error_message.vim:1
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return {ctx, error -> s:error_message(ctx, error)}

FUNCTION  lightline#tabs()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:448
Called 59 times
Total time:   0.002695
 Self time:   0.002695

count  total (s)   self (s)
   59              0.000126   let [x, y, z] = [[], [], []]
   59              0.000063   let nr = tabpagenr()
   59              0.000064   let cnt = tabpagenr('$')
  118              0.000159   for i in range(1, cnt)
   59              0.000512     call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%' . i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
  118              0.000063   endfor
   59              0.000044   let abbr = '...'
   59              0.000185   let n = min([max([&columns / 40, 2]), 8])
   59              0.000113   if len(x) > n && len(z) > n
                                let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
                                let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
   59              0.000112   elseif len(x) + len(z) > 2 * n
                                if len(x) > n
                                  let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
                                elseif len(z) > n
                                  let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
                                endif
   59              0.000017   endif
   59              0.000064   return [x, y, z]

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:172
Called 3 times
Total time:   0.002078
 Self time:   0.000726

count  total (s)   self (s)
    3              0.000049   let s:select_next = 0
                            
    3              0.000016   if !s:active
                                return
    3              0.000007   endif
                            
    3              0.000043   if exists('#WilderCmdlineChanged')
    3              0.000012     augroup WilderCmdlineChanged
    3              0.000129       autocmd!
    3              0.000002     augroup END
    3              0.000018     augroup! WilderCmdlineChanged
    3              0.000002   endif
                            
    3              0.000021   if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
    3              0.000002   endif
                            
    3              0.000009   if exists('#WilderCmdlineLeave')
    3              0.000002     augroup WilderCmdlineLeave
    3              0.000019       autocmd!
    3              0.000002     augroup END
    3              0.000007     augroup! WilderCmdlineLeave
    3              0.000001   endif
                            
    3              0.000007   if exists('#WilderVimResized')
    3              0.000002     augroup WilderVimResized
    3              0.000014       autocmd!
    3              0.000001     augroup END
    3              0.000007     augroup! WilderVimResized
    3              0.000001   endif
                            
    3              0.000005   let s:active = 0
    3              0.000026   let s:result = {'value': [], 'data': {}}
    3              0.000006   let s:selected = -1
    3              0.000006   let s:selection_was_made = 0
    3              0.000006   let s:clear_previous_renderer_state = 0
    3              0.000182   let s:completion_stack = []
    3              0.000006   let s:previous_cmdline = v:null
    3              0.000005   let s:completion = v:null
    3              0.000003   let s:error = v:null
    3              0.000005   let s:replaced_cmdline = v:null
    3              0.000007   let s:completion_from_reject_completion = v:null
                            
    3              0.000004   if !s:hidden
    3   0.001378   0.000026     call s:post_hook()
    3              0.000001   endif
                            
    3              0.000003   let s:hidden = 0

FUNCTION  <SNR>87_set_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:230
Called 20 times
Total time:   0.000436
 Self time:   0.000396

count  total (s)   self (s)
   20              0.000029   if self.state.window_state ==# 'hidden'
                                return
   20              0.000007   endif
                            
   20              0.000023   if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
   20              0.000007   endif
                            
   20   0.000296   0.000256   call nvim_win_set_option(self.state.win, a:option, a:value)

FUNCTION  <SNR>87_delete_all_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:243
Called 16 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   16              0.000447   call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:53
Called 27 times
Total time:   0.000517
 Self time:   0.000517

count  total (s)   self (s)
   27              0.000455   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  <SNR>51_parser_delim_new()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:528
Called 89 times
Total time:   0.018861
 Self time:   0.017793

count  total (s)   self (s)
   89              0.000084   let l:cursorpos = a:opts.cursorpos
   89              0.000056   let l:found = 0
                            
   89   0.000357   0.000289   let l:sides = matchup#loader#sidedict()[a:opts.side]
   89              0.000132   let l:rebrs = b:matchup_delim_lists[a:opts.type].regex_capture
                            
                              " use b:match_ignorecase
   89              0.000125   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
                            
                              " loop through all (index, side) pairs,
   89              0.000078   let l:ns = len(l:sides)
   89              0.000040   let l:found = 0
  374              0.000283   for l:i in range(len(l:rebrs)*l:ns)
  374              0.000346     let l:side = l:sides[ l:i % l:ns ]
                            
  374              0.000200     if l:side ==# 'mid'
  103              0.000105       let l:res = l:rebrs[l:i / l:ns].mid_list
  206              0.000097       if empty(l:res) | continue | end
  271              0.000057     else
  271              0.000389       let l:res = [ l:rebrs[l:i / l:ns][l:side] ]
  453              0.000279       if empty(l:res[0]) | continue | end
  271              0.000055     endif
                            
                                " if pattern may contain \zs, extra processing is required
  271              0.000306     let l:extra_info = l:rebrs[l:i / l:ns].extra_info
  271              0.000324     let l:has_zs = get(l:extra_info, 'has_zs', 0)
                            
  271              0.000129     let l:mid_id = 0
  453              0.000247     for l:re in l:res
  271              0.000158       let l:mid_id += 1
                            
                                  " check whether hlend needs to be handled
  271              0.000380       let l:id = l:side ==# 'mid' ? l:mid_id : l:side ==# 'open' ? 0 : -1
  271              0.000364       let l:extra_entry = l:rebrs[l:i / l:ns].extra_list[l:id]
  271              0.000289       let l:has_hlend = has_key(l:extra_entry, 'hlend')
                            
  271              0.000236       if l:has_hlend && get(a:opts, 'highlighting', 0)
                                    let l:re = s:process_hlend(l:re, l:cursorpos)
  271              0.000066       endif
                            
                                  " prepend the column number and append the cursor column
                                  " to anchor the match; we don't use {start} for matchlist
                                  " because there may be zero-width look behinds
  271   0.001918   0.000918       let l:re_anchored = l:ic . s:anchor_regex(l:re, a:cnum, l:has_zs)
                            
                                  " for current we want the first match which the cursor is inside
  271              0.000165       if a:opts.direction ==# 'current'
  271              0.000333         let l:re_anchored .= '\%>'.(l:cursorpos).'c'
  271              0.000053       endif
                            
  271              0.000773       let l:matches = matchlist(getline(a:lnum), l:re_anchored)
  453              0.000260       if empty(l:matches) | continue | endif
                            
                                  " reject matches which the cursor is outside of
                                  " this matters only for \ze
   89              0.000198       if !l:has_hlend && a:opts.direction ==# 'current' && a:cnum + strlen(l:matches[0]) <= l:cursorpos
                                    continue
   89              0.000014       endif
                            
                                  " if pattern contains \zs we need to re-check the starting column
   89              0.000115       if l:has_zs && match(getline(a:lnum), l:re_anchored) != a:cnum-1
                                    continue
   89              0.000013       endif
                            
                                  " handle syntax check- currently used for 'same' matches
   89              0.000066       if has_key(l:extra_entry, 'syn')
                                    let [l:pat; l:args] = split(l:extra_entry.syn, ';')
                                    let l:offs = str2nr(get(l:args, 0, 0))
                                    let l:invert = 0
                                    if l:pat[0] ==? '!'
                                      let l:invert = 1
                                      let l:pat = l:pat[1:]
                                    endif
                                    let l:res = matchup#util#in_synstack( l:pat, a:lnum, a:cnum + l:offs)
                                    if l:invert && l:res || !l:invert && !l:res
                                      continue
                                    endif
   89              0.000014       endif
                            
   89              0.000042       let l:found = 1
   89              0.000021       break
  271              0.000071     endfor
                            
  453              0.000193     if !l:found | continue | endif
                            
   89              0.000020     break
   89              0.000168   endfor
                            
   89              0.000039   if !l:found
                                return {}
   89              0.000017   endif
                            
   89              0.000072   let l:match = l:matches[0]
                            
   89              0.000100   let l:list = b:matchup_delim_lists[a:opts.type]
   89              0.000106   let l:thisregex  = l:list.regex[l:i / l:ns]
   89              0.000093   let l:thisrecap = l:list.regex_capture[l:i / l:ns]
                            
   89              0.000058   let l:augment = {}
                            
                              " these are the capture groups indexed by their 'open' id
   89              0.000052   let l:groups = {}
   89              0.000040   let l:id = 0
                            
   89              0.000045   if l:side ==# 'open'
   24              0.000032     for l:br in keys(l:thisrecap.need_grp)
                                  if empty(l:matches[l:br]) | continue | endif
                                  let l:groups[l:br] = l:matches[l:br]
   24              0.000009     endfor
   65              0.000013   else
   65              0.000110     let l:id = (l:side ==# 'close') ? len(l:thisrecap.mid_list)+1 : l:mid_id
                            
                                " groups here must be renumbered to match the open pattern
   65              0.000073     if has_key(l:thisrecap.grp_renu, l:id)
                                  for [l:br, l:to] in items(l:thisrecap.grp_renu[l:id])
                                    let l:groups[l:to] = l:matches[l:br]
                                  endfor
                                  " let l:groups[0] = l:matches[0]
   65              0.000013     endif
                            
                                " fill in augment pattern
                                " TODO all the augment patterns should match,
                                " but checking might be too slow
   65              0.000052     if has_key(l:thisrecap.aug_comp, l:id)
                                  let l:aug = l:thisrecap.aug_comp[l:id][0]
                                  let l:augment.str = matchup#delim#fill_backrefs( l:aug.str, l:groups, 0)
                                  let l:augment.unresolved = deepcopy(l:aug.outputmap)
   65              0.000012     endif
   89              0.000018   endif
                            
   89              0.000864   let l:result = { 'type'         : 'delim_tex', 'match'        : l:match, 'augment'      : l:augment, 'groups'       : l:groups, 'side'         : l:side, 'class'        : [(l:i / l:ns), l:id], 'get_matching' : s:engines.classic.get_matching, 'regexone'     : l:thisregex, 'regextwo'     : l:thisrecap, 'midmap'       : get(l:list, 'midmap', {}), 'highlighting' : get(a:opts, 'highlighting', 0),}
                            
   89              0.000044   return l:result

FUNCTION  <SNR>22_wordish()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:1241
Called 178 times
Total time:   0.000674
 Self time:   0.000674

count  total (s)   self (s)
  178              0.000642   return a:delim.match !~? '^[[:punct:]]\{1,3\}$'

FUNCTION  wilder#setup()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:953
Called 1 time
Total time:   0.000659
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000659   0.000073   return call('wilder#setup#', a:000)

FUNCTION  wilder#pipeline#run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:87
Called 138 times
Total time:   0.184892
 Self time:   0.001342

count  total (s)   self (s)
  138              0.000634   let l:pipeline = type(a:pipeline) isnot v:t_list ? [a:pipeline] : a:pipeline
                            
  138   0.117727   0.007205   return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)

FUNCTION  provider#pythonx#CheckForModule()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:75
Called 4 times
Total time:   0.145101
 Self time:   0.000570

count  total (s)   self (s)
    4              0.000400   let prog_path = exepath(a:prog)
    4              0.000004   if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
    4              0.000001   endif
                            
    4              0.000003   let min_version = '3.7'
                            
                              " Try to load module, and output Python version.
                              " Exit codes:
                              "   0  module can be loaded.
                              "   2  module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
    4   0.144572   0.000041   let [prog_exitcode, prog_version] = s:import_module(a:prog, a:module)
                            
    4              0.000011   if prog_exitcode == 2 || prog_exitcode == 0
                                " Check version only for expected return codes.
    4              0.000040     if prog_version !~ '^' . a:major_version
    1              0.000004       return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python ' . a:major_version . '.']
    3              0.000018     elseif prog_version =~ '^' . a:major_version && str2nr(prog_version[2:]) < str2nr(min_version[2:])
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python >= ' . min_version . '.']
    3              0.000002     endif
    3              0.000001   endif
                            
    3              0.000002   if prog_exitcode == 2
    2              0.000005     return [0, prog_path.' does not have the "' . a:module . '" module.']
    1              0.000001   elseif prog_exitcode == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_version]
    1              0.000000   elseif prog_exitcode
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. ' . '(' . prog_exitcode . ', output: ' . prog_version . ')' . ' Report this at https://github.com/neovim/neovim']
    1              0.000000   endif
                            
    1              0.000001   return [1, '']

FUNCTION  <SNR>81_render()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:121
Called 43 times
Total time:   0.012235
 Self time:   0.006306

count  total (s)   self (s)
   43              0.000191   call timer_stop(a:state.empty_message_first_draw_timer)
                            
   43              0.000091   if a:state.run_id != a:ctx.run_id
   24              0.000041     let a:state.longest_line_width = 0
   24   0.000219   0.000130     call a:state.draw_cache.clear()
   24   0.000156   0.000103     call a:state.highlight_cache.clear()
   43              0.000022   endif
                            
   43              0.000076   let a:state.run_id = a:ctx.run_id
                            
   43              0.000042   if a:ctx.clear_previous
   24              0.000054     let a:state.page = [-1, -1]
   43              0.000019   endif
                            
   43   0.002714   0.000322   let l:page = s:make_page(a:state, a:ctx, a:result)
   43              0.000072   let a:ctx.page = l:page
   43              0.000071   let a:state.page = l:page
                            
   43              0.000195   let l:height = l:page == [-1, -1] ? 0 : l:page[1] - l:page[0] + 1
                            
   43   0.002167   0.000452   let l:min_height = a:state.get_min_height(a:ctx, a:result)
   43              0.000110   let l:min_height -= len(a:state.top)
   43              0.000086   let l:min_height -= len(a:state.bottom)
   43              0.000057   if l:height < l:min_height
   13              0.000015     let l:height = l:min_height
   43              0.000019   endif
                            
   43              0.000076   let a:ctx.height = l:height
   43              0.001648   let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
   43              0.000224   if a:state.page == [-1, -1] && !has_key(a:ctx, 'error') && a:state.empty_message is 0
   13   0.000157   0.000080     call a:state.api.hide()
   13              0.000007     return
   30              0.000012   endif
                            
   30              0.000057   let l:was_first_draw = a:state.is_first_draw
   30              0.000041   let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
   30              0.000179   if l:was_first_draw && a:state.page == [-1, -1] && a:state.empty_message isnot 0 && !a:ctx.done && a:state.empty_message_first_draw_delay > 0
                                let a:state.empty_message_first_draw_timer = timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
                                return
   30              0.000011   endif
                            
                              " If error or empty message is not showing, check if we need to draw.
   30   0.001992   0.000530   if !has_key(a:ctx, 'error') && a:state.page != [-1, -1] && !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
   14              0.000009     return
   16              0.000006   endif
                            
   16              0.000022   let a:state.render_id += 1
                            
   16   0.000221   0.000080   if a:state.api.need_timer()
   16              0.000026     let l:render_id = a:state.render_id
   16              0.000105     call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
   16              0.000007   endif

FUNCTION  <SNR>87_hide()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:165
Called 16 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
   16              0.000063   if self.state.win == -1 || self.state.window_state ==# 'hidden'
   14              0.000010     return
    2              0.000002   endif
                            
    2              0.000004   if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
    2              0.000001   endif
                            
    2              0.000007   if getcmdwintype() ==# ''
    2              0.000005     try
    2              0.000176       call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
    2              0.000007     endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
    2              0.000001   endif
                            
    2              0.000005   let self.state.win = -1
    2              0.000004   let self.state.window_state = 'hidden'

FUNCTION  wilder#renderer#call_component_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:81
Called 15 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
   15              0.000052   if type(a:component) is v:t_dict && has_key(a:component, 'post_hook')
                                call a:component['post_hook'](a:ctx)
   15              0.000006   endif

FUNCTION  wilder#vim_substring_pattern()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:226
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return {_, x -> x . (x[-1:] ==# '\' ? '\' : '') . '\k*'}

FUNCTION  <SNR>99_wait_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:206
Called 1 time
Total time:   0.000103
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000005   if type(a:x) is v:t_func
                                let a:state.f = a:x
                                call s:wait_call(a:state, a:ctx)
                                return
    1              0.000001   endif
                            
    1              0.000006   let l:ctx = copy(a:ctx)
    1              0.000003   let l:ctx.handler_id = a:state.wait_handler_id
                            
    1              0.000001   try
    1   0.000075   0.000008     call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
    1              0.000001   endtry

FUNCTION  <SNR>87_set_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:247
Called 28 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   28              0.000190   call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])

FUNCTION  wilder#python_substring_pattern()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:269
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return {_, x -> '(' . wilder#escape_python(x) . ')\w*'}

FUNCTION  matchup#loader#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:21
Called 3 times
Total time:   0.002633
 Self time:   0.000284

count  total (s)   self (s)
    3   0.000025   0.000012   call matchup#perf#tic('loader_init_buffer')
                            
    3              0.000003   let l:has_ts = 0
    3              0.000006   let [l:no_words, l:filt_words] = [0, 0]
    3   0.000152   0.000021   if s:ts_may_be_supported && matchup#ts_engine#is_enabled(bufnr('%'))
                                let l:has_ts = 1
                                if matchup#ts_engine#get_option(bufnr('%'), 'include_match_words')
                                  let l:filt_words = 1
                                else
                                  let l:no_words = 1
                                endif
    3              0.000001   endif
                            
    3              0.000003   let l:has_ts_hl = 0
    3   0.000089   0.000017   if s:ts_may_be_supported && matchup#ts_engine#is_hl_enabled(bufnr('%'))
                                let l:has_ts_hl = 1
                            
                                if matchup#ts_engine#get_option( bufnr('%'), 'additional_vim_regex_highlighting')
                                  if empty(&syntax)
                                    set syntax=ON
                                  else
                                    augroup matchup_syntax
                                      au!
                                      autocmd VimEnter * if empty(&syntax) | set syntax=ON | endif
                                    augroup END
                                  endif
                                endif
    3              0.000001   endif
                            
                              " initialize lists of delimiter pairs and regular expressions
                              " this is the data obtained from parsing b:match_words
    3   0.000607   0.000028   let b:matchup_delim_lists = s:init_delim_lists(l:no_words, l:filt_words)
                            
                              " this is the combined set of regular expressions used for matching
                              " its structure is matchup_delim_re[type][open,close,both,mid,both_all]
    3   0.001489   0.000018   let b:matchup_delim_re = s:init_delim_regexes()
                            
                              " process b:match_skip
    3              0.000002   if l:has_ts_hl
                                let b:matchup_delim_skip = "matchup#ts_syntax#skip_expr(s:effline('.'),s:effcol('.'))"
    3              0.000001   else
    3   0.000026   0.000013     let b:matchup_delim_skip = s:init_delim_skip()
    3              0.000001   endif
                            
                              " enable matching engines
    3              0.000004   let b:matchup_active_engines = {}
                            
    3              0.000002   if l:has_ts
                                for l:t in ['all', 'delim_all', 'delim_py']
                                  let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['tree_sitter']
                                endfor
    3              0.000001   endif
                            
    3              0.000005   if !empty(b:matchup_delim_lists.all.regex)
   12              0.000009     for l:t in ['all', 'delim_all', 'delim_tex']
    9              0.000025       let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['classic']
   12              0.000015     endfor
    3              0.000001   endif
                            
                              " enable/disable for this buffer
    3              0.000005   let b:matchup_delim_enabled = !empty(b:matchup_active_engines)
                            
    3   0.000081   0.000012   call matchup#perf#toc('loader_init_buffer', 'done')

FUNCTION  wilder#highlight#get_hl_nvim()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:237
Called 8 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    8              0.000005   try
    8              0.000049     let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
    8              0.000016     let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
    8              0.000019     return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
    8              0.000005   endtry

FUNCTION  wilder#pipeline#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:12
Called 78 times
Total time:   0.045659
 Self time:   0.000616

count  total (s)   self (s)
   78   0.045616   0.000573   call s:handle(a:ctx, a:x, 'resolve')

FUNCTION  <SNR>62_convert()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:342
Called 67 times
Total time:   0.008097
 Self time:   0.002091

count  total (s)   self (s)
   67              0.000137   if !has_key(s:lightline.component_expand, a:name)
    8              0.000008     return [[[a:name], 0, a:index, a:index]]
   59              0.000028   else
   59              0.000133     let type = get(s:lightline.component_type, a:name, a:index)
   59              0.000151     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
   59   0.007455   0.001449     return filter(map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
                              endif

FUNCTION  wilder#python_search_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:524
Called 1 time
Total time:   0.000258
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002   let l:opts = get(a:, 1, {})
                            
    1              0.000002   let l:Pattern = get(l:opts, 'pattern', get(l:opts, 'regex', 'substring'))
    1              0.000001   if type(l:Pattern) is v:t_func
                                " pass
    1              0.000001   elseif l:Pattern ==# 'fuzzy'
                                let l:Pattern = wilder#python_fuzzy_pattern()
    1              0.000001   elseif l:Pattern ==# 'fuzzy_delimiter'
                                let l:Pattern = wilder#python_fuzzy_delimiter_pattern()
    1              0.000000   else
    1   0.000007   0.000003     let l:Pattern = wilder#python_substring_pattern()
    1              0.000000   endif
                            
    1              0.000002   let l:Sorter = get(l:opts, 'sorter', get(l:opts, 'sort', 0))
                            
    1   0.000015   0.000010   let l:pipeline = [ l:Pattern, wilder#subpipeline({ctx, x -> [   wilder#python_search(s:extract_keys(l:opts, 'max_candidates', 'engine')),   wilder#if(l:Sorter isnot 0, {ctx, xs -> l:Sorter(ctx, xs, ctx.input)}),   wilder#result_output_escape('^$*~[]/\'),   wilder#result({'data': {'pcre2.pattern': x}}), ]}), ]
                            
    1   0.000222   0.000006   return s:search_pipeline({ 'debounce': get(l:opts, 'debounce', 0), 'pipeline': l:pipeline, 'skip_cmdtype_check': get(l:opts, 'skip_cmdtype_check', 0), })

FUNCTION  <SNR>58_lastplace_jump()
    Defined: ~/.local/share/nvim/lazy/vim-lastplace/plugin/vim-lastplace.vim:50
Called 1 time
Total time:   0.000087
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000071   0.000003 	if !s:lastplace_can_run()
                            		return
    1              0.000000 	endif
                            
    1              0.000002 	if line("'\"") > 0 && line("'\"") <= line("$")
                            		"if the last edit position is set and is less than the number of lines in this buffer.
                            
    1              0.000001 		if line("w$") == line("$")
                            			"if the last line in the current buffer is also the last line visible in this window
                            			execute "normal! g`\""
                            
    1              0.000003 		elseif line("$") - line("'\"") > ((line("w$") - line("w0")) / 2) - 1
                            			"if we're not at the bottom of the file, center the cursor on the screen after we make the jump
    1              0.000006 			execute "normal! g`\"zz"
                            
                            		else
                            			"otherwise, show as much context as we can by jumping to the end of the file and then to the mark.
                            			"if we pressed zz here, there would be blank lines at the bottom of the screen.
                            			"we intentionally leave the last line blank by pressing <c-e> so the user can see that they are near the end of the file.
                            			execute "keepjumps normal! \G'\"\<c-e>"
    1              0.000000 		endif
    1              0.000000 	endif

FUNCTION  wilder#render#to_printable()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:98
Called 29 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
   29              0.000036   if !s:has_strtrans_issue
                                " check if first character is a combining character
   29              0.000137     if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
   29              0.000010     endif
                            
   29              0.000078     return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res

FUNCTION  lightline#statusline()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:313
Called 1 time
Total time:   0.000497
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
    1              0.000000   endif
    1   0.000494   0.000005   return s:line(0, a:inactive)

FUNCTION  wilder#vim_substring()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:222
Called 1 time
Total time:   0.000005
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000005   0.000003   return call('wilder#vim_substring_pattern', [])

FUNCTION  <SNR>51_get_matching_delims()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:682
Called 89 times
Total time:   0.044144
 Self time:   0.032570

count  total (s)   self (s)
                              " called as:   a:delim.get_matching(...)
                              " called from: matchup#delim#get_matching <- matchparen, motion
                              "   from: matchup#delim#get_surrounding <- matchparen, motion, text_obj
                            
   89   0.000520   0.000362   call matchup#perf#tic('get_matching_delims')
                            
                              " first, we figure out what the furthest match is, which will be
                              " either the open or close depending on the direction
   89              0.000475   let [l:re, l:flags, l:stopline] = a:down ? [self.regextwo.close, 'W', line('.') + a:stopline] : [self.regextwo.open, 'bW', max([line('.') - a:stopline, 1])]
                            
                              " these are the anchors for searchpairpos
                              " default to the backref '\1' patterns which will be filled in
   89              0.000072   let l:open = self.regexone.open
   89              0.000067   let l:close = self.regexone.close
                            
                              " if we're searching up, we anchor by the augment string, if it exists
   89              0.000087   if !a:down && !empty(self.augment)
                                let l:open = self.augment.str
   89              0.000017   endif
                            
                              " if going down from mid, we might not have all the groups yet
                              " TODO this could be improved via close augment strings
   89              0.000124   if a:down && self.side ==# 'mid' && !empty(self.augment.unresolved)
                                let l:open = self.regextwo.open
                                let l:close = self.regextwo.close
   89              0.000015   endif
                            
                              " turn \(\) into \%(\) for searchpairpos
   89   0.000920   0.000374   let l:open  = matchup#loader#remove_capture_groups(l:open)
   89   0.000742   0.000433   let l:close = matchup#loader#remove_capture_groups(l:close)
                            
                              " fill in necessary back-references
   89   0.000702   0.000323   let l:open = matchup#delim#fill_backrefs(l:open, self.groups, 0)
   89   0.000520   0.000276   let l:close = matchup#delim#fill_backrefs(l:close, self.groups, 0)
                            
   89   0.000327   0.000249   call matchup#delim#set_invert_skip(self.skip)
   89              0.000081   if empty(b:matchup_delim_skip)
   89              0.000057     let l:skip = 'matchup#delim#skip_default()'
                              else
                                let l:skip = 'matchup#delim#skip0()'
   89              0.000016   endif
                            
                              " disambiguate matches for languages like julia, matlab, ruby, etc
   89              0.000061   if !empty(self.midmap)
                                let l:midmap = self.midmap.elements
                                if self.side ==# 'mid'
                                  let l:idx = filter(range(len(l:midmap)), 'self.match =~# l:midmap[v:val][1]')
                                else
                                  let l:syn = synIDattr(synID(self.lnum, self.cnum, 0), 'name')
                                  let l:idx = filter(range(len(l:midmap)), 'l:syn =~# l:midmap[v:val][0]')
                                endif
                                if len(l:idx)
                                  let l:valid = l:midmap[l:idx[0]]
                                  let l:skip = printf('matchup#delim#skip1(%s, %s)', string(l:midmap[l:idx[0]]), string(l:skip))
                                else
                                  let l:skip = printf('matchup#delim#skip2(%s, %s)', string(self.midmap.strike), string(l:skip))
                                endif
   89              0.000015   endif
                            
   89   0.000915   0.000401   if matchup#perf#timeout_check() | return [['', 0, 0]] | endif
                            
                              " improves perceptual performance in insert mode
   89              0.000106   if mode() ==# 'i' || mode() ==# 'R'
                                if !g:matchup_matchparen_deferred && exists('*state') && state('s') ==# ''
                                  sleep 1m
                                endif
   89              0.000015   endif
                            
                              " use b:match_ignorecase
   89              0.000117   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
   89              0.000079   let l:open = l:ic . l:open
   89              0.000068   let l:close = l:ic . l:close
                            
                              " handle 'same' matches (TODO refactor to separate parser)
   89              0.000056   if l:open == l:close
                                let [l:lnum_corr, l:cnum_corr] = searchpos(l:open, 'n'.l:flags, l:stopline, matchup#perf#timeout()) " , l:skip)
   89              0.000027   else
   89   0.028797   0.022417     let [l:lnum_corr, l:cnum_corr] = searchpairpos(l:open, '', l:close, 'n'.l:flags, l:skip, l:stopline, matchup#perf#timeout())
   89              0.000026   endif
                            
   89   0.001285   0.000224   call matchup#perf#toc('get_matching_delims', 'initial_pair')
                            
                              " if nothing found, bail immediately
   89              0.000050   if l:lnum_corr == 0
                                return [['', 0, 0]]
   89              0.000015   endif
                            
                              " when highlighting, respect hlend
   89              0.000135   let l:extra_entry = self.regextwo.extra_list[a:down ? -1 : 0]
   89              0.000118   if self.highlighting && has_key(l:extra_entry, 'hlend')
                                let l:re = s:process_hlend(l:re, -1)
   89              0.000015   endif
                            
                              " get the corresponding match and (additional) groups
   89              0.000083   let l:has_zs = self.regextwo.extra_info.has_zs
   89   0.000651   0.000314   let l:re_anchored = l:ic . s:anchor_regex(l:re, l:cnum_corr, l:has_zs)
                            
   89              0.000287   let l:matches = matchlist(getline(l:lnum_corr), l:re_anchored)
   89              0.000100   let l:match_corr = l:matches[0]
                            
                              " store these in these groups
   89              0.000032   if a:down
   24              0.000030     let l:id = len(self.regextwo.mid_list) + 1
   24              0.000056     for [l:from, l:to] in items(get(self.regextwo.grp_renu, l:id, {}))
                                  if !has_key(self.groups, l:to) && !empty(l:matches[l:from])
                                    let self.groups[l:to] = l:matches[l:from]
                                  endif
   24              0.000009     endfor
   65              0.000012   else
   65              0.000081     for l:to in keys(self.regextwo.need_grp)
                                  if !has_key(self.groups, l:to) && !empty(l:matches[l:to])
                                    " TODO mark context
                                    let self.groups[l:to] = l:matches[l:to]
                                  endif
                                  " let self.groups[0] = l:matches[0]
   65              0.000024     endfor
   89              0.000017   endif
                            
   89   0.001387   0.000429   call matchup#perf#toc('get_matching_delims', 'get_matches')
                            
                              " fill in additional groups
   89   0.000686   0.000351   let l:mids = matchup#loader#remove_capture_groups(self.regexone.mid)
   89   0.000561   0.000287   let l:mids = matchup#delim#fill_backrefs(l:mids, self.groups, 1)
                            
                              " if there are no mids, we're done
   89              0.000082   if empty(l:mids) || g:matchup_delim_nomids
   89              0.000105     return [[l:match_corr, l:lnum_corr, l:cnum_corr]]
                              endif
                            
                              let l:re = l:mids
                            
                              " when highlighting, respect hlend
                              if get(self.regextwo.extra_info, 'mid_hlend') && self.highlighting
                                let l:re = s:process_hlend(l:re, -1)
                              endif
                            
                              " use b:match_ignorecase
                              let l:mid = l:ic . l:mids
                              let l:re = l:ic . l:re
                            
                              let l:list = []
                              while 1
                                if matchup#perf#timeout_check() | break | endif
                            
                                let [l:lnum, l:cnum] = searchpairpos(l:open, l:mids, l:close, l:flags, l:skip, l:lnum_corr, matchup#perf#timeout())
                                if l:lnum <= 0 | break | endif
                            
                                if a:down
                                  if l:lnum > l:lnum_corr || l:lnum == l:lnum_corr && l:cnum >= l:cnum_corr | break | endif
                                else
                                  if l:lnum < l:lnum_corr || l:lnum == l:lnum_corr && l:cnum <= l:cnum_corr | break | endif
                                endif
                            
                                let l:re_anchored = s:anchor_regex(l:re, l:cnum, l:has_zs)
                                let l:matches = matchlist(getline(l:lnum), l:re_anchored)
                                if empty(l:matches)
                                  " this should never happen
                                  continue
                                endif
                                let l:match = l:matches[0]
                            
                                call add(l:list, [l:match, l:lnum, l:cnum])
                              endwhile
                            
                              call add(l:list, [l:match_corr, l:lnum_corr, l:cnum_corr])
                            
                              if !a:down
                                call reverse(l:list)
                              endif
                            
                              return l:list

FUNCTION  matchup#loader#sidedict()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:766
Called 89 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   89              0.000053   return s:sidedict

FUNCTION  <SNR>81_draw_columns()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:543
Called 32 times
Total time:   0.003562
 Self time:   0.002189

count  total (s)   self (s)
   32              0.000050   let l:height = a:ctx.height
                            
   80              0.000087   for l:Column in a:columns
   48   0.001821   0.000449     let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
   48              0.000059     if empty(l:column)
   16              0.000011       continue
   32              0.000012     endif
                            
   32              0.000033     let l:i = 0
   88              0.000118     while l:i < len(l:column)
   56              0.000112       let a:column_chunks[l:i] += l:column[l:i]
                            
   56              0.000051       let l:i += 1
   88              0.000130     endwhile
                            
   32              0.000037     if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
   32              0.000012     endif
   64              0.000056   endfor

FUNCTION  remote#host#RegisterClone()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/host.vim:19
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
    1              0.000000   endif
    1              0.000003   let Factory = s:hosts[a:orig_name].factory
    1              0.000004   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }

FUNCTION  wilder#cmdline#pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1284
Called 1 time
Total time:   0.147014
 Self time:   0.000110

count  total (s)   self (s)
    1              0.000002   if has_key(a:opts, 'hide_in_substitute')
                                let l:hide_in_substitute = a:opts.hide_in_substitute
    1              0.000001   elseif has_key(a:opts, 'hide')
                                " DEPRECATED: use hide_in_substitute
                                let l:hide_in_substitute = a:opts.hide
    1              0.000000   else
    1              0.000003     let l:hide_in_substitute = has('nvim') && !has('nvim-0.3.7')
    1              0.000000   endif
                            
    1              0.000002   let l:Sorter = get(a:opts, 'sorter', get(a:opts, 'sort', 0))
                            
    1              0.000001   let l:set_pcre2_pattern = get(a:opts, 'set_pcre2_pattern', 0)
                            
    1              0.000001   let l:sort_buffers_lastused = get(a:opts, 'sort_buffers_lastused', 1)
                            
    1              0.000001   let l:should_debounce = get(a:opts, 'debounce', 0) > 0
    1              0.000000   if l:should_debounce
                                let l:debounce_interval = a:opts['debounce']
                                let l:Debounce = wilder#debounce(l:debounce_interval)
    1              0.000000   else
    1              0.000001     let l:Debounce = 0
    1              0.000000   endif
                            
    1   0.145985   0.000003   let l:opts = s:get_opts(a:opts)
    1              0.000001   let l:F = l:opts[0]
    1              0.000001   let l:with_data = l:opts[1]
    1              0.000001   let l:fuzzy = l:opts[3]
                            
    1              0.000000   if l:fuzzy
                                if l:with_data
                                  let l:Filter = {ctx, xs, q -> l:F(ctx, {}, xs, q)}
                                else
                                  let l:Filter = l:F
                                endif
    1              0.000000   else
    1              0.000004     let l:Filter = {ctx, xs, q -> filter(xs, {_, x -> match(x, q) == 0})}
    1              0.000000   endif
                            
                              " [handled, user_completions, parsed, need_filter]
                              " : handled?
                              " └--> user_completions
    1   0.000248   0.000015   let l:user_completion_pipeline = [ {ctx, res -> res[0] ? res : v:false}, wilder#subpipeline({ctx, res -> [   {_, res -> res[1]},   wilder#result({     'value': {ctx, xs -> res[3] ? l:Filter(ctx, xs, res[2].arg) : xs},     'pos': res[2].pos,     'replace': ['wilder#cmdline#replace'],     'data': s:convert_result_to_data(res[2]),   }), ]}), ]
                            
                              " [handled, user_completions, parsed]
                              " : not handled, extract parsed
                              " : getcompletion_pipeline 
                              " : sort if needed
                              " : add pcre2 pattern if needed
                              " └--> result
    1   0.000693   0.000021   let l:getcompletion_pipeline = [{ctx, res -> res[2]}] + wilder#cmdline#getcompletion_pipeline(a:opts) + [ wilder#if(l:Sorter isnot 0, wilder#result({   'value': {ctx, xs, data ->     l:Sorter(ctx, xs, get(data, 'cmdline.match_arg', ''))} })), wilder#if(l:set_pcre2_pattern, wilder#result({   'data': {ctx, data -> s:set_pcre2_pattern(data, l:fuzzy)}, })), ]
                            
                              " cmdline
                              " : check getcmdtype()?
                              " |--> return v:false
                              " : parse_cmdline
                              " : check is substitute command and should hide?
                              " |--> return v:true
                              " : prepare_user_completion
                              " : is user completion?
                              " |--> user_completion_pipeline
                              " └--> getcompletion_pipeline
                              "    : add data.query
                              "    └--> result
    1   0.000054   0.000036   return [ wilder#check({-> getcmdtype() ==# ':'}), {_, x -> wilder#cmdline#parse(x)}, wilder#if(l:hide_in_substitute, {ctx, res -> len(get(res, 'substitute_args', [])) >= 2 ? v:true : res}), wilder#if(l:should_debounce, l:Debounce), {ctx, res -> wilder#cmdline#prepare_user_completion(ctx, res)}, wilder#branch(   l:user_completion_pipeline,   l:getcompletion_pipeline, ), wilder#result({   'value': {ctx, xs, data -> l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs},   'data': {ctx, data -> s:set_query(data)}, }), ]

FUNCTION  highlighturl#set_url_match()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:64
Called 4 times
Total time:   0.000566
 Self time:   0.000359

count  total (s)   self (s)
    4   0.000072   0.000035   call highlighturl#delete_url_match()
    4   0.000045   0.000023   if s:get('enable', get(s:, 'enable', 1))
    4              0.000012     if !hlexists('HighlightUrl')
    1   0.000084   0.000003       call highlighturl#set_highlight()
    4              0.000002     endif
    4   0.000100   0.000048     let pattern = s:get('pattern', highlighturl#default_pattern())
    4   0.000217   0.000202     call matchadd('HighlightUrl', pattern, s:get('url_priority', 15))
    4              0.000004     if s:urlcursor
                                  call highlighturl#set_urlcursor_match()
    4              0.000001     endif
    4              0.000001   endif

FUNCTION  <SNR>21_init_delim_regexes()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:577
Called 3 times
Total time:   0.001471
 Self time:   0.000373

count  total (s)   self (s)
    3              0.000007   let l:re = {}
    3              0.000003   let l:re.delim_all = {}
    3              0.000003   let l:re.all = {}
                            
    3   0.001118   0.000020   let l:re.delim_tex = s:init_delim_regexes_generator('delim_tex')
    3              0.000006   let l:re.delim_tex._engine_info = { 'has_zs': {} }
                            
                              " use a flag for b:match_ignorecase
    3              0.000006   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
                            
                              " if a particular engine is specified, use that for the patterns
                              " (currently only applied to delim_re TODO)
    3              0.000014   let l:eng = string(get(b:, 'matchup_regexpengine', 0))
    3              0.000005   let l:eng = l:eng > 0 ? '\%#='.l:eng : ''
                            
   21              0.000014   for l:k in keys(s:sidedict)
   18              0.000095     let l:re.delim_tex._engine_info.has_zs[l:k] = l:re.delim_tex[l:k] =~# g:matchup#re#zs
                            
   18              0.000018     if l:re.delim_tex[l:k] ==# '\%(\)'
    3              0.000003       let l:re.delim_tex[l:k] = ''
   15              0.000004     else
                                  " since these patterns are used in searchpos(),
                                  " be explicit about regex mode (set magic mode and ignorecase)
   15              0.000034       let l:re.delim_tex[l:k] = l:eng . '\m' . l:ic . l:re.delim_tex[l:k]
   18              0.000005     endif
                            
   18              0.000026     let l:re.delim_all[l:k] = l:re.delim_tex[l:k]
   18              0.000024     let l:re.all[l:k] = l:re.delim_all[l:k]
   21              0.000018   endfor
                            
    3              0.000004   let l:re.delim_all._engine_info = l:re.delim_tex._engine_info
    3              0.000003   let l:re.all._engine_info = l:re.delim_all._engine_info
                            
    3              0.000002   return l:re

FUNCTION  wilder#cache#mru_cache()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:27
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   return { '_cache': {}, '_queue': [], '_counts': {}, '_max_size': a:max_size, 'get': funcref('s:mru_get'), 'set': funcref('s:mru_set'), 'has_key': funcref('s:has_key'), 'clear': funcref('s:mru_clear'), 'mru_update': funcref('s:mru_update'), }

FUNCTION  <SNR>96_getcmdline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:634
Called 24 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   24              0.000070   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
   24              0.000047     return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif

FUNCTION  <SNR>87_move()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:198
Called 16 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
   16              0.000030   if self.state.window_state ==# 'hidden'
                                return
   16              0.000006   endif
                            
   16              0.000020   if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
   16              0.000006   endif
                            
   16              0.000252   call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': a:row, 'col': a:col, 'height': a:height, 'width': a:width, })

FUNCTION  <SNR>87__open_win()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:82
Called 2 times
Total time:   0.003281
 Self time:   0.000374

count  total (s)   self (s)
                              " window might have been open or closed already.
    2              0.000003   if self.state.window_state !=# 'pending'
                                return
    2              0.000001   endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
    2              0.000011   let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
    2              0.000011   let l:win_opts = { 'relative': 'editor', 'height': 1, 'width': 1, 'row': &lines - 1, 'col': 0, 'focusable': 0, }
                            
    2              0.000004   if has('nvim-0.5.1')
    2              0.000003     let l:win_opts.zindex = self.state.zindex
    2              0.000001   endif
                            
    2   0.002988   0.000162   let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
    2              0.000004   let self.state.window_state = 'showing'
                            
    2              0.000009   if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
    2              0.000001   else
    2              0.000030     call nvim_win_set_config(self.state.win, { 'style': 'minimal', })
    2              0.000001   endif
                            
    2   0.000068   0.000018   call self.set_option('winhighlight', 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
    2              0.000003   if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
    2              0.000001   else
    2   0.000044   0.000011     call self.set_option('winblend', &pumblend)
    2              0.000001   endif
                            
    2              0.000003   if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
    2              0.000001   endif
                            
    2              0.000002   if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': l:row, 'col': l:col, 'height': l:height, 'width': l:width, })
    2              0.000001   endif
                            
    2              0.000006   for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
    2              0.000001   endfor
                            
    2              0.000003   let self.state.firstline = -1
    2              0.000003   let self.state.dimensions = -1
    2              0.000005   let self.state.options = {}

FUNCTION  highlighturl#default_pattern()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:17
Called 4 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    4              0.000029   return  '\v\c%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)%('.'[&:#*@~%_\-=?!+;/0-9a-z]+%(%([.;/?]|[.][.]+)[&:#*@~%_\-=?!+/0-9a-z]+|:\d+|'.',%(%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)@![0-9a-z]+))*|'.'\([&:#*@~%_\-=?!+;/.0-9a-z]*\)|\[[&:#*@~%_\-=?!+;/.0-9a-z]*\]|'.'\{%([&:#*@~%_\-=?!+;/.0-9a-z]*|\{[&:#*@~%_\-=?!+;/.0-9a-z]*\})\})+'

FUNCTION  matchup#pos#set_cursor()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/pos.vim:10
Called 178 times
Total time:   0.002062
 Self time:   0.000600

count  total (s)   self (s)
  178   0.002030   0.000568   call cursor(s:parse_args(a:000))

FUNCTION  wilder#main#on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:315
Called 24 times
Total time:   0.011575
 Self time:   0.001612

count  total (s)   self (s)
   24              0.000046   if !s:active || !s:enabled
                                return
   24              0.000009   endif
                            
   24              0.000034   if a:ctx.run_id != s:run_id
                                return
   24              0.000008   endif
                            
   24              0.000040   let s:result_run_id = a:ctx.run_id
   24              0.000040   let s:result_session_id = a:ctx.session_id
                            
   24              0.000095   let l:result = (a:x is v:false || a:x is v:true) ? {'value': []} : a:x
   24              0.000040   if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
   24              0.000013   else
   24              0.000047     let s:result = l:result
   24              0.000011   endif
                            
   24              0.000045   if !has_key(s:result, 'data')
    5              0.000010     let s:result.data = {}
   24              0.000009   endif
                            
   24              0.000044   if !has_key(s:result.data, 'query')
    5              0.000007     let s:result.data.query = a:ctx.input
   24              0.000008   endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
   24              0.000027   if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
   24              0.000008   endif
                            
   24              0.000028   let s:selected = -1
   24              0.000033   let s:selection_was_made = 0
   24              0.000038   let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
   24              0.000029   let s:error = v:null
                            
   24              0.000025   if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
   24              0.000008   endif
                            
   24              0.000019   if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
   24              0.000008   endif
                            
   24              0.000021   if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
   24              0.000008   endif
                            
   24              0.000075   if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
   24              0.000008   endif
                            
   24   0.010103   0.000140   call s:draw()

FUNCTION  argwrap#initSetting()
    Defined: ~/.local/share/nvim/lazy/vim-argwrap/autoload/argwrap.vim:229
Called 10 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   10              0.000011     let l:setting = 'g:argwrap_'.a:name
                            
   10              0.000010     if !exists(l:setting)
   10              0.000012         let {l:setting} = a:value
   10              0.000002     endif

FUNCTION  lightline#mode()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:217
Called 389 times
Total time:   0.000850
 Self time:   0.000850

count  total (s)   self (s)
  389              0.000768   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>75_get()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:13
Called 23 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
   23              0.000073   return get(b:, 'highlighturl_' . a:name, get(g:, 'highlighturl_' . a:name, a:default))

FUNCTION  <lambda>44()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 18 times
Total time:   0.024941
 Self time:   0.000256

count  total (s)   self (s)
                            return s:getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  lightline#tabline()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:435
Called 59 times
Total time:   0.024424
 Self time:   0.001693

count  total (s)   self (s)
   59              0.000301   if !has_key(s:highlight, 'tabline')
                                call lightline#highlight('tabline')
   59              0.000036   endif
   59              0.000243   if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$') || s:columns != &columns
   59              0.000154     let s:tabnr = tabpagenr()
   59              0.000084     let s:tabcnt = tabpagenr('$')
   59              0.000092     let s:columns = &columns
   59   0.023174   0.000443     let s:tabline = s:line(1, 0)
   59              0.000021   endif
   59              0.000044   return s:tabline

FUNCTION  <SNR>21_init_delim_skip()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:714
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000006   let l:skip = get(b:, 'match_skip', '')
    3              0.000005   if empty(l:skip) | return '' | endif
                            
                              " s:foo becomes (current syntax item) =~ foo
                              " S:foo becomes (current syntax item) !~ foo
                              " r:foo becomes (line before cursor) =~ foo
                              " R:foo becomes (line before cursor) !~ foo
                              let l:cursyn = "synIDattr(synID(s:effline('.'),s:effcol('.'),1),'name')"
                              let l:preline = "strpart(s:geteffline('.'),0,s:effcol('.'))"
                            
                              if l:skip =~# '^[sSrR]:'
                                let l:syn = strpart(l:skip, 2)
                            
                                let l:skip = { 's': l:cursyn."=~?'".l:syn."'", 'S': l:cursyn."!~?'".l:syn."'", 'r': l:preline."=~?'".l:syn."'", 'R': l:preline."!~?'".l:syn."'",}[l:skip[0]]
                              endif
                            
                              for [l:pat, l:str] in [ [ '\<col\ze(', 's:effcol'   ], [ '\<line\ze(', 's:effline' ], [ '\<getline\ze(', 's:geteffline' ],]
                                let l:skip = substitute(l:skip, l:pat, l:str, 'g')
                              endfor
                            
                              return l:skip

FUNCTION  <SNR>93_result_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:6
Called 41 times
Total time:   0.006686
 Self time:   0.001391

count  total (s)   self (s)
   41              0.000061   let l:kvs = []
  103              0.000179   for l:key in keys(a:args)
   62              0.000298     call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
  103              0.000064   endfor
                            
   41              0.000168   let l:result = type(a:x) isnot v:t_dict ? {'value': a:x} : a:x
                            
   41              0.000063   if empty(l:kvs)
                                return l:result
   41              0.000018   endif
                            
   41   0.005575   0.000280   return s:result(l:kvs, a:ctx, l:result)

FUNCTION  <SNR>33_GetFunctionPrefix()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:254
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000006   let res = "function! ".a:name."(...)"
    2              0.000004   if has_key(a:opts, 'range')
                                let res = res." range"
    2              0.000001   endif
    2              0.000003   return res."\n"

FUNCTION  <SNR>91_import_module()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:63
Called 4 times
Total time:   0.144532
 Self time:   0.000223

count  total (s)   self (s)
    4   0.144501   0.000192   let prog_version = system([a:prog, '-c' , printf( 'import sys; ' . 'sys.path = [p for p in sys.path if p != ""]; ' . 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' . 'import pkgutil; ' . 'exit(2*int(pkgutil.get_loader("%s") is None))', a:module)])
    4              0.000024   return [v:shell_error, prog_version]

FUNCTION  matchup#loader#remove_capture_groups()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:707
Called 285 times
Total time:   0.001310
 Self time:   0.001310

count  total (s)   self (s)
  285              0.000211   let l:sub_grp = '\(\\\@<!\(\\\\\)*\)\@<=\\('
  285              0.001025   return substitute(a:re, l:sub_grp, '\\%(', 'g')

FUNCTION  matchup#perf#tic()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/perf.vim:15
Called 766 times
Total time:   0.001676
 Self time:   0.001676

count  total (s)   self (s)
  766              0.001546   let s:time_start[a:context] = reltime()

FUNCTION  wilder#cmdline#getcompletion_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1119
Called 1 time
Total time:   0.000658
 Self time:   0.000128

count  total (s)   self (s)
    1   0.000031   0.000004   let [l:Filter, l:with_data, l:use_python, l:fuzzy] = s:get_opts(a:opts)
                            
                              " parsed cmdline
                              " : prepare_file_completion
                              " : s:getcompletion
                              " : map if relative_to_home_dir
                              " : fuzzy_filter if needed
                              " └--> result
    1   0.000291   0.000060   let l:file_completion_subpipeline = [ wilder#check({_, res -> wilder#cmdline#is_file_expansion(res.expand)}), {ctx, res -> wilder#cmdline#prepare_file_completion(ctx, res, l:fuzzy)}, wilder#subpipeline({ctx, res -> [   {ctx, res -> s:getcompletion(ctx, res, l:fuzzy, l:use_python)},   wilder#result({     'value': {ctx, xs, data -> l:fuzzy == 0 ?       s:filter_file_in_path(ctx, xs, data) : xs},   }),   wilder#result({     'value': {ctx, xs -> get(res, 'relative_to_home_dir', 0) ?       map(xs, {i, x -> fnamemodify(x, ':~')}) : xs},   }), ]}), wilder#if(l:fuzzy && !l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, xs, get(data, 'cmdline.path_prefix', '') . get(data, 'cmdline.match_arg', ''))}, })), wilder#if(l:fuzzy && l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, data, xs, get(data, 'cmdline.path_prefix', '') . get(data, 'cmdline.match_arg', ''))}, })), wilder#result({   'draw': ['wilder#cmdline#draw_path'],   'replace': ['wilder#cmdline#replace'], }), wilder#result_output_escape(' '), ]
                            
                              " parsed cmdline
                              " : prepare_completion
                              " : s:getcompletion
                              " : fuzzy_filter if needed
                              " └--> result
    1   0.000041   0.000022   let l:completion_subpipeline = [ {ctx, res -> wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)}, {ctx, res -> s:getcompletion(ctx, res, l:fuzzy, l:use_python)}, wilder#if(l:fuzzy && !l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))}, })), wilder#if(l:fuzzy && l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, data, xs, get(data, 'cmdline.match_arg', ''))}, })), wilder#result({   'replace': ['wilder#cmdline#replace'], }), ]
                            
    1   0.000057   0.000034   let l:lua_completion_subpipeline = [ wilder#check({_, res -> res.expand ==# 'lua'}), {ctx, res -> has('nvim-0.5') ? res : v:false}, {ctx, res -> s:get_lua_completion(ctx, res, l:fuzzy)}, wilder#if(l:fuzzy && !l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))}, })), wilder#if(l:fuzzy && l:with_data, wilder#result({   'value': {ctx, xs, data -> l:Filter(     ctx, data, xs, get(data, 'cmdline.match_arg', ''))}, })), ]
                            
                              " parsed cmdline
                              " : is file expansion?
                              " |--> file_completion_pipeline
                              " └--> completion_pipeline
    1   0.000234   0.000004   return [ wilder#branch(   l:lua_completion_subpipeline,   l:file_completion_subpipeline,   l:completion_subpipeline, ), ]

FUNCTION  remote#host#PluginsForHost()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/host.vim:177
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000002   if !has_key(s:plugins_for_host, a:host)
    1              0.000001     let s:plugins_for_host[a:host] = []
    2              0.000000   end
    2              0.000002   return s:plugins_for_host[a:host]

FUNCTION  <SNR>81_make_page()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:195
Called 43 times
Total time:   0.002392
 Self time:   0.001930

count  total (s)   self (s)
   43              0.000091   if empty(a:result.value)
   13              0.000019     return [-1, -1]
   30              0.000013   endif
                            
   30              0.000052   let l:page = a:state.page
   30              0.000046   let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
   30              0.000076   let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
   30              0.000076   if l:page != [-1, -1]
   14              0.000039     if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
   14              0.000037     elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
   14              0.000007     endif
   30              0.000013   endif
                            
   30              0.000043   if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
   14              0.000057     if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
   14              0.000016       return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
   16              0.000007   endif
                            
                              " Otherwise make a new page.
                            
   16   0.000483   0.000140   let l:max_height = a:state.get_max_height(a:ctx, a:result)
   16   0.000206   0.000087   let l:min_height = a:state.get_min_height(a:ctx, a:result)
   16              0.000024   if l:max_height < l:min_height
                                let l:max_height = l:min_height
   16              0.000006   endif
   16              0.000041   let l:max_height -= len(a:state.top)
   16              0.000031   let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
   16              0.000073   let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
   16              0.000019   if a:ctx.direction >= 0
   16              0.000024     let l:start = l:selected
                            
                                " Try to include all candidates after selected.
   16              0.000042     let l:height = len(a:result.value) - l:selected
                            
   16              0.000021     if l:height > l:max_height
                                  let l:height = l:max_height
   16              0.000007     endif
                            
   16              0.000037     return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]

FUNCTION  <SNR>78_search_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:485
Called 1 time
Total time:   0.000217
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000001   let l:opts = a:0 > 0 ? a:1 : {}
                            
    1   0.000184   0.000021   let l:search_pipeline = get(l:opts, 'pipeline', [ wilder#vim_substring(), wilder#vim_search(), wilder#result_output_escape('^$*~[]/\'), ])
                            
    1              0.000002   let l:skip_cmdtype_check = get(l:opts, 'skip_cmdtype_check', 0)
                            
    1              0.000001   let l:should_debounce = get(l:opts, 'debounce', 0) > 0
    1              0.000002   let l:Debounce = l:should_debounce ? wilder#debounce(l:opts['debounce']) : 0
                            
    1   0.000026   0.000013   return [ wilder#if(!l:skip_cmdtype_check,   wilder#check({-> getcmdtype() ==# '/' || getcmdtype() ==# '?'})), wilder#if(l:should_debounce, l:Debounce), wilder#subpipeline({ctx, x -> l:search_pipeline + [  wilder#result({    'data': {ctx, data -> s:set_query(data, x)},  }), ]}) ]

FUNCTION  provider#Poll()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider.vim:6
Called 1 time
Total time:   0.070418
 Self time:   0.070418

count  total (s)   self (s)
    1              0.000004   let job = {'rpc': v:true, 'stderr_buffered': v:true}
    1              0.000001   if a:0
    1              0.000005     let job = extend(job, a:1)
    1              0.000000   endif
    1              0.000000   try
    1              0.000367     let channel_id = jobstart(a:argv, job)
    1              0.070024     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
    1              0.000006       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
    1              0.000001   endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)

FUNCTION  wilder#options#set()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim:33
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000003   if len(a:000) == 0
                                call extend(s:opts, a:x)
    3              0.000001   else
    3              0.000004     let s:opts[a:x] = a:1
    3              0.000001   endif

FUNCTION  <SNR>22_close_floating_win()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:928
Called 341 times
Total time:   0.000540
 Self time:   0.000540

count  total (s)   self (s)
  341              0.000302   if !exists('s:float_id')
  341              0.000114     return
                              endif
                              if win_id2win(s:float_id) > 0
                                call s:do_popup_autocmd_leave(s:float_id)
                                call nvim_win_close(s:float_id, 0)
                              endif
                              let s:float_id = 0

FUNCTION  <SNR>62_expand()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:353
Called 120 times
Total time:   0.014719
 Self time:   0.006622

count  total (s)   self (s)
  120              0.000124   let components = []
  120              0.000088   let expanded = []
  120              0.000087   let indices = []
  120              0.000076   let prevtype = ''
  120              0.000095   let previndex = -1
  120              0.000076   let xs = []
  120   0.009212   0.001115   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
  187              0.000473   for [component, expand, type, index] in xs
   67              0.000069     if prevtype !=# type
   64              0.000202       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
   64              0.000026       endfor
   64              0.000090       call add(indices, type)
   64              0.000067       call add(components, [])
   64              0.000086       call add(expanded, [])
   67              0.000041     endif
   67              0.000122     call extend(components[-1], component)
   67              0.000220     call extend(expanded[-1], repeat([expand], len(component)))
   67              0.000061     let prevtype = type
   67              0.000061     let previndex = index
  187              0.000235   endfor
  120              0.000398   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
  120              0.000047   endfor
  120              0.000357   call add(indices, string(len(a:components)))
  120              0.000139   return [components, expanded, indices]

FUNCTION  provider#python3#Prog()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/python3.vim:13
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return s:prog

FUNCTION  <SNR>89_is_prefix()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1480
Called 36 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
   36              0.000047   if empty(a:q)
    6              0.000003     return 1
   30              0.000011   endif
                            
   30              0.000060   if len(a:q) > len(a:str)
    3              0.000002     return 0
   27              0.000009   endif
                            
   27              0.000073   return a:str[0 : len(a:q) - 1] ==# a:q

FUNCTION  remote#define#request()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:194
Called 2 times
Total time:   0.010503
 Self time:   0.010503

count  total (s)   self (s)
    2              0.000013   let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
    2              0.010421   let val = call('rpcrequest', [a:chan]+a:000)
    2              0.000021   let s:busy[a:chan] -= 1
    2              0.000007   if s:busy[a:chan] == 0
    2              0.000014     for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
    2              0.000003     endfor
    2              0.000006     let s:pending_notifications[a:chan] = []
    2              0.000001   endif
    2              0.000003   return val

FUNCTION  matchup#ts_engine#is_hl_enabled()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/ts_engine.vim:24
Called 3 times
Total time:   0.000073
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000005   if !has('nvim-0.5.0')
                                return 0
    3              0.000001   endif
    3   0.000064   0.000026   return +s:forward('is_hl_enabled', a:bufnr)

FUNCTION  <SNR>50_parse_args()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/pos.vim:124
Called 1530 times
Total time:   0.016516
 Self time:   0.010256

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
 1530              0.001113   if len(a:args) > 1
  676              0.000815     return s:parse_args([a:args])
  854              0.000602   elseif len(a:args) == 1
  854              0.001493     if type(a:args[0]) == type({})
   89              0.000164       return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
  765              0.000185     else
  765              0.000551       if len(a:args[0]) == 2
                                    return a:args[0]
  765              0.000154       else
  765              0.000665         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  <SNR>89_get_opts()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1090
Called 2 times
Total time:   0.146008
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000002   if has_key(a:opts, 'language')
                                let l:use_python = a:opts['language'] ==# 'python'
    2              0.000002   elseif has_key(a:opts, 'use_python')
                                let l:use_python = a:opts['use_python']
    2              0.000000   else
    2   0.145979   0.000007     let l:use_python = wilder#options#get('use_python_remote_plugin')
    2              0.000000   endif
                            
    2              0.000002   let l:fuzzy = get(a:opts, 'fuzzy', 0)
    2              0.000001   let l:with_data = 0
    2              0.000001   if l:fuzzy
                                if has_key(a:opts, 'fuzzy_filter_with_data')
                                  let l:with_data = 1
                                  let l:Filter = a:opts['fuzzy_filter_with_data']
                                elseif has_key(a:opts, 'fuzzy_filter')
                                  let l:Filter = a:opts['fuzzy_filter']
                                elseif l:use_python
                                  let l:Filter = wilder#python_fuzzy_filter()
                                else
                                  let l:Filter = wilder#vim_fuzzy_filter()
                                endif
    2              0.000000   else
    2              0.000001     let l:Filter = 0
    2              0.000000   endif
                            
    2              0.000003   return [l:Filter, l:with_data, l:use_python, l:fuzzy]

FUNCTION  <SNR>85_scrollbar()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:17
Called 16 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   16              0.000040   let [l:start, l:end] = a:ctx.page
   16              0.000036   let l:num_candidates = len(a:result.value)
   16              0.000031   let l:height = a:ctx.height
                            
   16              0.000023   if l:num_candidates <= l:height
   16              0.000015     if a:state.collapse
   16              0.000013       return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
                              endif
                            
                              let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
                              let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
                              let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
                              if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
                              endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
                              if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
                              endif
                            
                              let l:thumb_chunk = a:state.thumb_chunk
                              let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
                              let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
                              let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
                              let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
                              return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks

FUNCTION  wilder#branch()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:181
Called 3 times
Total time:   0.000243
 Self time:   0.000075

count  total (s)   self (s)
    3   0.000242   0.000074   return wilder#pipe#branch#(a:000)

FUNCTION  <SNR>96_do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:248
Called 25 times
Total time:   0.030663
 Self time:   0.002857

count  total (s)   self (s)
   25              0.000238   if !s:active || !s:enabled
    1              0.000003     return
   24              0.000042   endif
                            
   24   0.000659   0.000244   if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
   24              0.000013   endif
                            
   24   0.000497   0.000323   let l:input = s:getcmdline()
                            
   24              0.000077   let l:has_completion = l:input ==# s:completion
   24              0.000114   let l:is_new_input = s:previous_cmdline is v:null
   24              0.000096   let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
   24              0.000132   let l:should_keep_completion = s:completion_from_reject_completion isnot v:null && s:completion_from_reject_completion ==# l:input
                            
   24              0.000051   if !l:has_completion && !l:should_keep_completion
   24              0.000060     let s:completion = v:null
   24              0.000040     let s:replaced_cmdline = v:null
   24              0.000066     let s:completion_stack = []
   24              0.000015   endif
                            
   24              0.000027   if !l:should_keep_completion
   24              0.000044     let s:completion_from_reject_completion = v:null
   24              0.000011   endif
                            
   24              0.000050   if s:previous_cmdline is v:null || l:input_changed
   24              0.000038     let s:previous_cmdline = l:input
   24              0.000010   endif
                            
   24              0.000035   let s:draw_done = 0
                            
   24              0.000054   if !l:has_completion && (l:input_changed || l:is_new_input)
   24   0.016072   0.000327     call s:run_pipeline(l:input)
                            
   24              0.000029     if !s:draw_done
   19   0.011605   0.000134       call s:draw()
   24              0.000012     endif
   24              0.000011   endif
                            
   24              0.000032   let s:force = 0

FUNCTION  wilder#cmdline#main#skip_nonwhitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:699
Called 9 times
Total time:   0.002330
 Self time:   0.002185

count  total (s)   self (s)
    9              0.000025   if empty(a:ctx.cmdline[a:ctx.pos])
    1              0.000000     return 0
    8              0.000004   endif
                            
   31   0.000403   0.000258   while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
   28              0.000033     let a:ctx.pos += 1
                            
   28              0.000057     if empty(a:ctx.cmdline[a:ctx.pos])
    5              0.000004       return 0
   23              0.000010     endif
   26              0.001722   endwhile
                            
    3              0.000003   return 1

FUNCTION  wilder#lua#wrap()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:9
Called 1992 times
Total time:   0.055243
 Self time:   0.043656

count  total (s)   self (s)
 1992              0.008043   if type(a:t) is v:t_string || type(a:t) is v:t_number || type(a:t) is v:t_bool || a:t is v:null
 1701              0.002128     return a:t
  291              0.000245   endif
                            
  291              0.000436   if type(a:t) is v:t_func
   53   0.005336   0.000492     return s:wrap_function(a:t)
  238              0.000095   endif
                            
  238              0.000333   if type(a:t) is v:t_dict
  915              0.001797     for l:key in keys(a:t)
  778              0.001232       let l:Value = a:t[l:key]
  778              0.001497       let a:t[l:key] = wilder#lua#wrap(l:Value)
  915              0.000432     endfor
  238              0.000103   endif
                            
                              " v:t_list
  238              0.003028   return map(a:t, {_, x -> wilder#lua#wrap(x)})

FUNCTION  wilder#renderer#call_component_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:74
Called 15 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   15              0.000028   if type(a:component) is v:t_dict && has_key(a:component, 'pre_hook')
                                call a:component['pre_hook'](a:ctx)
   15              0.000004   endif

FUNCTION  <SNR>47_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/syntax/synload.vim:26
Called 5 times
Total time:   0.007136
 Self time:   0.007136

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    5              0.000013   syn clear
    5              0.000021   if exists("b:current_syntax")
                                unlet b:current_syntax
    5              0.000003   endif
                            
    5              0.000019   0verbose let s = expand("<amatch>")
    5              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    5              0.000004   elseif s == "OFF"
                                let s = ""
    5              0.000001   endif
                            
    5              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    6              0.000016     for name in split(s, '\.')
    3              0.000004       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    3              0.006965         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    3              0.000004       endif
    6              0.000004     endfor
    5              0.000002   endif

FUNCTION  lightline#tab#modified()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline/tab.vim:18
Called 59 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
   59              0.000066   let winnr = tabpagewinnr(a:n)
   59              0.000319   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'

FUNCTION  wilder#pipe#result#escape_output_result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:69
Called 2 times
Total time:   0.000022
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000022   0.000010   return wilder#result({ 'output': ['wilder#pipe#result#escape_output'], 'data': {ctx, data -> s:set_data(data, a:chars)}, })

FUNCTION  matchup#perf#timeout_start()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/perf.vim:84
Called 338 times
Total time:   0.001150
 Self time:   0.001150

count  total (s)   self (s)
  338              0.000277   let s:timeout = a:timeout
  338              0.000414   let s:timeout_enabled = (a:timeout == 0) ? 0 : 1
  338              0.000364   let s:timeout_pulse_time = reltime()

FUNCTION  wilder#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:55
Called 19 times
Total time:   0.000577
 Self time:   0.000370

count  total (s)   self (s)
   19              0.000034   if !a:0
                                return wilder#pipeline#wait(a:f)
   19              0.000025   elseif a:0 == 1
   19   0.000444   0.000237     return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif

FUNCTION  <SNR>81_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:698
Called 3 times
Total time:   0.000696
 Self time:   0.000286

count  total (s)   self (s)
    3   0.000348   0.000029   call a:state.api.hide()
                            
   18              0.000071   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   15   0.000218   0.000128     call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
   18              0.000010   endfor
                            
    3              0.000014   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    3              0.000006   let a:state.active = 0

FUNCTION  highlighturl#get_url_highlight()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:25
Called 1 time
Total time:   0.000065
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000001   let cursor = a:cursor ? '_cursor' : ''
    1   0.000029   0.000022   let term = s:get('term' . cursor, s:get('term_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
    1   0.000011   0.000005   let cterm = s:get('cterm' . cursor, s:get('cterm_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
    1   0.000005   0.000003   let ctermfg = s:get('ctermfg' . cursor, &background ==# 'dark' ? '44' : '31')
    1   0.000010   0.000005   let gui = s:get('gui' . cursor, s:get('gui_underline', s:get('underline', 1)) ? 'underline' : 'NONE')
    1   0.000005   0.000003   let guifg = s:get('guifg' . cursor, &background ==# 'dark' ? '#00dfdf' : '#002f5f')
    1              0.000003   return 'term=' . term . ' cterm=' . cterm . ' ctermfg=' . ctermfg . ' gui=' . gui . ' guifg=' . guifg

FUNCTION  matchup#loader#refresh_match_words()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:107
Called 336 times
Total time:   0.006447
 Self time:   0.006447

count  total (s)   self (s)
  336              0.001111   if get(b:, 'match_words', ':') !~# ':'
                                call matchup#perf#tic('refresh')
                            
                                " protect the cursor from the match_words function
                                let l:save_pos = matchup#pos#get_cursor()
                                let l:match_words = ''
                                execute 'let l:match_words =' b:match_words
                                if l:save_pos != matchup#pos#get_cursor()
                                  call matchup#pos#set_cursor(l:save_pos)
                                endif
                            
                                call matchup#perf#toc('refresh', 'function')
                            
                                if has_key(s:match_word_cache, l:match_words)
                                  let b:matchup_delim_lists = s:match_word_cache[l:match_words].delim_lists
                                  let b:matchup_delim_re = s:match_word_cache[l:match_words].delim_regexes
                                  call matchup#perf#toc('refresh', 'cache_hit')
                                else
                                  " re-parse match words
                                  let b:matchup_delim_lists = s:init_delim_lists(0, 0)
                                  let b:matchup_delim_re = s:init_delim_regexes()
                                  let s:match_word_cache[l:match_words] = { 'delim_lists'  : b:matchup_delim_lists, 'delim_regexes': b:matchup_delim_re,}
                                  call matchup#perf#toc('refresh', 'parse')
                                endif
  336              0.000062   endif

FUNCTION  <SNR>87_clear_all_highlights()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:255
Called 16 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
   16              0.000049   if !bufexists(self.state.buf)
                                return
   16              0.000006   endif
                            
   16              0.000082   call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)

FUNCTION  <SNR>62_subseparator()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:300
Called 3 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000010   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
    3              0.000049   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
    3              0.000015   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  wilder#renderer#pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:52
Called 30 times
Total time:   0.001462
 Self time:   0.001147

count  total (s)   self (s)
   30              0.000049   let l:should_draw = 0
                            
  120              0.000144   for l:Component in a:components
   90   0.000977   0.000661     let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
  120              0.000125   endfor
                            
   30              0.000033   return l:should_draw

FUNCTION  wilder#pipeline#clear_handlers()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:6
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000015   let s:last_cleared_id = s:id_index
    3              0.000011   let s:handler_registry = {}
    3              0.000007   let s:partial_results = {}

FUNCTION  wilder#options#get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim:13
Called 4 times
Total time:   0.145984
 Self time:   0.000189

count  total (s)   self (s)
    4              0.000002   if !a:0
    1              0.000001     return s:opts
    3              0.000001   endif
                            
    3              0.000006   if a:1 ==# 'use_python_remote_plugin' && !has_key(s:opts, 'use_python_remote_plugin')
    1   0.145951   0.000156     if !has('python3')
                                  let s:opts.use_python_remote_plugin = 0
    1              0.000002     elseif has('nvim')
    1              0.000001       let s:opts.use_python_remote_plugin = 1
                                else
                                  let l:file = findfile('autoload/yarp.vim', &rtp)
                                  let s:opts.use_python_remote_plugin = !empty(l:file)
    1              0.000000     endif
    3              0.000001   endif
                            
    3              0.000002   return s:opts[a:1]

FUNCTION  matchup#perf#toc()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/perf.vim:19
Called 1369 times
Total time:   0.016297
 Self time:   0.016297

count  total (s)   self (s)
 1369              0.003001   let l:elapsed = s:Reltimefloat(reltime(s:time_start[a:context]))
                            
 1369              0.001491   let l:key = a:context.'#'.a:state
 1369              0.001546   if has_key(g:matchup#perf#times, l:key)
 1364              0.001600     if l:elapsed > g:matchup#perf#times[l:key].maximum
   19              0.000027       let g:matchup#perf#times[l:key].maximum = l:elapsed
 1364              0.000265     endif
 1364              0.001487     let g:matchup#perf#times[l:key].last = l:elapsed
 1364              0.002941     let g:matchup#perf#times[l:key].emavg = s:alpha*l:elapsed + (1-s:alpha)*g:matchup#perf#times[l:key].emavg
    5              0.000001   else
    5              0.000011     let g:matchup#perf#times[l:key] = { 'maximum' : l:elapsed, 'emavg'   : l:elapsed, 'last'    : l:elapsed,}
 1369              0.000248   endif

FUNCTION  highlighturl#set_highlight()
    Defined: ~/.local/share/nvim/lazy/vim-highlighturl/autoload/highlighturl.vim:35
Called 1 time
Total time:   0.000082
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000080   0.000003   call highlighturl#set_url_highlight()
    1              0.000001   if s:urlcursor
                                call highlighturl#set_urlcursor_highlight()
    1              0.000000   endif

FUNCTION  <SNR>86_combine_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:71
Called 8 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
    8              0.000013   let l:term_hl = copy(a:l[0])
    8              0.000010   let l:cterm_hl = copy(a:l[1])
    8              0.000009   let l:gui_hl = copy(a:l[2])
                            
    8              0.000009   if len(l:term_hl) <= 2
    8              0.000011     let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
    8              0.000002   endif
                            
    8              0.000012   let l:cterm_fg = get(a:m[1], 0, -1)
    8              0.000014   if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
    8              0.000002   endif
                            
    8              0.000010   let l:cterm_bg = get(a:m[1], 1, -1)
    8              0.000007   if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
    8              0.000002   endif
                            
    8              0.000008   if len(a:m[1]) > 2
    8              0.000008     if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
    8              0.000002     else
    8              0.000014       let l:cterm_hl += a:m[1][2:]
    8              0.000002     endif
    8              0.000002   endif
                            
    8              0.000011   let l:gui_fg = get(a:m[2], 0, -1)
    8              0.000008   if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
                                else
                                  let l:gui_hl[0] = l:gui_fg
                                endif
    8              0.000002   endif
                            
    8              0.000010   let l:gui_bg = get(a:m[2], 1, -1)
    8              0.000007   if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
    8              0.000002   endif
                            
    8              0.000007   if len(a:m[2]) > 2
    8              0.000006     if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
    8              0.000002     else
    8              0.000011       let l:gui_hl += a:m[2][2:]
    8              0.000002     endif
    8              0.000002   endif
                            
    8              0.000009   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>81_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:682
Called 3 times
Total time:   0.000843
 Self time:   0.000273

count  total (s)   self (s)
    3   0.000355   0.000046   call a:state.api.new({ 'normal_highlight': a:state.highlights.default, 'zindex': get(a:state, 'zindex', 0), 'pumblend': get(a:state, 'pumblend', -1) })
                            
   18              0.000029   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   15   0.000424   0.000163     call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
   18              0.000018   endfor
                            
    3              0.000004   let a:state.active = 1
    3              0.000002   let a:state.is_first_draw = 1

FUNCTION  <SNR>92_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/subpipeline.vim:18
Called 1 time
Total time:   0.000022
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003   let l:ctx = copy(a:ctx)
    1              0.000003   let l:ctx.handler_id = a:handler_id
                            
    1   0.000015   0.000006   call wilder#resolve(l:ctx, a:x)

FUNCTION  <SNR>88_check()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:5
Called 81 times
Total time:   0.002101
 Self time:   0.001669

count  total (s)   self (s)
   81              0.000116   let l:i = 0
                            
  120              0.000308   for l:Check in a:checks
   81   0.001182   0.000750     if !l:Check(a:ctx, a:x)
   42              0.000044       return v:false
   39              0.000019     endif
   78              0.000071   endfor
                            
   39              0.000045   return a:x

FUNCTION  wilder#cmdline#skip_range#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim:3
Called 19 times
Total time:   0.001127
 Self time:   0.001127

count  total (s)   self (s)
   19              0.000169   while a:ctx.pos < len(a:ctx.cmdline) && stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' || l:second_char ==# '/' || l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
   19              0.000045   endwhile

FUNCTION  <SNR>77_wrap_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:32
Called 53 times
Total time:   0.004843
 Self time:   0.004843

count  total (s)   self (s)
   53              0.000112   let l:index = s:index
   53              0.000070   let s:index += 1
                            
   53              0.000155   let s:functions[l:index] = a:f
   53              0.000317   return { 'index': l:index, 'name': get(a:f, 'name'), '__wilder_wrapped__': s:token, }

FUNCTION  <SNR>22_add_matches()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/matchparen.vim:1176
Called 89 times
Total time:   0.008703
 Self time:   0.008029

count  total (s)   self (s)
   89              0.000096   if !exists('w:matchup_match_id_list')
   89              0.000073     let w:matchup_match_id_list = []
   89              0.000019   endif
                            
                              " if MatchwordCur is undefined and MatchWord links to MatchParen
                              " (as default), behave like MatchWordCur is the same as MatchParenCur
                              " otherwise, MatchWordCur is the same as MatchWord
   89              0.000034   if a:0
   89              0.000459     let l:mwc = hlexists('MatchWordCur') ? 'MatchWordCur' : (synIDtrans(hlID('MatchWord')) == hlID('MatchParen')     ? 'MatchParenCur' : 'MatchWord')
   89              0.000018   endif
                            
  267              0.000142   for l:corr in a:corrlist
  178              0.000177     if a:0 && l:corr.match_index == a:1.match_index
   89   0.000538   0.000240       let l:group = s:wordish(l:corr) ? l:mwc : 'MatchParenCur'
   89              0.000020     else
   89   0.000705   0.000329       let l:group = s:wordish(l:corr) ? 'MatchWord' : 'MatchParen'
  178              0.000039     endif
                            
  178              0.000136     if exists('s:ns_id')
  178              0.000478       if strlen(l:corr.match) == 0 && matchup#loader#_treesitter_may_be_supported() && !matchup#ts_engine#get_option(   bufnr('%'), 'disable_virtual_text')
                                    if hlexists('MatchupVirtualText')
                                      let l:group = 'MatchupVirtualText'
                                    endif
                                    call nvim_buf_set_extmark(0, s:ns_id, l:corr.lnum - 1, l:corr.cnum - 1, {   'virt_text': [[' ' . g:matchup_matchparen_end_sign . ' '                  . a:corrlist[0].match, l:group]],   'virt_text_pos': 'overlay'})
  178              0.000039       else
  178              0.000760         call nvim_buf_add_highlight(0, s:ns_id, l:group, l:corr.lnum - 1, l:corr.cnum - 1, l:corr.cnum - 1 + strlen(l:corr.match))
  178              0.000042       end
                                elseif exists('*matchaddpos')
                                  call add(w:matchup_match_id_list, matchaddpos(l:group, [[l:corr.lnum, l:corr.cnum, strlen(l:corr.match)]], 0))
                                else
                                  call add(w:matchup_match_id_list, matchadd(l:group, '\%'.(l:corr.lnum).'l\%'.(l:corr.cnum).'c' . '.\+\%<'.(l:corr.cnum+strlen(l:corr.match)+1).'c', 0))
  178              0.000053     endif
  267              0.000783   endfor

FUNCTION  wilder#popupmenu_renderer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:718
Called 1 time
Total time:   0.003700
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000002   let l:args = get(a:, 1, {})
                            
    1              0.000001   if !has_key(l:args, 'mode')
    1              0.000003     let l:args.mode = has('nvim-0.4') ? 'float' : 'popup'
    1              0.000000   endif
                            
    1   0.003693   0.000068   return wilder#renderer#popupmenu#(l:args)

FUNCTION  matchup#delim#skip()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:869
Called 178 times
Total time:   0.005266
 Self time:   0.001887

count  total (s)   self (s)
  178              0.000097   if a:0 >= 2
  178              0.000221     let [l:lnum, l:cnum] = [a:1, a:2]
                              else
                                let [l:lnum, l:cnum] = matchup#pos#get_cursor()[1:2]
  178              0.000032   endif
                            
  178              0.000251   if empty(get(b:, 'matchup_delim_skip', ''))
  178   0.004337   0.000958     return matchup#util#in_comment_or_string(l:lnum, l:cnum) ? !s:invert_skip : s:invert_skip
                              endif
                            
                              let s:eff_curpos = [l:lnum, l:cnum]
                              execute 'return' (s:invert_skip ? '!(' : '(') b:matchup_delim_skip ')'

FUNCTION  <SNR>81_make_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:446
Called 16 times
Total time:   0.012080
 Self time:   0.004868

count  total (s)   self (s)
   16              0.000055   let l:Highlighter = get(a:state, 'highlighter', [])
                            
   16              0.000024   let l:height = a:ctx.height
                            
   16              0.000016   if l:height > 0
   16   0.000314   0.000309     let l:left_column_chunks = map(repeat([0], l:height), {-> []})
   16   0.001595   0.000144     call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
   16   0.000134   0.000131     let l:right_column_chunks = map(repeat([0], l:height), {-> []})
   16   0.002249   0.000139     call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
   16              0.000007   endif
                            
                              " [[left_column, chunks, right_column]]
   16              0.000041   let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
   16              0.000034   let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
   16              0.000029   let [l:start, l:end] = a:state.page
   16              0.000015   let l:i = 0
   44              0.000046   while l:i < l:height
   28              0.000043     let l:index = l:start + l:i
   28              0.000030     if l:index <= l:end
   28   0.002300   0.000216       let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
   28              0.000010     endif
   28              0.000053     let l:left_column = l:left_column_chunks[l:i]
   28              0.000050     let l:right_column = l:right_column_chunks[l:i]
                            
   28   0.000678   0.000270     let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
   28   0.000585   0.000189     let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
   28   0.000465   0.000170     let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
   28              0.000064     let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
   28              0.000044     if l:total_width > a:state.longest_line_width
   17              0.000032       let a:state.longest_line_width = l:total_width
   28              0.000009     endif
                            
   28              0.000038     let l:index = l:i - l:start
   28              0.000078     let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
   28              0.000062     let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
   28              0.000025     let l:i += 1
   44              0.000039   endwhile
                            
   16   0.000343   0.000080   let l:max_width = a:state.get_max_width(a:ctx, a:result)
   16   0.000295   0.000100   let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
   16              0.000059   let l:expected_width = min([ l:max_width, a:state.longest_line_width, ])
   16              0.000026   if l:expected_width < l:min_width
   16              0.000025     let l:expected_width = l:min_width
   16              0.000007   endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
   16              0.000039   let l:lines = repeat([0], l:height)
                            
   16              0.000015   let l:i = 0
   44              0.000067   while l:i < len(l:raw_lines)
   28              0.000073     let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
   28              0.000054     let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
   28              0.000036     if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
   28              0.000035     elseif l:total_width < l:expected_width
   28              0.000045       let l:to_pad = l:expected_width - l:total_width
   28              0.000072       let l:chunks += [[repeat(' ', l:to_pad)]]
   28              0.000009     endif
                            
   28              0.000101     let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
   28              0.000023     let l:i += 1
   44              0.000035   endwhile
                            
   16              0.000026   return [l:lines, l:expected_width]

FUNCTION  lightline#onetab()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:470
Called 59 times
Total time:   0.003257
 Self time:   0.002296

count  total (s)   self (s)
   59              0.000043   let _ = []
  177              0.000202   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
  118              0.000176     if has_key(s:lightline.tab_component_function, name)
  118   0.001903   0.000942       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
                                else
                                  call add(_, get(s:lightline.tab_component, name, ''))
  118              0.000033     endif
  177              0.000088   endfor
   59              0.000218   return join(filter(_, 'v:val !=# ""'), ' ')

FUNCTION  <SNR>86_normalise_attrs()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:137
Called 24 times
Total time:   0.001249
 Self time:   0.001249

count  total (s)   self (s)
   24              0.000044   let l:attr_map = copy(s:attr_map)
                            
   56              0.000038   for l:attr in a:hl[2:]
   32              0.000034     if has_key(l:attr_map, l:attr)
   32              0.000033       let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
   32              0.000007     endif
   56              0.000017   endfor
                            
   24              0.000016   let l:result = []
  192              0.000105   for l:attr in keys(l:attr_map)
  168              0.000110     if l:attr_map[l:attr]
   32              0.000034       call add(l:result, l:attr)
  168              0.000036     endif
  192              0.000055   endfor
                            
   24              0.000030   return a:hl[:1] + l:result

FUNCTION  <SNR>84_clear()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:23
Called 48 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   48              0.000125   let self['_cache'] = {}

FUNCTION  matchup#ts_engine#is_enabled()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/ts_engine.vim:17
Called 3 times
Total time:   0.000131
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000007   if !has('nvim-0.5.0')
                                return 0
    3              0.000001   endif
    3   0.000121   0.000028   return +s:forward('is_enabled', a:bufnr)

FUNCTION  wilder#popupmenu_scrollbar()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:652
Called 1 time
Total time:   0.000248
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000001   let l:args = get(a:, 1, {})
    1   0.000241   0.000065   return wilder#renderer#component#popupmenu_scrollbar#(l:args)

FUNCTION  <SNR>84_has_key()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:19
Called 19 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   19              0.000077   return has_key(self['_cache'], a:key)

FUNCTION  <SNR>87_new_buf()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:59
Called 2 times
Total time:   0.000256
 Self time:   0.000198

count  total (s)   self (s)
    2   0.000124   0.000118   let l:buf = nvim_create_buf(v:false, v:true)
    2   0.000128   0.000076   call nvim_buf_set_name(l:buf, '[Wilder Float ' . s:index . ']')
    2              0.000002   let s:index += 1
                            
    2              0.000001   return l:buf

FUNCTION  wilder#cmdline_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:557
Called 1 time
Total time:   0.147681
 Self time:   0.000067

count  total (s)   self (s)
    1   0.147680   0.000067   return wilder#cmdline#pipeline(get(a:, 1, {}))

FUNCTION  <SNR>94_resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:48
Called 57 times
Total time:   0.001054
 Self time:   0.000765

count  total (s)   self (s)
   57              0.000293   let l:ctx = copy(a:ctx)
   57              0.000127   let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
   57   0.000589   0.000300   call wilder#resolve(l:ctx, a:x)

FUNCTION  <lambda>105()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 19 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <SNR>48_forward()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/ts_engine.vim:10
Called 6 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    6              0.000123   let l:ret = luaeval( 'require"treesitter-matchup.internal".' . a:fn . '(unpack(_A))', a:000)
    6              0.000005   return l:ret

FUNCTION  remote#host#RegisterPlugin()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/host.vim:69
Called 1 time
Total time:   0.000036
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000008   0.000004   let plugins = remote#host#PluginsForHost(a:host)
                            
    1              0.000001   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
    1              0.000000   endfor
                            
    1   0.000007   0.000004   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
    1              0.000000   endif
                            
    1              0.000001   for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
    1              0.000001   endfor
                            
    1              0.000003   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  wilder#lua#call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:5
Called 8 times
Total time:   0.153746
 Self time:   0.000154

count  total (s)   self (s)
    8   0.153745   0.000153   return wilder#lua#wrap(call(a:f, a:000))

FUNCTION  <lambda>5()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:843
Called 32 times
Total time:   0.000581
 Self time:   0.000289

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)

FUNCTION  <lambda>6()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 59 times
Total time:   0.001833
 Self time:   0.001675

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>7()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 16 times
Total time:   0.000263
 Self time:   0.000116

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <lambda>8()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 16 times
Total time:   0.000195
 Self time:   0.000074

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>9()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:13
Called 16 times
Total time:   0.000301
 Self time:   0.000118

count  total (s)   self (s)
                            return s:scrollbar(l:state, ctx, result)

FUNCTION  wilder#cmdline#prepare_user_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:617
Called 19 times
Total time:   0.000350
 Self time:   0.000246

count  total (s)   self (s)
   19   0.000290   0.000186   if !wilder#cmdline#is_user_command(a:res.cmd)
   19              0.000034     return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') && l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') && l:user_command['complete'] isnot v:null && l:user_command['complete'] !=# 'custom' && l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]

FUNCTION  wilder#renderer#redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:1
Called 16 times
Total time:   0.022555
 Self time:   0.000102

count  total (s)   self (s)
   16   0.022550   0.000098   call s:redraw(a:apply_incsearch_fix, 0)

FUNCTION  <SNR>86_get_attrs_as_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:209
Called 48 times
Total time:   0.002593
 Self time:   0.002593

count  total (s)   self (s)
   48              0.000034   let l:res = []
                            
  432              0.000190   for l:attr in s:attr_list
  384              0.000328     if has_key(a:attrs, l:attr)
   32              0.000020       if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
   32              0.000007       endif
                            
   32              0.000024       if a:attrs[l:attr]
   32              0.000036         call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
   32              0.000009       endif
  384              0.000080     endif
  432              0.000178   endfor
                            
   48              0.000025   return l:res

FUNCTION  <lambda>68()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 19 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>12()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 43 times
Total time:   0.012716
 Self time:   0.000480

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <lambda>13()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 3 times
Total time:   0.000860
 Self time:   0.000017

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <lambda>14()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 3 times
Total time:   0.000734
 Self time:   0.000038

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  wilder#renderer#component#popupmenu_scrollbar#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:1
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000001   let l:state = {}
                            
    1              0.000001   let l:thumb_char = get(a:opts, 'thumb_char', '█')
    1              0.000001   let l:thumb_hl = get(a:opts, 'thumb_hl', 'PmenuThumb')
    1              0.000001   let l:scrollbar_char = get(a:opts, 'scrollbar_char', ' ')
    1              0.000001   let l:scrollbar_hl = get(a:opts, 'scrollbar_hl', 'PmenuSbar')
                            
    1              0.000001   let l:state.thumb_chunk = [l:thumb_char, l:thumb_hl]
    1              0.000001   let l:state.scrollbar_chunk = [l:scrollbar_char, l:scrollbar_hl]
                            
    1              0.000001   let l:state.collapse = get(a:opts, 'collapse', 1)
                            
    1              0.000002   return {ctx, result -> s:scrollbar(l:state, ctx, result)}

FUNCTION  <SNR>51_get_delim()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:325
Called 336 times
Total time:   0.088778
 Self time:   0.046817

count  total (s)   self (s)
                              " arguments: {{{2
                              "   opts = {
                              "     'direction'   : 'next' | 'prev' | 'current'
                              "     'type'        : 'delim_tex'
                              "                   | 'delim_all'
                              "                   | 'all'
                              "     'side'        : 'open'     | 'close'
                              "                   | 'both'     | 'mid'
                              "                   | 'both_all' | 'open_mid'
                              "   }
                              "
                              "  }}}2
                              " returns: {{{2
                              "   delim = {
                              "     lnum     : line number
                              "     cnum     : column number
                              "     type     : e.g., 'delim_tex'
                              "     match    : the actual text match
                              "     side     : 'open' | 'close' | 'mid'
                              "     class    : [ c1, c2 ] identifies the kind of match_words
                              "     skip     : skip state
                              "     get_matching: callback used to get matching delims
                              "     highlighting: whether the request was for highlighting
                              "
                              "     ... Parser dependent ...
                              "     augment  : how to match a corresponding open
                              "     groups   : dict of captured groups
                              "     regexone : the regex items, like \1foo
                              "     regextwo : the regex_capture items, like \(group\)foo
                              "     midmap   : ??
                              "   }
                              "
                              " }}}2
                            
  336              0.000428   if !get(b:, 'matchup_delim_enabled', 0)
                                return {}
  336              0.000065   endif
                            
  336              0.000714   if has('*state') && state('a') !=# '' | return {} | endif
                            
  336   0.004876   0.004192   call matchup#perf#tic('s:get_delim')
                            
  336   0.001135   0.000857   let l:save_pos = matchup#pos#get_cursor()
                            
  336   0.007482   0.001035   call matchup#loader#refresh_match_words()
                            
                              " this contains all the patterns for the specified type and side
  336              0.000654   let l:re = b:matchup_delim_re[a:opts.type][a:opts.side]
                            
  336              0.000404   let l:cursorpos = col('.')
                            
  336              0.000429   let l:insertmode = get(a:opts, 'insertmode', 0)
  336              0.000305   if l:cursorpos > 1 && l:insertmode
                                let l:cursorpos -= 1
  336              0.000062   endif
  336              0.000928   if l:cursorpos > strlen(getline('.')) && stridx("vV\<c-v>", mode()) > -1
                                let l:cursorpos -= 1
  336              0.000055   endif
                            
  336   0.001321   0.001005   call matchup#delim#set_invert_skip(0)
                            
  336              0.000249   if a:opts.direction ==# 'current'
  336              0.001226     let l:check_skip = get(a:opts, 'check_skip', g:matchup_delim_noskips >= 2 || g:matchup_delim_noskips >= 1     && getline(line('.'))[l:cursorpos-1] =~? '[^[:punct:]]')
  336              0.000454     if l:check_skip && matchup#delim#skip(line('.'), l:cursorpos)
                                  return {}
  336              0.000069     endif
                              else
                                " check skip if cursor is not currently in skip
                                let l:check_skip = get(a:opts, 'check_skip', !matchup#delim#skip(line('.'), l:cursorpos) || g:matchup_delim_noskips >= 2)
  336              0.000063   endif
                            
  336              0.000307   let a:opts.cursorpos = l:cursorpos
                            
                              " for current, we want to find matches that end after the cursor
                              " note: we expect this to give false-positives with \ze
  336              0.000184   if a:opts.direction ==# 'current'
  336              0.000641     let l:re .= '\%>'.(l:cursorpos).'c'
  336              0.000070   endif
                            
                              " allow overlapping delimiters
                              " without this, the > in <tag> would not be found
  336              0.000541   if b:matchup_delim_re[a:opts.type]._engine_info.has_zs[a:opts.side]
                                let l:save_cpo = &cpo
                                noautocmd set cpo-=c
  336              0.000088   else
                                " faster than changing cpo but doesn't work right with \zs
  336              0.000248     let l:re .= '\&'
  336              0.000067   endif
                            
  336              0.000271   let l:need_restore_cursor = 0
                            
                              " stopline may depend on the current action
  336              0.000449   let l:stopline = get(a:opts, 'stopline', s:stopline)
                            
                              " in the first pass, we get matching line and column numbers
                              " this is intended to be as fast as possible, with no capture groups
                              " we look for a match on this line (if direction == current)
                              " or forwards or backwards (if direction == next or prev)
                              " for current, we actually search leftwards from the cursor
  336              0.000180   while 1
  336   0.001357   0.000969     let l:to = matchup#perf#timeout()
  336              0.009303     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + l:stopline, l:to) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW',               max([line('.') - l:stopline, 1]), l:to)   : searchpos(l:re, l:insertmode ? 'bnW' : 'bcnW',               line('.'), l:to)
  336              0.000517     if l:lnum == 0 | break | endif
                            
                                " note: the skip here should never be called
                                " in 'current' mode, but be explicit
   89              0.000565     if a:opts.direction !=# 'current' && (l:check_skip || g:matchup_delim_noskips == 1     && getline(l:lnum)[l:cnum-1] =~? '[^[:punct:]]'     || g:matchup_delim_noskips >= 2) && matchup#delim#skip(l:lnum, l:cnum) && (a:opts.direction ==# 'prev' ? (l:lnum > 1 || l:cnum > 1)     : (l:lnum < line('$') || l:cnum < len(getline('$'))))
                            
                                  " invalid match, move cursor and keep looking
                                  call matchup#pos#set_cursor(a:opts.direction ==# 'next' ? matchup#pos#next(l:lnum, l:cnum) : matchup#pos#prev(l:lnum, l:cnum))
                                  let l:need_restore_cursor = 1
                                  continue
   89              0.000018     endif
                            
   89              0.000024     break
  336              0.000299   endwhile
                            
                              " restore cpo if necessary
                              " note: this messes with cursor position
  336              0.000294   if exists('l:save_cpo')
                                noautocmd let &cpo = l:save_cpo
                                let l:need_restore_cursor = 1
  336              0.000066   endif
                            
                              " restore cursor
  336              0.000174   if l:need_restore_cursor
                                call matchup#pos#set_cursor(l:save_pos)
  336              0.000058   endif
                            
  336   0.006436   0.001490   call matchup#perf#toc('s:get_delim', 'first_pass')
                            
                              " nothing found, leave now
  336              0.000157   if l:lnum == 0
  247   0.003302   0.000765     call matchup#perf#toc('s:get_delim', 'nothing_found')
  247              0.000128     return {}
   89              0.000014   endif
                            
   89   0.000969   0.000350   if matchup#perf#timeout_check()
                                return {}
   89              0.000014   endif
                            
   89              0.000059   let l:skip_state = 0
   89              0.000114   if !l:check_skip && (!&synmaxcol || l:cnum <= &synmaxcol)
                                " XXX: workaround an apparent obscure vim bug where the
                                " reported syntax id is incorrect on the first synID() call
   89   0.003997   0.000431     call matchup#delim#skip(l:lnum, l:cnum)
   89   0.000887   0.000395     if matchup#perf#timeout_check()
                                  return {}
   89              0.000017     endif
                            
   89   0.002049   0.000349     let l:skip_state = matchup#delim#skip(l:lnum, l:cnum)
   89              0.000021   endif
                            
                              " now we get more data about the match in this position
                              " there may be capture groups which need to be stored
                            
                              " result stub, to be filled by the parser when there is a match
   89              0.000312   let l:result = { 'lnum'     : l:lnum, 'cnum'     : l:cnum, 'type'     : '', 'match'    : '', 'side'     : '', 'class'    : [], 'skip'     : l:skip_state,}
                            
   89              0.000206   for l:P in s:engines.classic.parsers[a:opts.type]
   89   0.019311   0.000450     let l:parser_result = l:P(l:lnum, l:cnum, a:opts)
   89              0.000082     if !empty(l:parser_result)
   89              0.000317       let l:result = extend(l:parser_result, l:result, 'keep')
   89              0.000024       break
                                endif
   89              0.000038   endfor
                            
   89   0.001457   0.000332   call matchup#perf#toc('s:get_delim', 'got_results')
                            
   89              0.000113   return empty(l:result.type) ? {} : l:result

FUNCTION  <SNR>21_init_delim_regexes_generator()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/loader.vim:616
Called 3 times
Total time:   0.001098
 Self time:   0.000978

count  total (s)   self (s)
    3              0.000006   let l:list = b:matchup_delim_lists[a:list_name].regex_capture
                            
                              " build the full regex strings: order matters here
    3              0.000003   let l:regexes = {}
   21              0.000026   for [l:key, l:sidelist] in items(s:sidedict)
   18              0.000015     let l:relist = []
                            
   90              0.000039     for l:set in l:list
  192              0.000091       for l:side in l:sidelist
  120              0.000118         if strlen(l:set[l:side])
   84              0.000106           call add(l:relist, l:set[l:side])
  120              0.000029         endif
  192              0.000063       endfor
   90              0.000020     endfor
                            
   18   0.000247   0.000126     let l:regexes[l:key] = matchup#loader#remove_capture_groups( '\%(' . join(l:relist, '\|') . '\)')
   21              0.000051   endfor
                            
    3              0.000002   return l:regexes

FUNCTION  _wilder_init()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:169
Called 1 time
Total time:   0.001291
 Self time:   0.000005

count  total (s)   self (s)
    1   0.001290   0.000005 return remote#define#request(4, "/Users/klasseg/.local/share/nvim/lazy/wilder.nvim/rplugin/python3/wilder:function:_wilder_init", a:000)

FUNCTION  wilder#cmdline#is_file_expansion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:600
Called 38 times
Total time:   0.000251
 Self time:   0.000251

count  total (s)   self (s)
   38              0.000219   return a:expand ==# 'file' || a:expand ==# 'file_in_path' || a:expand ==# 'dir' || a:expand ==# 'shellcmd' || a:expand ==# 'user'

FUNCTION  <SNR>84_mru_update()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:56
Called 19 times
Total time:   0.000950
 Self time:   0.000950

count  total (s)   self (s)
   19              0.000053   let l:queue = self['_queue']
   19              0.000039   let l:counts = self['_counts']
                            
   19              0.000223   call add(l:queue, a:key)
   19              0.000124   if !has_key(l:counts, a:key)
   19              0.000043     let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
   19              0.000009   endif
                            
   19              0.000051   if len(l:queue) > self['_max_size']
                                let l:removed_key = remove(l:queue, 0)
                                let l:counts[l:removed_key] -= 1
                            
                                if l:counts[l:removed_key] == 0
                                  unlet l:counts[l:removed_key]
                                  unlet self['_cache'][l:removed_key]
                                endif
   19              0.000008   endif

FUNCTION  matchup#perf#timeout_check()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/perf.vim:91
Called 267 times
Total time:   0.001626
 Self time:   0.001626

count  total (s)   self (s)
  267              0.000319   if !s:timeout_enabled | return 0 | endif
  267              0.000583   let l:elapsed = 1000.0 * s:Reltimefloat(reltime(s:timeout_pulse_time))
  267              0.000207   let s:timeout -= l:elapsed
  267              0.000247   let s:timeout_pulse_time = reltime()
  267              0.000166   return s:timeout <= 0.0

FUNCTION  <lambda>23()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 24 times
Total time:   0.001125
 Self time:   0.000349

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>25()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1325
Called 19 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            return res[0] ? res : v:false

FUNCTION  <lambda>28()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1344
Called 19 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            return res[2]

FUNCTION  <lambda>29()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 19 times
Total time:   0.000315
 Self time:   0.000176

count  total (s)   self (s)
                            return wilder#cmdline#is_file_expansion(res.expand)

FUNCTION  <SNR>89_sort_buffers_lastused()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1398
Called 19 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   19              0.000061   if get(a:data, 'cmdline.expand', '') !=# 'buffer'
   19              0.000020     return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed || empty(l:bufname) || has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})

FUNCTION  wilder#if()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:197
Called 12 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
   12              0.000005   if !a:condition
   11              0.000009     return {_, x -> x}
    1              0.000000   endif
                            
    1              0.000001   return {ctx, x -> a:p(ctx, x)}

FUNCTION  wilder#cmdline#profile#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/profile.vim:1
Called 9 times
Total time:   0.002609
 Self time:   0.000234

count  total (s)   self (s)
    9              0.000019   let l:arg_start = a:ctx.pos
                            
    9   0.002451   0.000121   if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
    6              0.000007     let a:ctx.expand = 'profile'
    6              0.000008     let a:ctx.pos = l:arg_start
    6              0.000004     return
    3              0.000002   endif
                            
    3              0.000011   let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                            
    3              0.000005   if l:subcommand ==# 'start'
    1              0.000001     let a:ctx.expand = 'files'
    1   0.000053   0.000008     call wilder#cmdline#main#skip_whitespace(a:ctx)
    3              0.000002   endif
                            
    3              0.000004   let a:ctx.expand = 'nothing'

FUNCTION  wilder#pipe#subpipeline#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/subpipeline.vim:1
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000009   return {_, x -> {ctx -> s:subpipeline(a:f, ctx, x)}}

FUNCTION  <lambda>30()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 19 times
Total time:   0.000682
 Self time:   0.000138

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>31()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 1 time
Total time:   0.000485
 Self time:   0.000022

count  total (s)   self (s)
                            return wilder#cmdline#prepare_file_completion(ctx, res, l:fuzzy)

FUNCTION  <lambda>32()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 1 time
Total time:   0.000111
 Self time:   0.000054

count  total (s)   self (s)
                            return [   {ctx, res -> s:getcompletion(ctx, res, l:fuzzy, l:use_python)},   wilder#result({     'value': {ctx, xs, data -> l:fuzzy == 0 ?       s:filter_file_in_path(ctx, xs, data) : xs},   }),   wilder#result({     'value': {ctx, xs -> get(res, 'relative_to_home_dir', 0) ?       map(xs, {i, x -> fnamemodify(x, ':~')}) : xs},   }), ]

FUNCTION  <lambda>33()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/subpipeline.vim:1
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            return {ctx -> s:subpipeline(a:f, ctx, x)}

FUNCTION  <lambda>36()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>39()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  wilder#main#get_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:599
Called 28 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   28              0.000047   return a:result.value[a:index]

FUNCTION  <SNR>98_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:62
Called 90 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
   90              0.000188   if type(a:component) isnot v:t_dict
   90              0.000091     return a:ctx.done
                              endif
                            
                              if has_key(a:component, 'pre_draw')
                                return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)

FUNCTION  <SNR>99_prepare_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 77 times
Total time:   0.002694
 Self time:   0.002694

count  total (s)   self (s)
   77              0.001372   let l:handler = { 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)}, 'on_error': {ctx, x -> a:on_error(ctx, x)}, }
                            
   77              0.000144   let s:id_index += 1
   77              0.000145   let l:handler_id = s:id_index
   77              0.000261   let s:handler_registry[s:id_index] = l:handler
                            
   77              0.000593   call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})

FUNCTION  provider#pythonx#Require()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:8
Called 1 time
Total time:   0.070900
 Self time:   0.000202

count  total (s)   self (s)
                              " Python host arguments
    1   0.000004   0.000003   let prog = provider#python3#Prog()
    1              0.000002   let args = [prog, '-c', 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; neovim.start_host()']
                            
                            
                              " Collect registered Python plugins into args
    1   0.000007   0.000003   let python_plugins = remote#host#PluginsForHost(a:host.name)
    2              0.000001   for plugin in python_plugins
    1              0.000001     call add(args, plugin.path)
    2              0.000000   endfor
                            
    1   0.070883   0.000189   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})

FUNCTION  <SNR>62_skip()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:30
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000023     return !nvim_win_get_config(0).focusable

FUNCTION  wilder#cmdline#main#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:36
Called 19 times
Total time:   0.023527
 Self time:   0.017355

count  total (s)   self (s)
                              " default
   19              0.000048   let a:ctx.expand = 'command'
   19              0.000029   let a:ctx.force = 0
                            
   19              0.000066   if empty(a:ctx.cmdline[a:ctx.pos :])
                                return
   19              0.000011   endif
                            
   19   0.001103   0.000287   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
   19              0.000009   endif
                            
                              " check if comment
   19              0.000039   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   19              0.000008   endif
                            
                              " skip range
   19   0.001909   0.000450   call wilder#cmdline#skip_range#do(a:ctx)
                            
   19   0.000779   0.000237   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
   19              0.000009   endif
                            
   19              0.000035   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   19              0.000008   endif
                            
                              " check if starts with | or :
                              " treat as a new command
   19              0.000069   if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   19              0.000009   endif
                            
   19              0.000031   let l:is_user_cmd = 0
                            
   19              0.000061   if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
   19              0.000012   else
   19              0.000036     let l:cmd_start = a:ctx.pos
                            
   19              0.000041     let l:char = a:ctx.cmdline[a:ctx.pos]
                            
   19              0.000043     if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
   19              0.000016     else
                                  " non-alphabet command
   19              0.000049       if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
   19              0.000010       else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
   19              0.000106         if a:ctx.cmdline[a:ctx.pos] ==# 'p' && a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' && a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
   19              0.000011         endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
  116              0.000342         while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char ==# '*'
   97              0.000107           let a:ctx.pos += 1
   97              0.000176           let l:char = a:ctx.cmdline[a:ctx.pos]
  116              0.000186         endwhile
   19              0.000012       endif
                            
   19              0.000035       if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
   19              0.000014       endif
                            
                                  " find the command
   19              0.000029       if a:ctx.pos > l:cmd_start
   19              0.000064         let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
   19              0.000038         let l:len = a:ctx.pos - l:cmd_start
                            
   19              0.000035         let l:char = l:cmd[0]
   19              0.000042         if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
   19              0.000010         endif
                            
   19              0.000081         let l:next_char = nr2char(char2nr(l:char) + 1)
                            
   19              0.000080         let l:i = s:command_char_pos[l:char]
   19              0.000102         let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
  242              0.000252         while l:i < l:end
  242              0.000575           let l:command = s:commands[l:i]
  242              0.000443           if l:cmd ==# l:command[: l:len - 1]
   19              0.000030             let a:ctx.cmd = l:command
   19              0.000014             break
  223              0.000781           endif
                            
  223              0.000226           let l:i += 1
  242              0.000124         endwhile
   19              0.000011       endif
   19              0.000010     endif
   19              0.000009   endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
   19              0.000047   if a:ctx.pos == len(a:ctx.cmdline)
    8              0.000017     let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
    8              0.000030     if l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
    8              0.000012       let a:ctx.pos = l:cmd_start
    8              0.000009       let a:ctx.cmd = ''
                                  " expand commands
    8              0.000006       return
                                endif
   11              0.000005   endif
                            
                              " no matching command found, treat as no arguments
   11              0.000021   if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' && stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
   11              0.000005   endif
                            
   11              0.000017   let a:ctx.expand = 'nothing'
                            
                              " handle !
   11              0.000021   if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
   11              0.000009   endif
                            
   11              0.000036   if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   11              0.000005   endif
                            
   11   0.000580   0.000097   call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
   11              0.000058   let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
   11              0.000017   let l:use_filter = 0
                            
   11              0.000028   if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
   11              0.000020   elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
   11              0.000024   elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
   11              0.000005   endif
                            
                              " Handle +cmd or ++opt
   11              0.000071   if a:ctx.cmdline[a:ctx.pos] ==# '+' && ((and(l:flags, s:EDITCMD) && !l:use_filter) || and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' && a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline) && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
   11              0.000008   endif
                            
                              " look for | for new command and " for comment
   11              0.000044   if and(l:flags, s:TRLBAR) && !l:use_filter
   10              0.000039     if a:ctx.cmd ==# 'redir' && a:ctx.cmdline[a:ctx.pos] ==# '@' && a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
   10              0.000005     endif
                            
   10              0.000019     let l:lookahead = a:ctx.pos
   65              0.000147     while l:lookahead < len(a:ctx.cmdline)
   55              0.000249       if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
   55              0.000027       endif
                            
                                  " Check if " indicates a comment or start of string
   55              0.000102       if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
   55              0.000104       elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
   55              0.000029       endif
                            
                                  " TODO: multibyte
   55              0.000079       let l:lookahead += 1
   65              0.000182     endwhile
   11              0.000007   endif
                            
                              " command does not take extra arguments
   11              0.000033   if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
   11              0.000008   endif
                            
                            
   11              0.000035   if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
   11              0.000005   endif
                            
   11              0.000024   if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
    1              0.000003     let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
    1              0.000003     if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
    1              0.000002     endif
                            
                                " Check if completing ~user
    1              0.000003     if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' || l:allow_backslash && l:char ==# '\' || !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) && a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
    1              0.000001     endif
                            
    1              0.000003     let a:ctx.pos = l:arg_start
    1              0.000002     let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
    1              0.000003     if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
    1              0.000001     endif
   11              0.000008   endif
                            
   11              0.000039   if a:ctx.cmd ==# 'find' || a:ctx.cmd ==# 'sfind' || a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
   11              0.000074   elseif a:ctx.cmd ==# 'cd' || a:ctx.cmd ==# 'chdir' || a:ctx.cmd ==# 'lcd' || a:ctx.cmd ==# 'lchdir' || a:ctx.cmd ==# 'tcd' || a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
   11              0.000016   elseif a:ctx.cmd ==# 'help'
    1              0.000002     let a:ctx.expand = 'help'
    1              0.000001     return
                              " command modifiers
   10              0.000031   elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
   10              0.000035   elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
   10              0.000014   elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
   10              0.000014   elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
   10              0.000014   elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
   10              0.000022   elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
   10              0.000020   elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
   10              0.000087   elseif a:ctx.cmd ==# 'isearch' || a:ctx.cmd ==# 'dsearch' || a:ctx.cmd ==# 'ilist' || a:ctx.cmd ==# 'dlist' || a:ctx.cmd ==# 'ijump' || a:ctx.cmd ==# 'psearch' || a:ctx.cmd ==# 'djump' || a:ctx.cmd ==# 'isplit' || a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
   10              0.000014   elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
   10              0.000022   elseif a:ctx.cmd ==# 'doautocmd' || a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
   10              0.000032   elseif a:ctx.cmd ==# 'set' || a:ctx.cmd ==# 'setglobal' || a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
   10              0.000099   elseif a:ctx.cmd ==# 'tag' || a:ctx.cmd ==# 'stag' || a:ctx.cmd ==# 'ptag' || a:ctx.cmd ==# 'ltag' || a:ctx.cmd ==# 'tselect' || a:ctx.cmd ==# 'stselect' || a:ctx.cmd ==# 'tjump' || a:ctx.cmd ==# 'stjump' || a:ctx.cmd ==# 'ptselect' || a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
   10              0.000013   elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
   10              0.000012   elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
   10              0.000174   elseif a:ctx.cmd ==# 'let' || a:ctx.cmd ==# 'if' || a:ctx.cmd ==# 'elseif' || a:ctx.cmd ==# 'while' || a:ctx.cmd ==# 'for' || a:ctx.cmd ==# 'echo' || a:ctx.cmd ==# 'echon' || a:ctx.cmd ==# 'execute' || a:ctx.cmd ==# 'echomsg' || a:ctx.cmd ==# 'echoerr' || a:ctx.cmd ==# 'call' || a:ctx.cmd ==# 'return' || a:ctx.cmd ==# 'cexpr' || a:ctx.cmd ==# 'caddexpr' || a:ctx.cmd ==# 'cgetexpr' || a:ctx.cmd ==# 'lexpr' || a:ctx.cmd ==# 'laddexpr' || a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
   10              0.000013   elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
   10              0.000013   elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
   10              0.000013   elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
   10              0.000012   elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
   10              0.000012   elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
   10              0.000030   elseif a:ctx.cmd ==# 'cscope' || a:ctx.cmd ==# 'lcscope' || a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
   10              0.000012   elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
   10              0.000029   elseif a:ctx.cmd ==# 'bdelete' || a:ctx.cmd ==# 'bwipeout' || a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
   10              0.000028   elseif a:ctx.cmd ==# 'buffer' || a:ctx.cmd ==# 'sbuffer' || a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
   10              0.000055   elseif a:ctx.cmd ==# 'abbreviate' || a:ctx.cmd ==# 'unabbreviate' || a:ctx.cmd[-3 :] ==# 'map' || a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
   10              0.000017   elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
   10              0.000015   elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
   10              0.000013   elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
   10              0.000012   elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
   10              0.000012   elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
   10              0.000011   elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
   10              0.000011   elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' || l:subcommand ==# 'ctype' || l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
   10              0.000013   elseif a:ctx.cmd ==# 'profile'
    9   0.003136   0.000264     call wilder#cmdline#profile#do(a:ctx)
    9              0.000005     return
    1              0.000002   elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
    1              0.000002   elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
    1              0.000001   endif

FUNCTION  <SNR>81_render_lines_from_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:275
Called 16 times
Total time:   0.048108
 Self time:   0.000295

count  total (s)   self (s)
                              " Multiple renders might be queued, skip if there is a newer render
   16              0.000048   if a:render_id != a:state.render_id || !a:state.active
                                return
   16              0.000007   endif
                            
   16   0.048019   0.000207   call s:render_lines(a:state, a:ctx, a:result)

FUNCTION  wilder#set_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:21
Called 2 times
Total time:   0.000018
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000001   if !a:0
                                call wilder#options#set(a:x)
    2              0.000000   else
    2   0.000013   0.000006     call wilder#options#set(a:x, a:1)
    2              0.000000   endif

FUNCTION  wilder#make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:86
Called 2 times
Total time:   0.001247
 Self time:   0.000066

count  total (s)   self (s)
    2   0.001247   0.000066   return wilder#highlight#make_hl(a:name, a:args, a:000)

FUNCTION  <lambda>40()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 1 time
Total time:   0.000180
 Self time:   0.000010

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>41()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:69
Called 1 time
Total time:   0.000026
 Self time:   0.000008

count  total (s)   self (s)
                            return s:set_data(data, a:chars)

FUNCTION  <lambda>42()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 1 time
Total time:   0.000175
 Self time:   0.000009

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>43()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 18 times
Total time:   0.000854
 Self time:   0.000472

count  total (s)   self (s)
                            return wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>47()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 18 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            return x

FUNCTION  <SNR>51_get_delim_multi()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:43
Called 338 times
Total time:   0.096119
 Self time:   0.007341

count  total (s)   self (s)
  338              0.000263   let l:best = {}
  585              0.001184   for l:e in get(get(b:, 'matchup_active_engines', {}), a:opts.type, [])
  336   0.090708   0.001930     let l:res = call(s:engines[l:e].get_delim, [a:opts])
  336              0.000283     if empty(l:res)
  247              0.000857       continue
   89              0.000017     endif
   89              0.000057     if a:opts.direction ==# 'current'
   89              0.000040       return l:res
                                elseif a:opts.direction ==# 'next' && (empty(l:best) || matchup#pos#smaller(l:res, l:best))
                                  let l:best = l:res
                                elseif a:opts.direction ==# 'prev' && (empty(l:best) || matchup#pos#larger(l:res, l:best))
                                  let l:best = l:res
                                endif
  249              0.000150   endfor
  249              0.000125   return l:best

FUNCTION  <SNR>62_func()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:386
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return exists('*' . a:name) ? '%{' . a:name . '()}' : '%{exists("*' . a:name . '")?' . a:name . '():""}'

FUNCTION  <SNR>86_make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:34
Called 8 times
Total time:   0.005724
 Self time:   0.000217

count  total (s)   self (s)
    8   0.001958   0.000068   let l:x = s:to_hl_list(a:x)
                            
   16              0.000010   for l:elem in a:xs
    8   0.001542   0.000028     let l:y = s:to_hl_list(l:elem)
    8   0.000389   0.000037     let l:x = s:combine_hl_list(l:x, l:y)
   16              0.000005   endfor
                            
    8   0.001793   0.000043   call s:make_hl_from_list(a:name, l:x)

FUNCTION  wilder#cmdline#python_get_file_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:318
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000003   if has_key(a:res, 'completions')
                                return a:res['completions']
    1              0.000001   endif
                            
    1              0.000003   let l:expand_arg = a:res.expand_arg
                            
    1              0.000006   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
    1              0.000013     return {ctx -> _wilder_python_get_file_completion( ctx, l:expand_arg, a:res.expand, get(a:res, 'has_wildcard', 0), get(a:res, 'path_prefix', ''), )}
                              endif
                            
                              if a:res.expand ==# 'user'
                                return {ctx -> _wilder_python_get_users(ctx, l:expand_arg, a:res.expand)}
                              endif
                            
                              return []

FUNCTION  <lambda>50()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 18 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>51()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 18 times
Total time:   0.002547
 Self time:   0.000314

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>52()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1177
Called 19 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                            return res.expand ==# 'lua'

FUNCTION  <lambda>53()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 19 times
Total time:   0.000408
 Self time:   0.000137

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  matchup#pos#get_cursor()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/pos.vim:17
Called 1439 times
Total time:   0.001587
 Self time:   0.001587

count  total (s)   self (s)
 1439              0.001276     return getcurpos()

FUNCTION  <SNR>94_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:26
Called 113 times
Total time:   0.069669
 Self time:   0.001889

count  total (s)   self (s)
  113              0.000174   if a:x isnot v:false
   57   0.001393   0.000338     call s:resolve(a:state, a:ctx, a:x)
   57              0.000040     return
   56              0.000025   endif
                            
   56              0.000086   let a:state.index += 1
                            
   56              0.000132   if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
   56              0.000023   endif
                            
   56   0.036718   0.002872   call wilder#pipeline#run( a:state.pipelines[a:state.index], {ctx, x -> s:on_finish(a:state, ctx, x)}, {ctx, x -> s:on_error(a:state, ctx, x)}, copy(a:state.original_ctx), copy(a:state.original_x), )

FUNCTION  wilder#cmdline#main#skip_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:683
Called 50 times
Total time:   0.001886
 Self time:   0.001497

count  total (s)   self (s)
   50              0.000149   if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
   50              0.000024   endif
                            
   61   0.001160   0.000771   while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
   12              0.000014     let a:ctx.pos += 1
                            
   12              0.000027     if empty(a:ctx.cmdline[a:ctx.pos])
    1              0.000001       return 0
   11              0.000006     endif
   60              0.000051   endwhile
                            
   49              0.000040   return 1

FUNCTION  lightline#update()
    Defined: ~/.local/share/nvim/lazy/lightline.vim/autoload/lightline.vim:13
Called 3 times
Total time:   0.000565
 Self time:   0.000044

count  total (s)   self (s)
    3   0.000041   0.000017   if s:skip() | return | endif
    1              0.000000   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
    1              0.000000   endif
    1              0.000001   if s:lightline.enable.statusline
    1              0.000002     let w = winnr()
    1   0.000503   0.000006     let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
    2              0.000002     for n in range(1, winnr('$'))
    1              0.000008       call setwinvar(n, '&statusline', s[n!=w])
    2              0.000000     endfor
    1              0.000000   endif

FUNCTION  wilder#cache#cache()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:1
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010   return { '_cache': {}, 'get': funcref('s:get'), 'set': funcref('s:set'), 'has_key': funcref('s:has_key'), 'clear': funcref('s:clear'), }

FUNCTION  wilder#subpipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:189
Called 4 times
Total time:   0.000247
 Self time:   0.000115

count  total (s)   self (s)
    4   0.000246   0.000114   return wilder#pipe#subpipeline#(a:f)

FUNCTION  wilder#renderer#popupmenu#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:3
Called 1 time
Total time:   0.003137
 Self time:   0.000409

count  total (s)   self (s)
    1              0.000003   let l:highlights = copy(get(a:opts, 'highlights', {}))
    1   0.001126   0.000258   let l:state = { 'highlights': extend(l:highlights, {   'default': get(a:opts, 'hl', 'Pmenu'),   'selected': get(a:opts, 'selected_hl', 'PmenuSel'),   'error': get(a:opts, 'error_hl', 'ErrorMsg'),   'empty_message': 'WarningMsg', }, 'keep'), 'ellipsis': wilder#render#to_printable(get(a:opts, 'ellipsis', '...')), 'apply_incsearch_fix': get(a:opts, 'apply_incsearch_fix', has('nvim') && !has('nvim-0.5.1')), 'reverse': get(a:opts, 'reverse', 0), 'highlight_mode': get(a:opts, 'highlight_mode', 'detailed'), 'left_offset': get(a:opts, 'left_offset', 1), 'zindex': get(a:opts, 'zindex', 250), 'top': get(a:opts, 'top', []), 'bottom': get(a:opts, 'bottom', []), 'empty_message': get(a:opts, 'empty_message', 0), 'empty_message_first_draw_delay': get(a:opts, 'empty_message_first_draw_delay', 100), 'error_message': get(a:opts, 'error_message', wilder#renderer#component#popupmenu_error_message#()), 'position': get(a:opts, 'position', funcref('s:get_position')), 'page': [-1, -1], 'buf': -1, 'win': -1, 'draw_cache': wilder#cache#cache(), 'highlight_cache': wilder#cache#cache(), 'run_id': -1, 'longest_line_width': 0, 'render_id': -1, 'active': 0, 'is_first_draw': 0, 'empty_message_first_draw_timer': -1, }
                            
    1              0.000001   let l:Max_height = get(a:opts, 'max_height', '50%')
    1              0.000002   if type(l:Max_height) is v:t_number && l:Max_height <= 0
                                let l:Max_height = 10000
    1              0.000000   endif
    1   0.000025   0.000005   let l:state.get_max_height = s:get_height_or_width_from_option(l:Max_height, 10000, 1)
                            
    1              0.000001   let l:Min_height = get(a:opts, 'min_height', 0)
    1   0.000007   0.000004   let l:state.get_min_height = s:get_height_or_width_from_option(l:Min_height, 0, 1)
                            
    1              0.000001   let l:Max_width = get(a:opts, 'max_width', '50%')
    1              0.000001   if type(l:Max_width) is v:t_number && l:Max_width <= 0
                                let l:Max_width = 10000
    1              0.000000   endif
    1   0.000018   0.000004   let l:state.get_max_width = s:get_height_or_width_from_option(l:Max_width, 10000, 0)
                            
    1              0.000001   let l:Min_width = get(a:opts, 'min_width', 16)
    1   0.000006   0.000004   let l:state.get_min_width = s:get_height_or_width_from_option(l:Min_width, 16, 0)
                            
    1              0.000001   if exists('+pumblend')
    1              0.000001     if has_key(a:opts, 'pumblend')
                                  let l:state.pumblend = a:opts.pumblend
    1              0.000001     elseif has_key(a:opts, 'winblend')
                                  " DEPRECATED: Use 'pumblend'
                                  let l:state.pumblend = a:opts.winblend
    1              0.000000     else
                                  " -1 to indicate unset
    1              0.000001       let l:state.pumblend = -1
    1              0.000000     endif
                              else
                                let l:state.pumblend = -1
    1              0.000000   endif
                            
    1              0.000001   if !has_key(a:opts, 'left') && !has_key(a:opts, 'right')
    1              0.000001     let l:state.left = [' ']
    1   0.000251   0.000004     let l:state.right = [' ', wilder#popupmenu_scrollbar()]
                              else
                                let l:state.left = get(a:opts, 'left', [])
                                let l:state.right = get(a:opts, 'right', [])
    1              0.000000   endif
                            
    1              0.000001   if !has_key(l:state.highlights, 'accent')
    1   0.000809   0.000005     let l:state.highlights.accent = wilder#hl_with_attr( 'WilderPoppupMenuAccent', l:state.highlights['default'], 'underline', 'bold')
    1              0.000000   endif
                            
    1              0.000001   if !has_key(l:state.highlights, 'selected_accent')
    1   0.000476   0.000005     let l:state.highlights.selected_accent = wilder#hl_with_attr( 'WilderPopupMenuSelectedAccent', l:state.highlights['selected'], 'underline', 'bold')
    1              0.000000   endif
                            
    1              0.000001   if has_key(a:opts, 'highlighter')
                                let l:Highlighter = a:opts['highlighter']
    1              0.000001   elseif has_key(a:opts, 'apply_highlights')
                                let l:Highlighter = a:opts['apply_highlights']
    1              0.000000   else
    1              0.000001     let l:Highlighter = 0
    1              0.000000   endif
                            
    1              0.000001   if type(l:Highlighter) is v:t_list
                                let l:Highlighter = wilder#highlighter#apply_first(l:Highlighter)
    1              0.000000   endif
                            
    1              0.000001   let l:state.highlighter = l:Highlighter
                            
    1              0.000001   if a:opts.mode ==# 'float'
    1   0.000370   0.000071     let l:state.api = wilder#renderer#nvim_api#()
                              else
                                let l:state.api = wilder#renderer#vim_api#()
    1              0.000000   endif
                            
    1              0.000007   return { 'render': {ctx, result -> s:render(l:state, ctx, result)}, 'pre_hook': {ctx -> s:pre_hook(l:state, ctx)}, 'post_hook': {ctx -> s:post_hook(l:state, ctx)}, }

FUNCTION  remote#define#FunctionBootstrap()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/remote/define.vim:145
Called 2 times
Total time:   0.071359
 Self time:   0.000168

count  total (s)   self (s)
    2   0.070981   0.000020   let channel = remote#host#Require(a:host)
                            
    2              0.000083   exe 'autocmd! '.a:group
    2              0.000017   exe 'augroup! '.a:group
    2              0.000002   if channel
    2   0.000260   0.000030     call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name, a:opts)
                              else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
    2              0.000001   endif

FUNCTION  wilder#cmdline#is_user_command()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:608
Called 19 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
   19              0.000093   return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'

FUNCTION  matchup#delim#get_current()
    Defined: ~/.local/share/nvim/lazy/vim-matchup/autoload/matchup/delim.vim:28
Called 338 times
Total time:   0.099431
 Self time:   0.003312

count  total (s)   self (s)
  338   0.099346   0.003227   return s:get_delim_multi(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  <lambda>62()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 19 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>65()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 19 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                            return x

FUNCTION  <SNR>89_convert_result_to_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:753
Called 19 times
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
   19              0.000125   let l:data = { 'pos': a:res.pos, 'cmdline.command': a:res.cmd, 'cmdline.expand': a:res.expand, 'cmdline.arg': a:res.arg, }
                            
   19              0.000040   if has_key(a:res, 'path_prefix')
    1              0.000004     let l:data['cmdline.path_prefix'] = a:res.path_prefix
   19              0.000010   endif
                            
   19              0.000033   if has_key(a:res, 'match_arg')
   19              0.000051     let l:data['cmdline.match_arg'] = a:res.match_arg
   19              0.000009   endif
                            
   19              0.000031   if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
   19              0.000008   endif
                            
   19              0.000022   return l:data

FUNCTION  <lambda>69()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 19 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <SNR>91_get_python_executable_from_host_var()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-d086bc1/share/nvim/runtime/autoload/provider/pythonx.vim:23
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000052   return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : execute("throw 'unsupported'")).'_host_prog', ''), v:true)

FUNCTION  <SNR>81_get_height_or_width_from_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:831
Called 4 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    4              0.000003   if type(a:opt) is v:t_number
    2              0.000003     return {-> s:clamp(a:opt, a:is_height)}
    2              0.000000   endif
                            
    2              0.000002   if type(a:opt) is v:t_func
                                return {ctx, result -> s:clamp(a:opt(ctx, result), a:is_height)}
    2              0.000000   endif
                            
    2              0.000008   let l:matches = matchlist(a:opt, '^\(\d\+%\)$')
    2              0.000002   if len(l:matches) >= 2
    2              0.000005     let l:percent = 0.01 * str2nr(l:matches[1])
    2              0.000001     if a:is_height
    1              0.000003       return {-> s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)}
    1              0.000000     else
    1              0.000002       return {-> s:clamp(float2nr(l:percent * &columns), a:is_height)}
                                endif
                              endif
                            
                              return {-> s:clamp(a:default, a:is_height)}

FUNCTION  wilder#cmdline#draw_path()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:744
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   if get(a:data, 'cmdline.expand', '') ==# 'file_in_path'
                                return a:x
    1              0.000000   endif
                            
    1              0.000003   let l:path_prefix = get(a:data, 'cmdline.path_prefix', '')
    1              0.000003   return a:x[len(l:path_prefix) :]

FUNCTION  <SNR>99_run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:118
Called 215 times
Total time:   0.222003
 Self time:   0.028155

count  total (s)   self (s)
  215              0.000507   if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
  215              0.000098   endif
                            
  215              0.000396   if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
  215              0.000089   endif
                            
  215              0.000259   let l:x = a:x
  215              0.000234   let l:i = a:i
                            
  485              0.001127   while l:i < len(a:pipeline)
  408              0.002863     let l:F = a:pipeline[l:i]
                            
  408              0.000767     if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
  408              0.000171     endif
                            
  408              0.000246     try
  408   0.113849   0.007121       let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
  408              0.000282     endtry
                            
  408              0.000956     if l:Result is v:false || l:Result is v:true
   61   0.004180   0.003087       call a:on_finish(a:ctx, l:Result)
   61              0.000036       return
  347              0.000148     endif
                            
  347              0.000926     if type(l:Result) is v:t_func
   77              0.000268       let l:ctx = copy(a:ctx)
   77   0.003649   0.000955       call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
   77              0.000057       return
  270              0.000103     endif
                            
  270              0.000381     let l:x = l:Result
  270              0.000310     let l:i += 1
  347              0.001240   endwhile
                            
   77   0.012821   0.000394   call a:on_finish(a:ctx, l:x)

FUNCTION  wilder#pipe#result#()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:1
Called 15 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   15              0.000017   let l:args = a:0 ? a:1 : {}
   15              0.000034   return {ctx, x -> s:result_start(l:args, ctx, x)}

FUNCTION  <lambda>70()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 19 times
Total time:   0.000704
 Self time:   0.000195

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>71()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 19 times
Total time:   0.031605
 Self time:   0.000139

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  <lambda>73()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 19 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>74()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 19 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>75()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 19 times
Total time:   0.000537
 Self time:   0.000187

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>76()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 19 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>77()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 19 times
Total time:   0.000311
 Self time:   0.000203

count  total (s)   self (s)
                            return l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs

FUNCTION  <lambda>78()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 19 times
Total time:   0.000478
 Self time:   0.000125

count  total (s)   self (s)
                            return s:set_query(data)

FUNCTION  <lambda>79()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 19 times
Total time:   0.003962
 Self time:   0.000192

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  338   0.235345   0.003143  3()
  338   0.232202   0.034833  4()
  215   0.222003   0.028155  <SNR>99_run()
  138   0.184892   0.001342  wilder#pipeline#run()
  263   0.165514   0.008209  wilder#lua#call_wrapped_function()
    8   0.153746   0.000154  wilder#lua#call()
    1   0.147681   0.000067  wilder#cmdline_pipeline()
    1   0.147014   0.000110  wilder#cmdline#pipeline()
    2   0.146008   0.000035  <SNR>89_get_opts()
    4   0.145984   0.000189  wilder#options#get()
    1   0.145230   0.000005  provider#pythonx#Detect()
    1   0.145225   0.000068  provider#pythonx#DetectByModule()
    4   0.145101   0.000570  provider#pythonx#CheckForModule()
    4   0.144532   0.000223  <SNR>91_import_module()
   78   0.122691   0.001592  <SNR>99_call()
   57   0.107299   0.003368  <SNR>94_branch()
  338   0.099431   0.003312  matchup#delim#get_current()
  338   0.096119   0.007341  <SNR>51_get_delim_multi()
  336   0.088778   0.046817  <SNR>51_get_delim()
    3   0.080154   0.000556  <SNR>96_start()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1              0.070418  provider#Poll()
  336   0.088778   0.046817  <SNR>51_get_delim()
 1992   0.055243   0.043656  wilder#lua#wrap()
  338   0.232202   0.034833  4()
   89   0.044144   0.032570  <SNR>51_get_matching_delims()
  215   0.222003   0.028155  <SNR>99_run()
   16              0.022453  <SNR>98_redraw()
   18   0.021497   0.021060  wilder#cmdline#getcompletion()
   89   0.018861   0.017793  <SNR>51_parser_delim_new()
   19   0.023527   0.017355  wilder#cmdline#main#do()
 1369              0.016297  matchup#perf#toc()
    2              0.010503  remote#define#request()
 1530   0.016516   0.010256  <SNR>50_parse_args()
   89   0.056383   0.010095  matchup#delim#get_matching()
  341   0.010097   0.009557  1()
  395              0.008441  lightline#link()
   60   0.023220   0.008423  <SNR>62_line()
  263   0.165514   0.008209  wilder#lua#call_wrapped_function()
   89   0.008703   0.008029  <SNR>22_add_matches()
  338   0.096119   0.007341  <SNR>51_get_delim_multi()

